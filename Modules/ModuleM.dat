<MOV>
[1]
"MOV: Move"
""
"NOTES:"
"------"
"*The moffs8, moffs16, and moffs32 operands specify a simple offset relative to the segment base , where 8, 16, and 32 refer to the size of the data. The address-size attribute of the instruction determines the size of the offset, either 16 or 32 bits."
"** In 32-bit mode, the assembler may insert the 16-bit operand-size prefix with this instruction."
""
"Copies the second operand (source operand) to the first operand (destination operand). The source operand can be an immediate value, general-purpose register, segment register, or memory location; the destination register can be a general-purpose register, segment register, or memory location. Both operands must be the same size, which can be a byte, a word, or a doubleword."
"The MOV instruction cannot be used to load the CS register. Attempting to do so results in an invalid opcode exception (#UD). To load the CS register, use the far JMP, CALL, or RET instruction."
"If the destination operand is a segment register (DS, ES, FS, GS, or SS), the source operand must be a valid segment selector. In protected mode, moving a segment selector into a segment register automatically causes the segment descriptor information associated with that segment selector to be loaded into the hidden (shadow) part of the segment register. While loading this information, the segment selector and segment descriptor information is validated (see the “Operation” algorithm). The segment descriptor data is obtained from the GDT or LDT entry for the specified segment selector."
"A null segment selector (values 0000-0003) can be loaded into the DS, ES, FS, and GS registers without causing a protection exception. However, any subsequent attempt to reference a segment whose corresponding segment register is loaded with a null value causes a general protection exception (#GP) and no memory reference occurs."
"Loading the SS register with a MOV instruction inhibits all interrupts until after the execution of the next instruction. This operation allows a stack pointer to be loaded into the ESP register with the next instruction (MOV ESP, stack-pointer value) before an interrupt occurs 1 . The LSS instruction offers a more efficient method of loading the SS and ESP registers."
"When operating in 32-bit mode and moving data between a segment register and a general-purpose register, the Intel Architecture 32-bit processors do not require the use of the 16-bit operand-size prefix (a byte with the value 66H) with this instruction, but most assemblers will insert it if the standard form of the instruction is used (for example, MOV DS, AX). The processor will execute this instruction correctly, but it will usually require an extra clock. With most assemblers, using the instruction form MOV DS, EAX will avoid this unneeded 66H prefix. When the processor executes the instruction with a 32-bit general-purpose register, it assumes that the 16 least-significant bits of the general-purpose register are the destination or source operand. If the register is a destination operand, the resulting value in the two high-order bytes of the register is implementation dependent. For the Pentium Pro processor, the two high-order bytes are filled with zeros; for earlier 32-bit Intel Architecture processors, the two high order bytes are undefined."
""
"NOTE: In a sequence of instructions that individually delay interrupts past the following instruction, only the first instruction in the sequence is guaranteed to delay the interrupt, but subsequent interrupt-delaying instructions may not delay the interrupt. Thus, in the following instruction sequence:"
""
"STI"
"MOV SS, EAX"
"MOV ESP, EBP"
""
"interrupts may be recognized before MOV ESP, EBP executes, because STI also delays interrupts for one instruction."
[2]
"DEST ¬ SRC;"
"Loading a segment register while in protected mode results in special checks and actions, as described in the following listing. These checks are performed on the segment selector and the segment descriptor it points to."
"IF SS is loaded;"
"THEN"
"IF segment selector is null"
"THEN #GP(0);"
"FI;"
"IF segment selector index is outside descriptor table limits"
"OR segment selector's RPL ¹ CPL"
"OR segment is not a writable data segment"
"OR DPL ¹ CPL"
"THEN #GP(selector);"
"FI;"
"IF segment not marked present"
"THEN #SS(selector);"
"ELSE"
"SS ¬ segment selector;"
"SS ¬ segment descriptor;"
"FI;"
"FI;"
"IF DS, ES, FS or GS is loaded with non-null selector;"
"THEN"
"IF segment selector index is outside descriptor table limits"
"OR segment is not a data or readable code segment"
"OR ((segment is a data or nonconforming code segment)"
"AND (both RPL and CPL > DPL))"
"THEN #GP(selector);"
"IF segment not marked present"
"THEN #NP(selector);"
"ELSE"
"SegmentRegister ¬ segment selector;"
"SegmentRegister ¬ segment descriptor;"
"FI;"
"FI;"
"IF DS, ES, FS or GS is loaded with a null selector;"
"THEN"
"SegmentRegister ¬ segment selector;"
"SegmentRegister ¬ segment descriptor;"
"FI;"
[3]
"None."
[4]
"Protected Mode Exceptions"
""
"#GP(0) If attempt is made to load SS register with null segment selector. If the destination operand is in a nonwritable segment. If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit. If the DS, ES, FS, or GS register contains a null segment selector."
"#GP(selector) If segment selector index is outside descriptor table limits. If the SS register is being loaded and the segment selector's RPL and the segment descriptor’s DPL are not equal to the CPL. If the SS register is being loaded and the segment pointed to is a nonwritable data segment. If the DS, ES, FS, or GS register is being loaded and the segment pointed to is not a data or readable code segment. If the DS, ES, FS, or GS register is being loaded and the segment pointed to is a data or nonconforming code segment, but both the RPL and the CPL are greater than the DPL."
"#SS(0) If a memory operand effective address is outside the SS segment limit."
"#SS(selector) If the SS register is being loaded and the segment pointed to is marked not present."
"#NP If the DS, ES, FS, or GS register is being loaded and the segment pointed to is marked not present."
"#PF(fault-code) If a page fault occurs."
"#AC(0) If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3."
"#UD If attempt is made to load the CS register."
""
"Real-Address Mode Exceptions"
""
"#GP If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit."
"#SS If a memory operand effective address is outside the SS segment limit."
"#UD If attempt is made to load the CS register."
""
"Virtual-8086 Mode Exceptions"
""
"#GP(0) If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit."
"#SS(0) If a memory operand effective address is outside the SS segment limit."
"#PF(fault-code) If a page fault occurs."
"#AC(0) If alignment checking is enabled and an unaligned memory reference is made."
"#UD If attempt is made to load the CS register."
[5]
"88 / r MOV r/m8,r8 Move r8 to r/m8"
"89 / r MOV r/m16,r16 Move r16 to r/m16"
"89 / r MOV r/m32,r32 Move r32 to r/m32"
"8A / r MOV r8,r/m8 Move r/m8 to r8"
"8B / r MOV r16,r/m16 Move r/m16 to r16"
"8B / r MOV r32,r/m32 Move r/m32 to r32"
"8C / r MOV r/m16,Sreg** Move segment register to r/m16"
"8E / r MOV Sreg,r/m16** Move r/m16 to segment register"
"A0 MOV AL, moffs8* Move byte at ( seg:offset) to AL"
"A1 MOV AX, moffs16* Move word at ( seg:offset) to AX"
"A1 MOV EAX, moffs32* Move doubleword at ( seg:offset) to EAX"
"A2 MOV moffs8*,AL Move AL to ( seg:offset)"
"A3 MOV moffs16*,AX Move AX to ( seg:offset)"
"A3 MOV moffs32*,EAX Move EAX to ( seg:offset)"
"B0+ rb MOV r8,imm8 Move imm8 to r8"
"B8+ rw MOV r16,imm16 Move imm16 to r16"
"B8+ rd MOV r32,imm32 Move imm32 to r32"
"C6 / 0 MOV r/m8,imm8 Move imm8 to r/m8"
"C7 / 0 MOV r/m16,imm16 Move imm16 to r/m16"
"C7 / 0 MOV r/m32,imm32 Move imm32 to r/m32"
[6]
</MOV>
<MOVD>
[1]
"MOVD: Move 32 Bits"
""
"Copies doubleword from the source operand (second operand) to the destination operand (first operand). Source and destination operands can be MMX registers, memory locations, or 32-bit general-purpose registers; however, data cannot be transferred from an MMX register to an MMX register, from one memory location to another memory location, or from one general-purpose register to another general-purpose register."
"When the destination operand is an MMX register, the 32-bit source value is written to the low-order 32 bits of the 64-bit MMX register and zero-extended to 64 bits. When the source operand is an MMX register, the low-order 32 bits of the MMX register are written to the 32-bit general-purpose register or 32-bit memory location selected with the destination operand."
[2]
"IF DEST is MMX register"
"THEN"
"DEST ¬ ZeroExtend(SRC);"
"ELSE (* SRC is MMX register *)"
"DEST ¬ LowOrderDoubleword(SRC);"
[3]
"None."
[4]
"Protected Mode Exceptions"
""
"#GP(0) If the destination operand is in a nonwritable segment. If a memory operand effective address is outside the CS, DS, ES, FS or GS segment limit."
"#SS(0) If a memory operand effective address is outside the SS segment limit."
"#UD If EM in CR0 is set."
"#NM If TS in CR0 is set."
"#MF If there is a pending FPU exception."
"#PF(fault-code) If a page fault occurs."
"#AC(0) If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3."
""
"Real-Address Mode Exceptions"
""
"#GP If any part of the operand lies outside of the effective address space from 0 to FFFFH."
"#UD If EM in CR0 is set."
"#NM If TS in CR0 is set."
"#MF If there is a pending FPU exception."
""
"Virtual-8086 Mode Exceptions"
""
"#GP If any part of the operand lies outside of the effective address space from 0 to FFFFH."
"#UD If EM in CR0 is set."
"#NM If TS in CR0 is set."
"#MF If there is a pending FPU exception."
"#PF(fault-code) If a page fault occurs."
"#AC(0) If alignment checking is enabled and an unaligned memory reference is made."
[5]
"0F 6E /r MOVD mm, r/m32 Move doubleword from r/m32 to mm."
"0F 7E /r MOVD r/m32, mm Move doubleword from mm to r/m32."
[6]
</MOVD>
<MOVQ>
[1]
"MOVQ: Move 64 Bits"
""
"Copies quadword from the source operand (second operand) to the destination operand (first operand). A source or destination operand can be either an MMX register or a memory location; however, data cannot be transferred from one memory location to another memory location. Data can be transferred from one MMX register to another MMX register."
[2]
"DEST ¬ SRC;"
[3]
"None."
[4]
"Protected Mode Exceptions"
""
"#GP(0) If the destination operand is in a nonwritable segment. If a memory operand effective address is outside the CS, DS, ES, FS or GS segment limit."
"#SS(0) If a memory operand effective address is outside the SS segment limit."
"#UD If EM in CR0 is set."
"#NM If TS in CR0 is set."
"#MF If there is a pending FPU exception."
"#PF(fault-code) If a page fault occurs."
"#AC(0) If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3."
""
"Real-Address Mode Exceptions"
""
"#GP If any part of the operand lies outside of the effective address space from 0 to FFFFH."
"#UD If EM in CR0 is set."
"#NM If TS in CR0 is set."
"#MF If there is a pending FPU exception."
""
"Virtual-8086 Mode Exceptions"
""
"#GP If any part of the operand lies outside of the effective address space from 0 to FFFFH."
"#UD If EM in CR0 is set."
"#NM If TS in CR0 is set."
"#MF If there is a pending FPU exception."
"#PF(fault-code) If a page fault occurs."
"#AC(0) If alignment checking is enabled and an unaligned memory reference is made."
[5]
"0F 6F /r MOVQ mm, mm/m64 Move quadword from mm/m64 to mm."
"0F 7F /r MOVQ mm/m64, mm Move quadword from mm to mm/m64."
[6]
</MOVQ>
<MOVS>
<MOVSB>
<MOVSD>
<MOVSW>
[1]
"MOVS/MOVSB/MOVSW/MOVSD: Move Data from String to String"
""
"Moves the byte, word, or doubleword specified with the second operand (source operand) to the location specified with the first operand (destination operand). Both the source and destination operands are located in memory. The address of the source operand is read from the DS:ESI or the DS:SI registers (depending on the address-size attribute of the instruction, 32 or 16, respectively). The address of the destination operand is read from the ES:EDI or the ES:DI registers (again depending on the address-size attribute of the instruction). The DS segment may be overridden with a segment override prefix, but the ES segment cannot be overridden."
"At the assembly-code level, two forms of this instruction are allowed: the “explicit-operands” form and the “no-operands” form. The explicit-operands form (specified with the MOVS mnemonic) allows the source and destination operands to be specified explicitly. Here, the source and destination operands should be symbols that indicate the size and location of the source value and the destination, respectively. This explicit-operands form is provided to allow documentation; however, note that the documentation provided by this form can be misleading. That is, the source and destination operand symbols must specify the correct type (size) of the operands (bytes, words, or doublewords), but they do not have to specify the correct location. The locations of the source and destination operands are always specified by the DS:(E)SI and ES:(E)DI registers, which must be loaded correctly before the move string instruction is executed."
"The no-operands form provides “short forms” of the byte, word, and doubleword versions of the MOVS instructions. Here also DS:(E)SI and ES:(E)DI are assumed to be the source and destination operands, respectively. The size of the source and destination operands is selected with the mnemonic: MOVSB (byte move), MOVSW (word move), or MOVSD (doubleword move)."
"After the move operation, the (E)SI and (E)DI registers are incremented or decremented automatically according to the setting of the DF flag in the EFLAGS register. (If the DF flag is 0, the (E)SI and (E)DI register are incremented; if the DF flag is 1, the (E)SI and (E)DI registers are decremented.) The registers are incremented or decremented by 1 for byte operations, by 2 for word operations, or by 4 for doubleword operations."
"The MOVS, MOVSB, MOVSW, and MOVSD instructions can be preceded by the REP prefix for block moves of ECX bytes, words, or doublewords."
[2]
"DEST ¬SRC;"
"IF (byte move)"
"THEN IF DF = 0"
"THEN"
"(E)SI ¬ (E)SI + 1;"
"(E)DI ¬ (E)DI + 1;"
"ELSE"
"(E)SI ¬ (E)SI – 1;"
"(E)DI ¬ (E)DI – 1;"
"FI;"
"ELSE IF (word move)"
"THEN IF DF = 0"
"(E)SI ¬ (E)SI + 2;"
"(E)DI ¬ (E)DI + 2;"
"ELSE"
"(E)SI ¬ (E)SI – 2;"
"(E)DI ¬ (E)DI – 2;"
"FI;"
"ELSE (* doubleword move*)"
"THEN IF DF = 0"
"(E)SI ¬ (E)SI + 4;"
"(E)DI ¬ (E)DI + 4;"
"ELSE"
"(E)SI ¬ (E)SI – 4;"
"(E)DI ¬ (E)DI – 4;"
"FI;"
"FI;"
[3]
"None."
[4]
"Protected Mode Exceptions"
""
"#GP(0) If the destination is located in a nonwritable segment. If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit. If the DS, ES, FS, or GS register contains a null segment selector."
"#SS(0) If a memory operand effective address is outside the SS segment limit."
"#PF(fault-code) If a page fault occurs."
"#AC(0) If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3."
""
"Real-Address Mode Exceptions"
""
"#GP If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit."
"#SS If a memory operand effective address is outside the SS segment limit."
""
"Virtual-8086 Mode Exceptions"
""
"#GP(0) If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit."
"#SS(0) If a memory operand effective address is outside the SS segment limit."
"#PF(fault-code) If a page fault occurs."
"#AC(0) If alignment checking is enabled and an unaligned memory reference is made."
[5]
"A4 MOVS m8, m8 Move byte at address DS:(E)SI to address ES:(E)DI"
"A5 MOVS m16, m16 Move word at address DS:(E)SI to address ES:(E)DI"
"A5 MOVS m32, m32 Move doubleword at address DS:(E)SI to address ES:(E)DI"
"A4 MOVSB Move byte at address DS:(E)SI to address ES:(E)DI"
"A5 MOVSW Move word at address DS:(E)SI to address ES:(E)DI"
"A5 MOVSD Move doubleword at address DS:(E)SI to address ES:(E)DI"
[6]
</MOVS>
</MOVSB>
</MOVSD>
</MOVSW>
<MOVSX>
[1]
"MOVSX: Move with Sign-Extension"
""
"Copies the contents of the source operand (register or memory location) to the destination operand (register) and sign extends the value to 16 or 32 bits. The size of the converted value depends on the operand-size attribute."
[2]
"DEST ¬ SignExtend(SRC);"
[3]
"None."
[4]
"Protected Mode Exceptions"
""
"#GP(0) If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit. If the DS, ES, FS, or GS register contains a null segment selector."
"#SS(0) If a memory operand effective address is outside the SS segment limit."
"#PF(fault-code) If a page fault occurs."
"#AC(0) If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3."
""
"Real-Address Mode Exceptions"
""
"#GP If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit."
"#SS If a memory operand effective address is outside the SS segment limit."
""
"Virtual-8086 Mode Exceptions"
""
"#GP(0) If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit."
"#SS(0) If a memory operand effective address is outside the SS segment limit."
"#PF(fault-code) If a page fault occurs."
[5]
"0F BE / r MOVSX r16,r/m8 Move byte to word with sign-extension"
"0F BE / r MOVSX r32,r/m8 Move byte to doubleword, sign-extension"
"0F BF / r MOVSX r32,r/m16 Move word to doubleword, sign-extension"
[6]
</MOVSX>
<MOVZX>
[1]
"MOVZX: Move with Zero-Extend"
""
"Copies the contents of the source operand (register or memory location) to the destination operand (register) and zero extends the value to 16 or 32 bits. The size of the converted value depends on the operand-size attribute"
[2]
"DEST ¬ ZeroExtend(SRC);"
[3]
"None."
[4]
"Protected Mode Exceptions"
""
"#GP(0) If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit. If the DS, ES, FS, or GS register contains a null segment selector."
"#SS(0) If a memory operand effective address is outside the SS segment limit."
"#PF(fault-code) If a page fault occurs."
"#AC(0) If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3."
""
"Real-Address Mode Exceptions"
""
"#GP If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit."
"#SS If a memory operand effective address is outside the SS segment limit."
""
"Virtual-8086 Mode Exceptions"
""
"#GP(0) If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit."
"#SS(0) If a memory operand effective address is outside the SS segment limit."
"#PF(fault-code) If a page fault occurs."
"#AC(0) If alignment checking is enabled and an unaligned memory reference is made."
[5]
"0F B6 / r MOVZX r16,r/m8 Move byte to word with zero-extension"
"0F B6 / r MOVZX r32,r/m8 Move byte to doubleword, zero-extension"
"0F B7 / r MOVZX r32,r/m16 Move word to doubleword, zero-extension"
[6]
</MOVZX>
<MUL>
[1]
"MUL: Unsigned Multiply"
""
"Performs an unsigned multiplication of the first operand (destination operand) and the second operand (source operand) and stores the result in the destination operand. The destination operand is an implied operand located in register AL, AX or EAX (depending on the size of the operand); the source operand is located in a general-purpose register or a memory location."
"The result is stored in register AX, register pair DX:AX, or register pair EDX:EAX (depending on the operand size), with the high-order bits of the product contained in register AH, DX, or EDX, respectively. If the high-order bits of the product are 0, the CF and OF flags are cleared; otherwise, the flags are set."
[2]
"IF byte operation"
"THEN"
"AX ¬ AL * SRC"
"ELSE (* word or doubleword operation *)"
"IF OperandSize = 16"
"THEN"
"DX:AX ¬ AX * SRC"
"ELSE (* OperandSize = 32 *)"
"EDX:EAX ¬ EAX * SRC"
"FI;"
"FI;"
[3]
"The OF and CF flags are cleared to 0 if the upper half of the result is 0; otherwise, they are set to 1. The SF, ZF, AF, and PF flags are undefined."
[4]
"Protected Mode Exceptions"
""
"#GP(0) If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit. If the DS, ES, FS, or GS register contains a null segment selector."
"#SS(0) If a memory operand effective address is outside the SS segment limit."
"#PF(fault-code) If a page fault occurs."
"#AC(0) If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3."
""
"Real-Address Mode Exceptions"
""
"#GP If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit."
"#SS If a memory operand effective address is outside the SS segment limit."
""
"Virtual-8086 Mode Exceptions"
""
"#GP(0) If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit."
"#SS(0) If a memory operand effective address is outside the SS segment limit."
"#PF(fault-code) If a page fault occurs."
"#AC(0) If alignment checking is enabled and an unaligned memory reference is made."
[5]
"F6 /4 MUL r/m8 Unsigned multiply (AX ¬ AL * r/m8)"
"F7 /4 MUL r/m16 Unsigned multiply (DX:AX ¬ AX * r/m16)"
"F7 /4 MUL r/m32 Unsigned multiply (EDX:EAX ¬ EAX * r/m32)"
[6]
</MUL>