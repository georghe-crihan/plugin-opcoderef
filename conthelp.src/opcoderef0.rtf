{\rtf1
\deff1{\fonttbl{\f1\fnil default;}}
!{\footnote JumpKeyword(Contents)}
\page
${\footnote AAA,Description}
K{\footnote AAA,AAA;AAA,Description}
#{\footnote AAA::1}

{\fs20\b AAA}\tab{\b Description}\par\par
AAA: ASCII Adjust After Addition
\par 
\par Adjusts the sum of two unpacked BCD values to create an unpacked BCD result. The AL register is the implied source and destination operand for this instruction. The AAA instruction is only useful when it follows an ADD instruction that adds (binary addition) two unpacked BCD values and stores a byte result in the AL register. The AAA instruction then adjusts the contents of the AL register to contain the correct 1-digit unpacked BCD result.
\par If the addition produces a decimal carry the AH register is incremented by 1 and the CF and AF flags are set. If there was no decimal carry the CF and AF flags are cleared and the AH register is unchanged. In either case bits 4 through 7 of the AL register are cleared to 0.
{\page}

${\footnote AAA,Operation}
K{\footnote AAA,AAA;AAA,Operation}
#{\footnote AAA::2}

{\fs20\b AAA}\tab{\b Operation}\par\par
IF ((AL AND 0FH) > 9) OR (AF = 1)
\par THEN
\par AL <- (AL + 6);
\par AH <- AH + 1;
\par AF <- 1;
\par CF <- 1;
\par ELSE
\par AF <- 0;
\par CF <- 0;
\par FI,
\par AL <- AL AND 0FH;
{\page}

${\footnote AAA,Flags affected}
K{\footnote AAA,AAA;AAA,Flags affected}
#{\footnote AAA::3}

{\fs20\b AAA}\tab{\b Flags affected}\par\par
The AF and CF flags are set to 1 if the adjustment results in a decimal carry; otherwise they are cleared to 0. The OF - SF - ZF and PF flags are undefined.
{\page}

${\footnote AAA,Exceptions}
K{\footnote AAA,AAA;AAA,Exceptions}
#{\footnote AAA::4}

{\fs20\b AAA}\tab{\b Exceptions}\par\par
(All Operating Modes)
\par None.
{\page}

${\footnote AAA,Opcode}
K{\footnote AAA,AAA;AAA,Opcode}
#{\footnote AAA::5}

{\fs20\b AAA}\tab{\b Opcode}\par\par
37 AAA ASCII adjust AL after addition
{\page}

${\footnote AAD,Description}
K{\footnote AAD,AAD;AAD,Description}
#{\footnote AAD::1}

{\fs20\b AAD}\tab{\b Description}\par\par
AAD: ASCII Adjust AX Before Division
\par 
\par Adjusts two unpacked BCD digits (the least-significant digit in the AL register and the most-significant digit in the AH register) so that a division operation performed on the result will yield a correct unpacked BCD value. The AAD instruction is only useful when it precedes a DIV instruction that divides (binary division) the adjusted value in the AX register by an unpacked BCD value.
\par The AAD instruction sets the value in the AL register to (AL + (10 * AH)), and then clears the AH register to 00H. The value in the AX register is then equal to the binary equivalent of the original unpacked two-digit (base 10) number in registers AH and AL.
\par The generalized version of this instruction allows adjustment of two unpacked digits of any number base (see the 'Operation' section), by setting the imm8 byte to the selected number base (for example, 08H for octal, 0AH for decimal, or 0CH for base 12 numbers). The AAD mnemonic is interpreted by all assemblers to mean adjust ASCII (base 10) values. To adjust values in another number base, the instruction must be hand coded in machine code (D5 imm8).
{\page}

${\footnote AAD,Operation}
K{\footnote AAD,AAD;AAD,Operation}
#{\footnote AAD::2}

{\fs20\b AAD}\tab{\b Operation}\par\par
tempAL <- AL;
\par tempAH <- AH;
\par AL <- (tempAL + (tempAH * imm8)) AND FFH; (* imm8 is set to 0AH for the AAD mnemonic *)
\par AH <- 0
\par 
\par The immediate value (imm8) is taken from the second byte of the instruction.
{\page}

${\footnote AAD,Flags affected}
K{\footnote AAD,AAD;AAD,Flags affected}
#{\footnote AAD::3}

{\fs20\b AAD}\tab{\b Flags affected}\par\par
The SF, ZF, and PF flags are set according to the result; the OF, AF, and CF flags are undefined.
{\page}

${\footnote AAD,Exceptions}
K{\footnote AAD,AAD;AAD,Exceptions}
#{\footnote AAD::4}

{\fs20\b AAD}\tab{\b Exceptions}\par\par
(All Operating Modes)
\par None.
{\page}

${\footnote AAD,Opcode}
K{\footnote AAD,AAD;AAD,Opcode}
#{\footnote AAD::5}

{\fs20\b AAD}\tab{\b Opcode}\par\par
D5 0A AAD ASCII adjust AX before division
\par D5 ib (No mnemonic) Adjust AX before division to number base imm8
{\page}

${\footnote AAM,Description}
K{\footnote AAM,AAM;AAM,Description}
#{\footnote AAM::1}

{\fs20\b AAM}\tab{\b Description}\par\par
AAM: ASCII Adjust AX After Multiply
\par 
\par Adjusts the result of the multiplication of two unpacked BCD values to create a pair of unpacked (base 10) BCD values. The AX register is the implied source and destination operand for this instruction. The AAM instruction is only useful when it follows an MUL instruction that multi-plies (binary multiplication) two unpacked BCD values and stores a word result in the AX register. The AAM instruction then adjusts the contents of the AX register to contain the correct 2-digit unpacked (base 10) BCD result.
\par The generalized version of this instruction allows adjustment of the contents of the AX to create two unpacked digits of any number base (see the 'Operation' section). Here, the imm8 byte is set to the selected number base (for example, 08H for octal, 0AH for decimal, or 0CH for base 12 numbers). The AAM mnemonic is interpreted by all assemblers to mean adjust to ASCII (base 10) values. To adjust to values in another number base, the instruction must be hand coded in machine code (D4 imm8).
{\page}

${\footnote AAM,Operation}
K{\footnote AAM,AAM;AAM,Operation}
#{\footnote AAM::2}

{\fs20\b AAM}\tab{\b Operation}\par\par
tempAL <- AL;
\par AH <- tempAL / imm8; (* imm8 is set to 0AH for the AAD mnemonic *)
\par AL <- tempAL MOD imm8;
\par 
\par The immediate value (imm8) is taken from the second byte of the instruction.
{\page}

${\footnote AAM,Flags affected}
K{\footnote AAM,AAM;AAM,Flags affected}
#{\footnote AAM::3}

{\fs20\b AAM}\tab{\b Flags affected}\par\par
The SF, ZF, and PF flags are set according to the result. The OF, AF, and CF flags are undefined.
{\page}

${\footnote AAM,Exceptions}
K{\footnote AAM,AAM;AAM,Exceptions}
#{\footnote AAM::4}

{\fs20\b AAM}\tab{\b Exceptions}\par\par
(All Operating Modes)
\par None with the default immediate value of 0AH. If, however, an immediate value of 0 is used, it will cause a #DE (divide error) exception.
{\page}

${\footnote AAM,Opcode}
K{\footnote AAM,AAM;AAM,Opcode}
#{\footnote AAM::5}

{\fs20\b AAM}\tab{\b Opcode}\par\par
D4 0A AAM ASCII adjust AX after multiply
\par D4 ib (No mnemonic) Adjust AX after multiply to number base imm8
{\page}

${\footnote AAS,Description}
K{\footnote AAS,AAS;AAS,Description}
#{\footnote AAS::1}

{\fs20\b AAS}\tab{\b Description}\par\par
AAS: ASCII Adjust AL After Subtraction
\par 
\par Adjusts the result of the subtraction of two unpacked BCD values to create a unpacked BCD result. The AL register is the implied source and destination operand for this instruction. The AAS instruction is only useful when it follows a SUB instruction that subtracts (binary subtrac-tion) one unpacked BCD value from another and stores a byte result in the AL register. The AAA instruction then adjusts the contents of the AL register to contain the correct 1-digit unpacked BCD result.
\par If the subtraction produced a decimal carry, the AH register is decremented by 1, and the CF and AF flags are set. If no decimal carry occurred, the CF and AF flags are cleared, and the AH register is unchanged. In either case, the AL register is left with its top nibble set to 0.
{\page}

${\footnote AAS,Operation}
K{\footnote AAS,AAS;AAS,Operation}
#{\footnote AAS::2}

{\fs20\b AAS}\tab{\b Operation}\par\par
IF ((AL AND 0FH) > 9) OR (AF = 1)
\par THEN
\par AL <- AL ' 6;
\par AH <- AH ' 1;
\par AF <- 1;
\par CF <- 1;
\par ELSE
\par CF <- 0;
\par AF <- 0;
\par FI;
\par AL <- AL AND 0FH;
{\page}

${\footnote AAS,Flags affected}
K{\footnote AAS,AAS;AAS,Flags affected}
#{\footnote AAS::3}

{\fs20\b AAS}\tab{\b Flags affected}\par\par
The AF and CF flags are set to 1 if there is a decimal borrow; otherwise, they are cleared to 0. The OF, SF, ZF, and PF flags are undefined.
{\page}

${\footnote AAS,Exceptions}
K{\footnote AAS,AAS;AAS,Exceptions}
#{\footnote AAS::4}

{\fs20\b AAS}\tab{\b Exceptions}\par\par
(All Operating Modes)
\par None.
{\page}

${\footnote AAS,Opcode}
K{\footnote AAS,AAS;AAS,Opcode}
#{\footnote AAS::5}

{\fs20\b AAS}\tab{\b Opcode}\par\par
3F AAS ASCII adjust AL after subtraction
{\page}

${\footnote ADC,Description}
K{\footnote ADC,ADC;ADC,Description}
#{\footnote ADC::1}

{\fs20\b ADC}\tab{\b Description}\par\par
ADC: Add with Carry
\par 
\par Adds the destination operand (first operand), the source operand (second operand), and the carry (CF) flag and stores the result in the destination operand. The destination operand can be a register or a memory location; the source operand can be an immediate, a register, or a memory location. (However, two memory operands cannot be used in one instruction.) The state of the CF flag represents a carry from a previous addition. When an immediate value is used as an operand, it is sign-extended to the length of the destination operand format.
\par The ADC instruction does not distinguish between signed or unsigned operands. Instead, the processor evaluates the result for both data types and sets the OF and CF flags to indicate a carry in the signed or unsigned result, respectively. The SF flag indicates the sign of the signed result.
\par The ADC instruction is usually executed as part of a multibyte or multiword addition in which an ADD instruction is followed by an ADC instruction.
{\page}

${\footnote ADC,Operation}
K{\footnote ADC,ADC;ADC,Operation}
#{\footnote ADC::2}

{\fs20\b ADC}\tab{\b Operation}\par\par
DEST <- DEST + SRC + CF;
{\page}

${\footnote ADC,Flags affected}
K{\footnote ADC,ADC;ADC,Flags affected}
#{\footnote ADC::3}

{\fs20\b ADC}\tab{\b Flags affected}\par\par
The OF, SF, ZF, AF, CF, and PF flags are set according to the result.
{\page}

${\footnote ADC,Exceptions}
K{\footnote ADC,ADC;ADC,Exceptions}
#{\footnote ADC::4}

{\fs20\b ADC}\tab{\b Exceptions}\par\par
Protected Mode Exceptions
\par 
\par #GP(0) If the destination is located in a nonwritable segment. If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit. If the DS, ES, FS, or GS register is used to access memory and it contains a null segment selector.
\par #SS(0) If a memory operand effective address is outside the SS segment limit.
\par #PF(fault-code) If a page fault occurs.
\par #AC(0) If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.
\par 
\par Real-Address Mode Exceptions
\par 
\par #GP If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.
\par #SS If a memory operand effective address is outside the SS segment limit.
\par 
\par Virtual-8086 Mode Exceptions
\par 
\par #GP(0) If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.
\par #SS(0) If a memory operand effective address is outside the SS segment limit.
\par #PF(fault-code) If a page fault occurs.
\par #AC(0) If alignment checking is enabled and an unaligned memory reference is made.
{\page}

${\footnote ADC,Opcode}
K{\footnote ADC,ADC;ADC,Opcode}
#{\footnote ADC::5}

{\fs20\b ADC}\tab{\b Opcode}\par\par
14 ib ADC AL, imm8 Add with carry imm8 to AL
\par 15 iw ADC AX, imm16 Add with carry imm16 to AX
\par 15 id ADC EAX, imm32 Add with carry imm32 to EAX
\par 80 /2 ib ADC r/m8, imm8 Add with carry imm8 to r/m8
\par 81 /2 iw ADC r/m16,imm16 Add with carry imm16 to r/m16
\par 81 /2 id ADC r/m32,imm32 Add with CF imm32 to r/m32
\par 83 /2 ib ADC r/m16,imm8 Add with CF sign-extended imm8 to r/m16
\par 83 /2 ib ADC r/m32,imm8 Add with CF sign-extended imm8 into r/m32
\par 10 / r ADC r/m8,r8 Add with carry byte register to r/m8
\par 11 / r ADC r/m16,r16 Add with carry r16 to r/m16
\par 11 / r ADC r/m32,r32 Add with CF r32 to r/m32
\par 12 / r ADC r8,r/m8 Add with carry r/m8 to byte register
\par 13 / r ADC r16,r/m16 Add with carry r/m16 to r16
\par 13 / r ADC r32,r/m32 Add with CF r/m32 to r32
{\page}

${\footnote ADD,Description}
K{\footnote ADD,ADD;ADD,Description}
#{\footnote ADD::1}

{\fs20\b ADD}\tab{\b Description}\par\par
ADD: Add
\par 
\par Adds the first operand (destination operand) and the second operand (source operand) and stores the result in the destination operand. The destination operand can be a register or a memory location; the source operand can be an immediate, a register, or a memory location. (However, two memory operands cannot be used in one instruction.) When an immediate value is used as an operand, it is sign-extended to the length of the destination operand format.
\par The ADD instruction does not distinguish between signed or unsigned operands. Instead, the processor evaluates the result for both data types and sets the OF and CF flags to indicate a carry in the signed or unsigned result, respectively. The SF flag indicates the sign of the signed result.
{\page}

${\footnote ADD,Operation}
K{\footnote ADD,ADD;ADD,Operation}
#{\footnote ADD::2}

{\fs20\b ADD}\tab{\b Operation}\par\par
DEST <- DEST + SRC;
{\page}

${\footnote ADD,Flags affected}
K{\footnote ADD,ADD;ADD,Flags affected}
#{\footnote ADD::3}

{\fs20\b ADD}\tab{\b Flags affected}\par\par
The OF, SF, ZF, AF, CF, and PF flags are set according to the result.
{\page}

${\footnote ADD,Exceptions}
K{\footnote ADD,ADD;ADD,Exceptions}
#{\footnote ADD::4}

{\fs20\b ADD}\tab{\b Exceptions}\par\par
Protected Mode Exceptions
\par 
\par #GP(0) If the destination is located in a nonwritable segment. If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit. If the DS, ES, FS, or GS register is used to access memory and it contains a null segment selector.
\par #SS(0) If a memory operand effective address is outside the SS segment limit.
\par #PF(fault-code) If a page fault occurs.
\par #AC(0) If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.
\par 
\par Real-Address Mode Exceptions
\par 
\par #GP If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.
\par #SS If a memory operand effective address is outside the SS segment limit.
\par 
\par Virtual-8086 Mode Exceptions
\par 
\par #GP(0) If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.
\par #SS(0) If a memory operand effective address is outside the SS segment limit.
\par #PF(fault-code) If a page fault occurs.
\par #AC(0) If alignment checking is enabled and an unaligned memory reference is made.
{\page}

${\footnote ADD,Opcode}
K{\footnote ADD,ADD;ADD,Opcode}
#{\footnote ADD::5}

{\fs20\b ADD}\tab{\b Opcode}\par\par
04 ib ADD AL, imm8 Add imm8 to AL
\par 05 iw ADD AX, imm16 Add imm16 to AX
\par 05 id ADD EAX, imm32 Add imm32 to EAX
\par 80 /0 ib ADD r/m8,imm8 Add imm8 to r/m8
\par 81 /0 iw ADD r/m16,imm16 Add imm16 to r/m16
\par 81 /0 id ADD r/m32,imm32 Add imm32 to r/m32
\par 83 /0 ib ADD r/m16,imm8 Add sign-extended imm8 to r/m16
\par 83 /0 ib ADD r/m32,imm8 Add sign-extended imm8 to r/m32
\par 00 / r ADD r/m8,r8 Add r8 to r/m8
\par 01 / r ADD r/m16,r16 Add r16 to r/m16
\par 01 / r ADD r/m32,r32 Add r32 to r/m32
\par 02 / r ADD r8,r/m8 Add r/m8 to r8
\par 03 / r ADD r16,r/m16 Add r/m16 to r16
\par 03 / r ADD r32,r/m32 Add r/m32 to r32
{\page}

${\footnote AND,Description}
K{\footnote AND,AND;AND,Description}
#{\footnote AND::1}

{\fs20\b AND}\tab{\b Description}\par\par
AND: Logical AND
\par 
\par Performs a bitwise AND operation on the destination (first) and source (second) operands and stores the result in the destination operand location. The source operand can be an immediate, a register, or a memory location; the destination operand can be a register or a memory location. (However, two memory operands cannot be used in one instruction.) Each bit of the result of the AND instruction is a 1 if both corresponding bits of the operands are 1; otherwise, it becomes a 0.
{\page}

${\footnote AND,Operation}
K{\footnote AND,AND;AND,Operation}
#{\footnote AND::2}

{\fs20\b AND}\tab{\b Operation}\par\par
DEST <- DEST AND SRC;
{\page}

${\footnote AND,Flags affected}
K{\footnote AND,AND;AND,Flags affected}
#{\footnote AND::3}

{\fs20\b AND}\tab{\b Flags affected}\par\par
The OF and CF flags are cleared; the SF, ZF, and PF flags are set according to the result. The state of the AF flag is undefined.
{\page}

${\footnote AND,Exceptions}
K{\footnote AND,AND;AND,Exceptions}
#{\footnote AND::4}

{\fs20\b AND}\tab{\b Exceptions}\par\par
Protected Mode Exceptions
\par 
\par #GP(0) If the destination operand points to a nonwritable segment. If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit. If the DS, ES, FS, or GS register contains a null segment selector.
\par #SS(0) If a memory operand effective address is outside the SS segment limit.
\par #PF(fault-code) If a page fault occurs.
\par #AC(0) If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.
\par 
\par Real-Address Mode Exceptions
\par 
\par #GP If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.
\par #SS If a memory operand effective address is outside the SS segment limit.
\par 
\par Virtual-8086 Mode Exceptions
\par 
\par #GP(0) If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.
\par #SS(0) If a memory operand effective address is outside the SS segment limit.
\par #PF(fault-code) If a page fault occurs.
\par #AC(0) If alignment checking is enabled and an unaligned memory reference is made.
{\page}

${\footnote AND,Opcode}
K{\footnote AND,AND;AND,Opcode}
#{\footnote AND::5}

{\fs20\b AND}\tab{\b Opcode}\par\par
24 ib AND AL, imm8 AL AND imm8
\par 25 iw AND AX, imm16 AX AND i mm16
\par 25 id AND EAX, imm32 EAX AND imm32
\par 80 /4 ib AND r/m8,imm8 r/m8 AND imm8
\par 81 /4 iw AND r/m16,imm16 r/m16 AND imm16
\par 81 /4 id AND r/m32,imm32 r/m32 AND imm32
\par 83 /4 ib AND r/m16,imm8 r/m16 AND imm8 (sign-extended)
\par 83 /4 ib AND r/m32,imm8 r/m32 AND imm8 (sign-extended)
\par 20 /r AND r/m8,r8 r/m8 AND r8
\par 21 / r AND r/m16,r16 r/m16 AND r16
\par 21 / r AND r/m32,r32 r/m32 AND r32
\par 22 / r AND r8,r/m8 r8 AND r/m8
\par 23 / r AND r16,r/m16 r16 AND r/m16
\par 23 / r AND r32,r/m32 r32 AND r/m32
{\page}

${\footnote ARPL,Description}
K{\footnote ARPL,ARPL;ARPL,Description}
#{\footnote ARPL::1}

{\fs20\b ARPL}\tab{\b Description}\par\par
ARPL: Adjust RPL Field of Segment Selector
\par 
\par Compares the RPL fields of two segment selectors. The first operand (the destination operand) contains one segment selector and the second operand (source operand) contains the other. (The RPL field is located in bits 0 and 1 of each operand.) If the RPL field of the destination operand is less than the RPL field of the source operand, the ZF flag is set and the RPL field of the destination operand is increased to match that of the source operand. Otherwise, the ZF flag is cleared and no change is made to the destination operand. (The destination operand can be a word register or a memory location; the source operand must be a word register.)
\par The ARPL instruction is provided for use by operating-system procedures (however, it can also be used by applications). It is generally used to adjust the RPL of a segment selector that has been passed to the operating system by an application program to match the privilege level of the application program. Here the segment selector passed to the operating system is placed in the destination operand and segment selector for the application program's code segment is placed in the source operand. (The RPL field in the source operand represents the privilege level of the application program.) Execution of the ARPL instruction then insures that the RPL of the segment selector received by the operating system is no lower (does not have a higher privilege) than the privilege level of the application program. (The segment selector for the application program's code segment can be read from the stack following a procedure call.)
{\page}

${\footnote ARPL,Operation}
K{\footnote ARPL,ARPL;ARPL,Operation}
#{\footnote ARPL::2}

{\fs20\b ARPL}\tab{\b Operation}\par\par
IF DEST(RPL) < SRC(RPL)
\par THEN
\par ZF <- 1;
\par DEST(RPL) <- SRC(RPL);
\par ELSE
\par ZF <- 0;
\par FI;
{\page}

${\footnote ARPL,Flags affected}
K{\footnote ARPL,ARPL;ARPL,Flags affected}
#{\footnote ARPL::3}

{\fs20\b ARPL}\tab{\b Flags affected}\par\par
The ZF flag is set to 1 if the RPL field of the destination operand is less than that of the source operand; otherwise, is cleared to 0.
{\page}

${\footnote ARPL,Exceptions}
K{\footnote ARPL,ARPL;ARPL,Exceptions}
#{\footnote ARPL::4}

{\fs20\b ARPL}\tab{\b Exceptions}\par\par
Protected Mode Exceptions
\par 
\par #GP(0) If the destination is located in a nonwritable segment. If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit. If the DS, ES, FS, or GS register is used to access memory and it contains a null segment selector.
\par #SS(0) If a memory operand effective address is outside the SS segment limit.
\par #PF(fault-code) If a page fault occurs.
\par #AC(0) If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.
\par 
\par Real-Address Mode Exceptions
\par 
\par #UD The ARPL instruction is not recognized in real-address mode.
\par 
\par Virtual-8086 Mode Exceptions
\par 
\par #UD The ARPL instruction is not recognized in virtual-8086 mode.
{\page}

${\footnote ARPL,Opcode}
K{\footnote ARPL,ARPL;ARPL,Opcode}
#{\footnote ARPL::5}

{\fs20\b ARPL}\tab{\b Opcode}\par\par
63 / r ARPL r/m16,r16 Adjust RPL of r/m16 to not less than RPL of r16
{\page}

${\footnote PF2IW,Description}
K{\footnote PF2IW,PF2IW;PF2IW,Description}
#{\footnote PF2IW::1}

{\fs20\b PF2IW}\tab{\b Description}\par\par
PF2IW: Packed floating-point to integer word conversion with sign extend
\par 
\par PF2IW is a vector instruction that converts a vector register containing single-precision floating-point operands to 16-bit signed integers using truncation. Arguments outside the range representable by signed 16-bit integers are saturated to the largest and smallest 16-bit integer, depending on their sign. All results are sign-extended to 32-bits.
{\page}

${\footnote PF2IW,Operation}
K{\footnote PF2IW,PF2IW;PF2IW,Operation}
#{\footnote PF2IW::2}

{\fs20\b PF2IW}\tab{\b Operation}\par\par
PF2IW mmreg1, mmreg2 performs the following operations:
\par 
\par IF (mmreg2[31:0] >= 2 15 )
\par THEN mmreg1[31:0] = 0x0000_7FFF
\par ELSE IF (mmreg2[31:0] <= -2 15 )
\par THEN mmreg1[31:0] = 0xFFFF_8000
\par ELSE mmreg1[31:0] = int(mmreg2[31:0])
\par IF (mmreg2[63:32] >= 2 15 )
\par THEN mmreg1[63:32] = 0x0000_7FFF
\par ELSE IF (mmreg2[63:32] <= -2 15 )
\par THEN mmreg1[63:32] = 0xFFFF_8000
\par ELSE mmreg1[63:32] = int(mmreg2[63:32])
\par 
\par PF2IW mmreg, mem64 performs the following operations:
\par 
\par IF (mem64[31:0] >= 2 15 )
\par THEN mmreg[31:0] = 0x0000_7FFF
\par ELSE IF (mem64[31:0] <= -2 15 )
\par THEN mmreg[31:0] = 0xFFFF_8000
\par ELSE mmreg[31:0] = int(mem64[31:0])
\par IF (mem64[63:32] >= 2 15 )
\par THEN mmreg[63:32] = 0x0000_7FFF
\par ELSE IF (mem64[63:32] <= -2 15 )
\par THEN mmreg[63:32] = 0xFFFF_8000
\par ELSE mmreg[63:32] = int(mem64[63:32])
{\page}

${\footnote PF2IW,Flags affected}
K{\footnote PF2IW,PF2IW;PF2IW,Flags affected}
#{\footnote PF2IW::3}

{\fs20\b PF2IW}\tab{\b Flags affected}\par\par
None.
{\page}

${\footnote PF2IW,Exceptions}
K{\footnote PF2IW,PF2IW;PF2IW,Exceptions}
#{\footnote PF2IW::4}

{\fs20\b PF2IW}\tab{\b Exceptions}\par\par
Protected Mode Exceptions
\par 
\par #Invalid Opcode, The emulate instruction bit (EM) of the control register (CR0) is set to 1.
\par #Device Not Available, Save the floating-point or MMX state if the task switch bit (TS) of the control register (CR0) is set to 1.
\par #Stack Exception, During instruction execution, the stack segment limit was exceeded.
\par #General Protection, During instruction execution, the effective address of one of the segment registers used for the operand points to an illegal memory location.
\par #Page fault, A page fault resulted from the execution of the instruction.
\par #Float point exception pending, An exception is pending due to the floating-point execution unit.
\par #Alignment check, An unaligned memory reference resulted from the instruction execution, and the alignment mask bit (AM) of the control register (CR0) is set to 1. (In Protected Mode, CPL = 3.)
\par 
\par Real-Address Mode Exceptions
\par 
\par #Invalid Opcode, The emulate instruction bit (EM) of the control register (CR0) is set to 1.
\par #Device Not Available, Save the floating-point or MMX state if the task switch bit (TS) of the control register (CR0) is set to 1.
\par #Segment Overrun, One of the instruction data operands falls outside the address range 00000h to 0FFFFh.
\par #Float point exception pending, An exception is pending due to the floating-point execution unit.
\par 
\par Virtual-8086 Mode Exceptions
\par 
\par #Invalid Opcode, The emulate instruction bit (EM) of the control register (CR0) is set to 1.
\par #Device Not Available, Save the floating-point or MMX state if the task switch bit (TS) of the control register (CR0) is set to 1.
\par #Segment Overrun, One of the instruction data operands falls outside the address range 00000h to 0FFFFh.
\par #Page fault, A page fault resulted from the execution of the instruction.
\par #Float point exception pending, An exception is pending due to the floating-point execution unit.
\par #Alignment check, An unaligned memory reference resulted from the instruction execution, and the alignment mask bit (AM) of the control register (CR0) is set to 1. (In Protected Mode, CPL = 3.)
{\page}

${\footnote PF2IW,Opcode}
K{\footnote PF2IW,PF2IW;PF2IW,Opcode}
#{\footnote PF2IW::5}

{\fs20\b PF2IW}\tab{\b Opcode}\par\par
0F 0F 1C /r PF2IW mmreg1, mmreg2 or PF2IW mmreg, mem64
{\page}

${\footnote PFNACC,Description}
K{\footnote PFNACC,PFNACC;PFNACC,Description}
#{\footnote PFNACC::1}

{\fs20\b PFNACC}\tab{\b Description}\par\par
PFNACC: Packed floating-point negative accumulate
\par 
\par PFNACC is a vector instruction that does negative accumulation of the two doublewords of the destination operand and the source operand. PFNACC then stores the results in the low and high words of the destination operand, respectively. Both operands are single-precision, floating-point operands with 24-bit significands.
{\page}

${\footnote PFNACC,Operation}
K{\footnote PFNACC,PFNACC;PFNACC,Operation}
#{\footnote PFNACC::2}

{\fs20\b PFNACC}\tab{\b Operation}\par\par
PFNACC mmreg1, mmreg2 performs the following operations:
\par 
\par mmreg1[31:0] = mmreg1[31:0] - mmreg1[63:32]
\par mmreg1[63:32] = mmreg2[31:0] - mmreg2[63:32]
\par 
\par PFNACC mmreg, mem64 performs the following operations:
\par 
\par mmreg[31:0] = mmreg[31:0] - mmreg[63:32]
\par mmreg[63:32] = mem64[31:0] - mem64[63:32]
{\page}

${\footnote PFNACC,Flags affected}
K{\footnote PFNACC,PFNACC;PFNACC,Flags affected}
#{\footnote PFNACC::3}

{\fs20\b PFNACC}\tab{\b Flags affected}\par\par
None.
{\page}

${\footnote PFNACC,Exceptions}
K{\footnote PFNACC,PFNACC;PFNACC,Exceptions}
#{\footnote PFNACC::4}

{\fs20\b PFNACC}\tab{\b Exceptions}\par\par
Protected Mode Exceptions
\par 
\par #Invalid Opcode, The emulate instruction bit (EM) of the control register (CR0) is set to 1.
\par #Device Not Available, Save the floating-point or MMX state if the task switch bit (TS) of the control register (CR0) is set to 1.
\par #Stack Exception, During instruction execution, the stack segment limit was exceeded.
\par #General Protection, During instruction execution, the effective address of one of the segment registers used for the operand points to an illegal memory location.
\par #Page fault, A page fault resulted from the execution of the instruction.
\par #Float point exception pending, An exception is pending due to the floating-point execution unit.
\par #Alignment check, An unaligned memory reference resulted from the instruction execution, and the alignment mask bit (AM) of the control register (CR0) is set to 1. (In Protected Mode, CPL = 3.)
\par 
\par Real-Address Mode Exceptions
\par 
\par #Invalid Opcode, The emulate instruction bit (EM) of the control register (CR0) is set to 1.
\par #Device Not Available, Save the floating-point or MMX state if the task switch bit (TS) of the control register (CR0) is set to 1.
\par #Segment Overrun, One of the instruction data operands falls outside the address range 00000h to 0FFFFh.
\par #Float point exception pending, An exception is pending due to the floating-point execution unit.
\par 
\par Virtual-8086 Mode Exceptions
\par 
\par #Invalid Opcode, The emulate instruction bit (EM) of the control register (CR0) is set to 1.
\par #Device Not Available, Save the floating-point or MMX state if the task switch bit (TS) of the control register (CR0) is set to 1.
\par #Segment Overrun, One of the instruction data operands falls outside the address range 00000h to 0FFFFh.
\par #Page fault, A page fault resulted from the execution of the instruction.
\par #Float point exception pending, An exception is pending due to the floating-point execution unit.
\par #Alignment check, An unaligned memory reference resulted from the instruction execution, and the alignment mask bit (AM) of the control register (CR0) is set to 1. (In Protected Mode, CPL = 3.)
{\page}

${\footnote PFNACC,Opcode}
K{\footnote PFNACC,PFNACC;PFNACC,Opcode}
#{\footnote PFNACC::5}

{\fs20\b PFNACC}\tab{\b Opcode}\par\par
0F 0F 8A /r PFNACC mmreg1, mmreg2 or PFNACC mmreg, mem64
{\page}

${\footnote PFPNACC,Description}
K{\footnote PFPNACC,PFPNACC;PFPNACC,Description}
#{\footnote PFPNACC::1}

{\fs20\b PFPNACC}\tab{\b Description}\par\par
PFPNACC: Packed floating-point mixed positive-negative accumulate
\par 
\par PFPNACC is a vector instruction that does mixed negative and positive accumulation of the two doublewords of the destination operand and the source operand and stores the results in the low and high words of the destination operand, respectively. Both operands are single-precision, floating-point operands with 24-bit significands.
{\page}

${\footnote PFPNACC,Operation}
K{\footnote PFPNACC,PFPNACC;PFPNACC,Operation}
#{\footnote PFPNACC::2}

{\fs20\b PFPNACC}\tab{\b Operation}\par\par
PFPNACC mmreg1, mmreg2 performs the following operations:
\par 
\par mmreg1[31:0] = mmreg1[31:0] - mmreg1[63:32]
\par mmreg1[63:32] = mmreg2[31:0] + mmreg2[63:32]
\par PFPNACC mmreg, mem64 performs the following operations:
\par 
\par mmreg[31:0] = mmreg[31:0] - mmreg[63:32]
\par mmreg[63:32] = mem64[31:0] + mem64[63:32]
{\page}

${\footnote PFPNACC,Flags affected}
K{\footnote PFPNACC,PFPNACC;PFPNACC,Flags affected}
#{\footnote PFPNACC::3}

{\fs20\b PFPNACC}\tab{\b Flags affected}\par\par
None.
{\page}

${\footnote PFPNACC,Exceptions}
K{\footnote PFPNACC,PFPNACC;PFPNACC,Exceptions}
#{\footnote PFPNACC::4}

{\fs20\b PFPNACC}\tab{\b Exceptions}\par\par
Protected Mode Exceptions
\par 
\par #Invalid Opcode, The emulate instruction bit (EM) of the control register (CR0) is set to 1.
\par #Device Not Available, Save the floating-point or MMX state if the task switch bit (TS) of the control register (CR0) is set to 1.
\par #Stack Exception, During instruction execution, the stack segment limit was exceeded.
\par #General Protection, During instruction execution, the effective address of one of the segment registers used for the operand points to an illegal memory location.
\par #Page fault, A page fault resulted from the execution of the instruction.
\par #Float point exception pending, An exception is pending due to the floating-point execution unit.
\par #Alignment check, An unaligned memory reference resulted from the instruction execution, and the alignment mask bit (AM) of the control register (CR0) is set to 1. (In Protected Mode, CPL = 3.)
\par 
\par Real-Address Mode Exceptions
\par 
\par #Invalid Opcode, The emulate instruction bit (EM) of the control register (CR0) is set to 1.
\par #Device Not Available, Save the floating-point or MMX state if the task switch bit (TS) of the control register (CR0) is set to 1.
\par #Segment Overrun, One of the instruction data operands falls outside the address range 00000h to 0FFFFh.
\par #Float point exception pending, An exception is pending due to the floating-point execution unit.
\par 
\par Virtual-8086 Mode Exceptions
\par 
\par #Invalid Opcode, The emulate instruction bit (EM) of the control register (CR0) is set to 1.
\par #Device Not Available, Save the floating-point or MMX state if the task switch bit (TS) of the control register (CR0) is set to 1.
\par #Segment Overrun, One of the instruction data operands falls outside the address range 00000h to 0FFFFh.
\par #Page fault, A page fault resulted from the execution of the instruction.
\par #Float point exception pending, An exception is pending due to the floating-point execution unit.
\par #Alignment check, An unaligned memory reference resulted from the instruction execution, and the alignment mask bit (AM) of the control register (CR0) is set to 1. (In Protected Mode, CPL = 3.)
{\page}

${\footnote PFPNACC,Opcode}
K{\footnote PFPNACC,PFPNACC;PFPNACC,Opcode}
#{\footnote PFPNACC::5}

{\fs20\b PFPNACC}\tab{\b Opcode}\par\par
0F 0F 8E /r PFPNACC mmreg1, mmreg2 or PFPNACC mmreg, mem64
{\page}

${\footnote PI2FW,Description}
K{\footnote PI2FW,PI2FW;PI2FW,Description}
#{\footnote PI2FW::1}

{\fs20\b PI2FW}\tab{\b Description}\par\par
PI2FW: Packed 16-bit integer to floating-point conversion
\par 
\par PI2FW is a vector instruction that converts a vector register containing signed, 16-bit integers to single-precision, floating-point operands.
{\page}

${\footnote PI2FW,Operation}
K{\footnote PI2FW,PI2FW;PI2FW,Operation}
#{\footnote PI2FW::2}

{\fs20\b PI2FW}\tab{\b Operation}\par\par
PI2FW mmreg1, mmreg2 performs the following operations:
\par 
\par mmreg1[31:0] = float(mmreg2[15:0])
\par mmreg1[63:32] = float(mmreg2[47:32])
\par PI2FW mmreg, mem64" performs the following operations:
\par 
\par mmreg[31:0] = float(mem64[15:0])
\par mmreg[63:32] = float(mem64[47:32])
{\page}

${\footnote PI2FW,Flags affected}
K{\footnote PI2FW,PI2FW;PI2FW,Flags affected}
#{\footnote PI2FW::3}

{\fs20\b PI2FW}\tab{\b Flags affected}\par\par
None.
{\page}

${\footnote PI2FW,Exceptions}
K{\footnote PI2FW,PI2FW;PI2FW,Exceptions}
#{\footnote PI2FW::4}

{\fs20\b PI2FW}\tab{\b Exceptions}\par\par
Protected Mode Exceptions
\par 
\par #Invalid Opcode, The emulate instruction bit (EM) of the control register (CR0) is set to 1.
\par #Device Not Available, Save the floating-point or MMX state if the task switch bit (TS) of the control register (CR0) is set to 1.
\par #Stack Exception, During instruction execution, the stack segment limit was exceeded.
\par #General Protection, During instruction execution, the effective address of one of the segment registers used for the operand points to an illegal memory location.
\par #Page fault, A page fault resulted from the execution of the instruction.
\par #Float point exception pending, An exception is pending due to the floating-point execution unit.
\par #Alignment check, An unaligned memory reference resulted from the instruction execution, and the alignment mask bit (AM) of the control register (CR0) is set to 1. (In Protected Mode, CPL = 3.)
\par 
\par Real-Address Mode Exceptions
\par 
\par #Invalid Opcode, The emulate instruction bit (EM) of the control register (CR0) is set to 1.
\par #Device Not Available, Save the floating-point or MMX state if the task switch bit (TS) of the control register (CR0) is set to 1.
\par #Segment Overrun, One of the instruction data operands falls outside the address range 00000h to 0FFFFh.
\par #Float point exception pending, An exception is pending due to the floating-point execution unit.
\par 
\par Virtual-8086 Mode Exceptions
\par 
\par #Invalid Opcode, The emulate instruction bit (EM) of the control register (CR0) is set to 1.
\par #Device Not Available, Save the floating-point or MMX state if the task switch bit (TS) of the control register (CR0) is set to 1.
\par #Segment Overrun, One of the instruction data operands falls outside the address range 00000h to 0FFFFh.
\par #Page fault, A page fault resulted from the execution of the instruction.
\par #Float point exception pending, An exception is pending due to the floating-point execution unit.
\par #Alignment check, An unaligned memory reference resulted from the instruction execution, and the alignment mask bit (AM) of the control register (CR0) is set to 1. (In Protected Mode, CPL = 3.)
{\page}

${\footnote PI2FW,Opcode}
K{\footnote PI2FW,PI2FW;PI2FW,Opcode}
#{\footnote PI2FW::5}

{\fs20\b PI2FW}\tab{\b Opcode}\par\par
0F 0F 0C /r PI2FW mmreg1, mmreg2 or PI2FW mmreg, mem64
{\page}

${\footnote PSWAPD,Description}
K{\footnote PSWAPD,PSWAPD;PSWAPD,Description}
#{\footnote PSWAPD::1}

{\fs20\b PSWAPD}\tab{\b Description}\par\par
PSWAPD: Packed swap doubleword
\par 
\par The PSWAPD instruction swaps or reverses the upper and lower doublewords of the source operand.
{\page}

${\footnote PSWAPD,Operation}
K{\footnote PSWAPD,PSWAPD;PSWAPD,Operation}
#{\footnote PSWAPD::2}

{\fs20\b PSWAPD}\tab{\b Operation}\par\par
PSWAPD mmreg1, mmreg2 performs the following operations:
\par 
\par mmreg1[63:32] = mmreg2[31:0])
\par mmreg1[31:0] = mmreg2[63:32])
\par 
\par PSWAPD mmreg, mem64 performs the following operations:
\par 
\par mmreg[63:32] = mem64[31:0])
\par mmreg[31:0] = mem64[63:32])
{\page}

${\footnote PSWAPD,Flags affected}
K{\footnote PSWAPD,PSWAPD;PSWAPD,Flags affected}
#{\footnote PSWAPD::3}

{\fs20\b PSWAPD}\tab{\b Flags affected}\par\par
None.
{\page}

${\footnote PSWAPD,Exceptions}
K{\footnote PSWAPD,PSWAPD;PSWAPD,Exceptions}
#{\footnote PSWAPD::4}

{\fs20\b PSWAPD}\tab{\b Exceptions}\par\par
Protected Mode Exceptions
\par 
\par #Invalid Opcode, The emulate instruction bit (EM) of the control register (CR0) is set to 1.
\par #Device Not Available, Save the floating-point or MMX state if the task switch bit (TS) of the control register (CR0) is set to 1.
\par #Stack Exception, During instruction execution, the stack segment limit was exceeded.
\par #General Protection, During instruction execution, the effective address of one of the segment registers used for the operand points to an illegal memory location.
\par #Page fault, A page fault resulted from the execution of the instruction.
\par #Float point exception pending, An exception is pending due to the floating-point execution unit.
\par #Alignment check, An unaligned memory reference resulted from the instruction execution, and the alignment mask bit (AM) of the control register (CR0) is set to 1. (In Protected Mode, CPL = 3.)
\par 
\par Real-Address Mode Exceptions
\par 
\par #Invalid Opcode, The emulate instruction bit (EM) of the control register (CR0) is set to 1.
\par #Device Not Available, Save the floating-point or MMX state if the task switch bit (TS) of the control register (CR0) is set to 1.
\par #Segment Overrun, One of the instruction data operands falls outside the address range 00000h to 0FFFFh.
\par #Float point exception pending, An exception is pending due to the floating-point execution unit.
\par 
\par Virtual-8086 Mode Exceptions
\par 
\par #Invalid Opcode, The emulate instruction bit (EM) of the control register (CR0) is set to 1.
\par #Device Not Available, Save the floating-point or MMX state if the task switch bit (TS) of the control register (CR0) is set to 1.
\par #Segment Overrun, One of the instruction data operands falls outside the address range 00000h to 0FFFFh.
\par #Page fault, A page fault resulted from the execution of the instruction.
\par #Float point exception pending, An exception is pending due to the floating-point execution unit.
\par #Alignment check, An unaligned memory reference resulted from the instruction execution, and the alignment mask bit (AM) of the control register (CR0) is set to 1. (In Protected Mode, CPL = 3.)
{\page}

${\footnote PSWAPD,Opcode}
K{\footnote PSWAPD,PSWAPD;PSWAPD,Opcode}
#{\footnote PSWAPD::5}

{\fs20\b PSWAPD}\tab{\b Opcode}\par\par
0F 0F BB /r PSWAPD mmreg1, mmreg2 or PSWAPD mmreg, mem64
{\page}

${\footnote MASKMOVQ,Description}
K{\footnote MASKMOVQ,MASKMOVQ;MASKMOVQ,Description}
#{\footnote MASKMOVQ::1}

{\fs20\b MASKMOVQ}\tab{\b Description}\par\par
MASKMOVQ: Store using byte mask
\par 
\par The MASKMOVQ instruction uses the result of an MMX compare instruction to conditionally store MMX data to memory on a byte-by-byte basis.
{\page}

${\footnote MASKMOVQ,Operation}
K{\footnote MASKMOVQ,MASKMOVQ;MASKMOVQ,Operation}
#{\footnote MASKMOVQ::2}

{\fs20\b MASKMOVQ}\tab{\b Operation}\par\par
MASKMOVQ mmreg1, mmreg2 (edi) performs the following operations:
\par 
\par memory[edi][63:56] = mmreg2[63] ? mmreg1[63:56] : memory[edi][63:56]
\par memory[edi][55:48] = mmreg2[55] ? mmreg1[55:48] : memory[edi][55:48]
\par memory[edi][47:40] = mmreg2[47] ? mmreg1[47:40] : memory[edi][47:40]
\par memory[edi][39:32] = mmreg2[39] ? mmreg1[39:32] : memory[edi][39:32]
\par memory[edi][31:24] = mmreg2[31] ? mmreg1[31:24] : memory[edi][31:24]
\par memory[edi][23:16] = mmreg2[23] ? mmreg1[23:16] : memory[edi][23:16]
\par memory[edi][15:8] = mmreg2[15] ? mmreg1[15:8] : memory[edi][15:8]
\par memory[edi][7:0] = mmreg2[7] ? mmreg1[7:0] : memory[edi][7:0]
{\page}

${\footnote MASKMOVQ,Flags affected}
K{\footnote MASKMOVQ,MASKMOVQ;MASKMOVQ,Flags affected}
#{\footnote MASKMOVQ::3}

{\fs20\b MASKMOVQ}\tab{\b Flags affected}\par\par
None.
{\page}

${\footnote MASKMOVQ,Exceptions}
K{\footnote MASKMOVQ,MASKMOVQ;MASKMOVQ,Exceptions}
#{\footnote MASKMOVQ::4}

{\fs20\b MASKMOVQ}\tab{\b Exceptions}\par\par
Protected Mode Exceptions
\par 
\par #Invalid Opcode, The emulate instruction bit (EM) of the control register (CR0) is set to 1.
\par #Device Not Available, Save the floating-point or MMX state if the task switch bit (TS) of the control register (CR0) is set to 1.
\par #Stack Exception, During instruction execution, the stack segment limit was exceeded.
\par #General Protection, During instruction execution, the effective address of one of the segment registers used for the operand points to an illegal memory location.
\par #Page fault, A page fault resulted from the execution of the instruction.
\par #Float point exception pending, An exception is pending due to the floating-point execution unit.
\par #Alignment check, An unaligned memory reference resulted from the instruction execution, and the alignment mask bit (AM) of the control register (CR0) is set to 1. (In Protected Mode, CPL = 3.)
\par 
\par Real-Address Mode Exceptions
\par 
\par #Invalid Opcode, The emulate instruction bit (EM) of the control register (CR0) is set to 1.
\par #Device Not Available, Save the floating-point or MMX state if the task switch bit (TS) of the control register (CR0) is set to 1.
\par #Segment Overrun, One of the instruction data operands falls outside the address range 00000h to 0FFFFh.
\par #Float point exception pending, An exception is pending due to the floating-point execution unit.
\par 
\par Virtual-8086 Mode Exceptions
\par 
\par #Invalid Opcode, The emulate instruction bit (EM) of the control register (CR0) is set to 1.
\par #Device Not Available, Save the floating-point or MMX state if the task switch bit (TS) of the control register (CR0) is set to 1.
\par #Segment Overrun, One of the instruction data operands falls outside the address range 00000h to 0FFFFh.
\par #Page fault, A page fault resulted from the execution of the instruction.
\par #Float point exception pending, An exception is pending due to the floating-point execution unit.
\par #Alignment check, An unaligned memory reference resulted from the instruction execution, and the alignment mask bit (AM) of the control register (CR0) is set to 1. (In Protected Mode, CPL = 3.)
{\page}

${\footnote MASKMOVQ,Opcode}
K{\footnote MASKMOVQ,MASKMOVQ;MASKMOVQ,Opcode}
#{\footnote MASKMOVQ::5}

{\fs20\b MASKMOVQ}\tab{\b Opcode}\par\par
0F F7 /r MASKMOVQ mmreg1, mmreg2 (edi)
{\page}

${\footnote MOVNTQ,Description}
K{\footnote MOVNTQ,MOVNTQ;MOVNTQ,Description}
#{\footnote MOVNTQ::1}

{\fs20\b MOVNTQ}\tab{\b Description}\par\par
MOVNTQ: Streaming (cache bypass) store
\par 
\par The MOVNTQ instruction is used to store data without first reading in old data (no write allocate).
{\page}

${\footnote MOVNTQ,Operation}
K{\footnote MOVNTQ,MOVNTQ;MOVNTQ,Operation}
#{\footnote MOVNTQ::2}

{\fs20\b MOVNTQ}\tab{\b Operation}\par\par
MOVNTQ mem64, mmreg performs the following operations:
\par 
\par mem64[63:0] = mmreg
{\page}

${\footnote MOVNTQ,Flags affected}
K{\footnote MOVNTQ,MOVNTQ;MOVNTQ,Flags affected}
#{\footnote MOVNTQ::3}

{\fs20\b MOVNTQ}\tab{\b Flags affected}\par\par
None.
{\page}

${\footnote MOVNTQ,Exceptions}
K{\footnote MOVNTQ,MOVNTQ;MOVNTQ,Exceptions}
#{\footnote MOVNTQ::4}

{\fs20\b MOVNTQ}\tab{\b Exceptions}\par\par
Protected Mode Exceptions
\par 
\par #Invalid Opcode, The emulate instruction bit (EM) of the control register (CR0) is set to 1.
\par #Device Not Available, Save the floating-point or MMX state if the task switch bit (TS) of the control register (CR0) is set to 1.
\par #Stack Exception, During instruction execution, the stack segment limit was exceeded.
\par #General Protection, During instruction execution, the effective address of one of the segment registers used for the operand points to an illegal memory location.
\par #Page fault, A page fault resulted from the execution of the instruction.
\par #Float point exception pending, An exception is pending due to the floating-point execution unit.
\par #Alignment check, An unaligned memory reference resulted from the instruction execution, and the alignment mask bit (AM) of the control register (CR0) is set to 1. (In Protected Mode, CPL = 3.)
\par 
\par Real-Address Mode Exceptions
\par 
\par #Invalid Opcode, The emulate instruction bit (EM) of the control register (CR0) is set to 1.
\par #Device Not Available, Save the floating-point or MMX state if the task switch bit (TS) of the control register (CR0) is set to 1.
\par #Segment Overrun, One of the instruction data operands falls outside the address range 00000h to 0FFFFh.
\par #Float point exception pending, An exception is pending due to the floating-point execution unit.
\par 
\par Virtual-8086 Mode Exceptions
\par 
\par #Invalid Opcode, The emulate instruction bit (EM) of the control register (CR0) is set to 1.
\par #Device Not Available, Save the floating-point or MMX state if the task switch bit (TS) of the control register (CR0) is set to 1.
\par #Segment Overrun, One of the instruction data operands falls outside the address range 00000h to 0FFFFh.
\par #Page fault, A page fault resulted from the execution of the instruction.
\par #Float point exception pending, An exception is pending due to the floating-point execution unit.
\par #Alignment check, An unaligned memory reference resulted from the instruction execution, and the alignment mask bit (AM) of the control register (CR0) is set to 1. (In Protected Mode, CPL = 3.)
{\page}

${\footnote MOVNTQ,Opcode}
K{\footnote MOVNTQ,MOVNTQ;MOVNTQ,Opcode}
#{\footnote MOVNTQ::5}

{\fs20\b MOVNTQ}\tab{\b Opcode}\par\par
0F E7 /r MOVNTQ mem64, mmreg
{\page}

${\footnote PAVGB,Description}
K{\footnote PAVGB,PAVGB;PAVGB,Description}
#{\footnote PAVGB::1}

{\fs20\b PAVGB}\tab{\b Description}\par\par
PAVGB: Packed average of unsigned byte
\par 
\par The PAVGB instruction produces the rounded up averages of the eight unsigned 8-bit integer values in the source operand (an MMX register or a 64-bit memory location) and the eight corresponding unsigned 8-bit integer values in the destination operand (an MMX register). It does so by adding the source and destination byte values to get a 9-bit intermediate value. The intermediate value is then incremented by 1, divided by 2 (shifted right one place) and rounded up. The eight unsigned 8-bit results are stored in the MMX register specified as the destination operand.
\par 
\par The PAVGB instruction is identical to the 3DNow! PAVGUSB instruction and can be used for pixel averaging in MPEG-2 motion compensation and video scaling operations.
{\page}

${\footnote PAVGB,Operation}
K{\footnote PAVGB,PAVGB;PAVGB,Operation}
#{\footnote PAVGB::2}

{\fs20\b PAVGB}\tab{\b Operation}\par\par
PAVGB mmreg1, mmreg2 performs the following operations:
\par 
\par ;round up by using a ceiling function
\par mmreg1[7:0] = (mmreg1[7:0] + mmreg2[7:0]) / 2
\par mmreg1[15:8] = (mmreg1[15:8] + mmreg2[15:8]) / 2
\par mmreg1[23:16] = (mmreg1[23:16] + mmreg2[23:16]) / 2
\par mmreg1[31:24] = (mmreg1[31:24] + mmreg2[31:24]) / 2
\par mmreg1[39:32] = (mmreg1[39:32] + mmreg2[39:32]) / 2
\par mmreg1[47:40] = (mmreg1[47:40] + mmreg2[47:40]) / 2
\par mmreg1[55:48] = (mmreg1[55:48] + mmreg2[55:48]) / 2
\par mmreg1[63:56] = (mmreg1[63:56] + mmreg2[63:56]) / 2
\par 
\par PAVGB mmreg, mem64 performs the following operations:
\par 
\par ;round up by using a ceiling function
\par mmreg[7:0] = (mmreg[7:0] + mem64[7:0]) / 2
\par mmreg[15:8] = (mmreg[15:8] + mem64[15:8]) / 2
\par mmreg[23:16] = (mmreg[23:16] + mem64[23:16]) / 2
\par mmreg[31:24] = (mmreg[31:24] + mem64[31:24]) / 2
\par mmreg[39:32] = (mmreg[39:32] + mem64[39:32]) / 2
\par mmreg[47:40] = (mmreg[47:40] + mem64[47:40]) / 2
\par mmreg[55:48] = (mmreg[55:48] + mem64[55:48]) / 2
\par mmreg[63:56] = (mmreg[63:56] + mem64[63:56]) / 2
{\page}

${\footnote PAVGB,Flags affected}
K{\footnote PAVGB,PAVGB;PAVGB,Flags affected}
#{\footnote PAVGB::3}

{\fs20\b PAVGB}\tab{\b Flags affected}\par\par
None.
{\page}

${\footnote PAVGB,Exceptions}
K{\footnote PAVGB,PAVGB;PAVGB,Exceptions}
#{\footnote PAVGB::4}

{\fs20\b PAVGB}\tab{\b Exceptions}\par\par
Protected Mode Exceptions
\par 
\par #Invalid Opcode, The emulate instruction bit (EM) of the control register (CR0) is set to 1.
\par #Device Not Available, Save the floating-point or MMX state if the task switch bit (TS) of the control register (CR0) is set to 1.
\par #Stack Exception, During instruction execution, the stack segment limit was exceeded.
\par #General Protection, During instruction execution, the effective address of one of the segment registers used for the operand points to an illegal memory location.
\par #Page fault, A page fault resulted from the execution of the instruction.
\par #Float point exception pending, An exception is pending due to the floating-point execution unit.
\par #Alignment check, An unaligned memory reference resulted from the instruction execution, and the alignment mask bit (AM) of the control register (CR0) is set to 1. (In Protected Mode, CPL = 3.)
\par 
\par Real-Address Mode Exceptions
\par 
\par #Invalid Opcode, The emulate instruction bit (EM) of the control register (CR0) is set to 1.
\par #Device Not Available, Save the floating-point or MMX state if the task switch bit (TS) of the control register (CR0) is set to 1.
\par #Segment Overrun, One of the instruction data operands falls outside the address range 00000h to 0FFFFh.
\par #Float point exception pending, An exception is pending due to the floating-point execution unit.
\par 
\par Virtual-8086 Mode Exceptions
\par 
\par #Invalid Opcode, The emulate instruction bit (EM) of the control register (CR0) is set to 1.
\par #Device Not Available, Save the floating-point or MMX state if the task switch bit (TS) of the control register (CR0) is set to 1.
\par #Segment Overrun, One of the instruction data operands falls outside the address range 00000h to 0FFFFh.
\par #Page fault, A page fault resulted from the execution of the instruction.
\par #Float point exception pending, An exception is pending due to the floating-point execution unit.
\par #Alignment check, An unaligned memory reference resulted from the instruction execution, and the alignment mask bit (AM) of the control register (CR0) is set to 1. (In Protected Mode, CPL = 3.)
{\page}

${\footnote PAVGB,Opcode}
K{\footnote PAVGB,PAVGB;PAVGB,Opcode}
#{\footnote PAVGB::5}

{\fs20\b PAVGB}\tab{\b Opcode}\par\par
0F E0 /r PAVGB mmreg1, mmreg2 or PAVGB mmreg, mem64
{\page}

${\footnote PAVGW,Description}
K{\footnote PAVGW,PAVGW;PAVGW,Description}
#{\footnote PAVGW::1}

{\fs20\b PAVGW}\tab{\b Description}\par\par
PAVGW: Packed average of unsigned word
\par 
\par The PAVGW instruction produces the rounded up averages of the four unsigned 16-bit integer values in the source operand (an MMX register or a 64-bit memory location) and the four corresponding unsigned 16-bit integer values in the destination operand (an MMX register).
{\page}

${\footnote PAVGW,Operation}
K{\footnote PAVGW,PAVGW;PAVGW,Operation}
#{\footnote PAVGW::2}

{\fs20\b PAVGW}\tab{\b Operation}\par\par
PAVGW mmreg1, mmreg2 performs the following operations:
\par 
\par ;round up by using a ceiling function
\par mmreg1[15:0] = (mmreg1[15:0] + mmreg2[15:0]) / 2
\par mmreg1[31:16] = (mmreg1[31:16] + mmreg2[31:16]) / 2
\par mmreg1[47:32] = (mmreg1[47:32] + mmreg2[47:32]) / 2
\par mmreg1[63:48] = (mmreg1[63:48] + mmreg2[63:48]) / 2
\par 
\par PAVGW mmreg, mem64 performs the following operations:
\par 
\par ;round up by using a ceiling function
\par mmreg[15:0] = (mmreg[15:0] + mem64[15:0]) / 2
\par mmreg[31:16] = (mmreg[31:16] + mem64[31:16]) / 2
\par mmreg[47:32] = (mmreg[47:32] + mem64[47:32]) / 2
\par mmreg[63:48] = (mmreg[63:48] + mem64[63:48]) / 2
{\page}

${\footnote PAVGW,Flags affected}
K{\footnote PAVGW,PAVGW;PAVGW,Flags affected}
#{\footnote PAVGW::3}

{\fs20\b PAVGW}\tab{\b Flags affected}\par\par
None.
{\page}

${\footnote PAVGW,Exceptions}
K{\footnote PAVGW,PAVGW;PAVGW,Exceptions}
#{\footnote PAVGW::4}

{\fs20\b PAVGW}\tab{\b Exceptions}\par\par
Protected Mode Exceptions
\par 
\par #Invalid Opcode, The emulate instruction bit (EM) of the control register (CR0) is set to 1.
\par #Device Not Available, Save the floating-point or MMX state if the task switch bit (TS) of the control register (CR0) is set to 1.
\par #Stack Exception, During instruction execution, the stack segment limit was exceeded.
\par #General Protection, During instruction execution, the effective address of one of the segment registers used for the operand points to an illegal memory location.
\par #Page fault, A page fault resulted from the execution of the instruction.
\par #Float point exception pending, An exception is pending due to the floating-point execution unit.
\par #Alignment check, An unaligned memory reference resulted from the instruction execution, and the alignment mask bit (AM) of the control register (CR0) is set to 1. (In Protected Mode, CPL = 3.)
\par 
\par Real-Address Mode Exceptions
\par 
\par #Invalid Opcode, The emulate instruction bit (EM) of the control register (CR0) is set to 1.
\par #Device Not Available, Save the floating-point or MMX state if the task switch bit (TS) of the control register (CR0) is set to 1.
\par #Segment Overrun, One of the instruction data operands falls outside the address range 00000h to 0FFFFh.
\par #Float point exception pending, An exception is pending due to the floating-point execution unit.
\par 
\par Virtual-8086 Mode Exceptions
\par 
\par #Invalid Opcode, The emulate instruction bit (EM) of the control register (CR0) is set to 1.
\par #Device Not Available, Save the floating-point or MMX state if the task switch bit (TS) of the control register (CR0) is set to 1.
\par #Segment Overrun, One of the instruction data operands falls outside the address range 00000h to 0FFFFh.
\par #Page fault, A page fault resulted from the execution of the instruction.
\par #Float point exception pending, An exception is pending due to the floating-point execution unit.
\par #Alignment check, An unaligned memory reference resulted from the instruction execution, and the alignment mask bit (AM) of the control register (CR0) is set to 1. (In Protected Mode, CPL = 3.)
{\page}

${\footnote PAVGW,Opcode}
K{\footnote PAVGW,PAVGW;PAVGW,Opcode}
#{\footnote PAVGW::5}

{\fs20\b PAVGW}\tab{\b Opcode}\par\par
0F E3 /r PAVGW mmreg1, mmreg2 or PAVGB mmreg, mem64
{\page}

${\footnote PEXTRW,Description}
K{\footnote PEXTRW,PEXTRW;PEXTRW,Description}
#{\footnote PEXTRW::1}

{\fs20\b PEXTRW}\tab{\b Description}\par\par
PEXTRW: Extract word into integer register
\par 
\par The PEXTRW instruction extracts one of the four words pointed to by imm8 from an MMX register and stores that into the least significant word of a 32-bit integer register.
{\page}

${\footnote PEXTRW,Operation}
K{\footnote PEXTRW,PEXTRW;PEXTRW,Operation}
#{\footnote PEXTRW::2}

{\fs20\b PEXTRW}\tab{\b Operation}\par\par
PEXTRW reg32, mmreg, imm8 performs the following operations:
\par 
\par index = imm8[1:0] * 16
\par reg32[31:16] = 0
\par reg32[15:0] = mmreg[index+15:index]
{\page}

${\footnote PEXTRW,Flags affected}
K{\footnote PEXTRW,PEXTRW;PEXTRW,Flags affected}
#{\footnote PEXTRW::3}

{\fs20\b PEXTRW}\tab{\b Flags affected}\par\par
None.
{\page}

${\footnote PEXTRW,Exceptions}
K{\footnote PEXTRW,PEXTRW;PEXTRW,Exceptions}
#{\footnote PEXTRW::4}

{\fs20\b PEXTRW}\tab{\b Exceptions}\par\par
Protected Mode Exceptions
\par 
\par #Invalid Opcode, The emulate instruction bit (EM) of the control register (CR0) is set to 1.
\par #Device Not Available, Save the floating-point or MMX state if the task switch bit (TS) of the control register (CR0) is set to 1.
\par #Stack Exception, During instruction execution, the stack segment limit was exceeded.
\par #General Protection, During instruction execution, the effective address of one of the segment registers used for the operand points to an illegal memory location.
\par #Page fault, A page fault resulted from the execution of the instruction.
\par #Float point exception pending, An exception is pending due to the floating-point execution unit.
\par #Alignment check, An unaligned memory reference resulted from the instruction execution, and the alignment mask bit (AM) of the control register (CR0) is set to 1. (In Protected Mode, CPL = 3.)
\par 
\par Real-Address Mode Exceptions
\par 
\par #Invalid Opcode, The emulate instruction bit (EM) of the control register (CR0) is set to 1.
\par #Device Not Available, Save the floating-point or MMX state if the task switch bit (TS) of the control register (CR0) is set to 1.
\par #Segment Overrun, One of the instruction data operands falls outside the address range 00000h to 0FFFFh.
\par #Float point exception pending, An exception is pending due to the floating-point execution unit.
\par 
\par Virtual-8086 Mode Exceptions
\par 
\par #Invalid Opcode, The emulate instruction bit (EM) of the control register (CR0) is set to 1.
\par #Device Not Available, Save the floating-point or MMX state if the task switch bit (TS) of the control register (CR0) is set to 1.
\par #Segment Overrun, One of the instruction data operands falls outside the address range 00000h to 0FFFFh.
\par #Page fault, A page fault resulted from the execution of the instruction.
\par #Float point exception pending, An exception is pending due to the floating-point execution unit.
\par #Alignment check, An unaligned memory reference resulted from the instruction execution, and the alignment mask bit (AM) of the control register (CR0) is set to 1. (In Protected Mode, CPL = 3.)
{\page}

${\footnote PEXTRW,Opcode}
K{\footnote PEXTRW,PEXTRW;PEXTRW,Opcode}
#{\footnote PEXTRW::5}

{\fs20\b PEXTRW}\tab{\b Opcode}\par\par
0F C5 /r PEXTRW reg32, mmreg, imm8
{\page}

${\footnote PINSRW,Description}
K{\footnote PINSRW,PINSRW;PINSRW,Description}
#{\footnote PINSRW::1}

{\fs20\b PINSRW}\tab{\b Description}\par\par
PINSRW: Insert word from integer register
\par 
\par The PINSRW instruction inserts the least significant word of an integer register into one of the four words of an MMX register.
{\page}

${\footnote PINSRW,Operation}
K{\footnote PINSRW,PINSRW;PINSRW,Operation}
#{\footnote PINSRW::2}

{\fs20\b PINSRW}\tab{\b Operation}\par\par
PINSRW mmreg, reg32, imm8 performs the following operations:
\par 
\par index = imm8[1:0] * 16
\par mmreg[index+15:index] = reg32[15:0]
\par mmreg[rest] = mmreg[rest] / no change (merge)
\par 
\par PINSRW mmreg, mem16, imm8 performs the following operations:
\par 
\par index = imm8[1:0] * 16
\par mmreg[index+15:index] = mem16[15:0]
\par mmreg[rest] = mmreg[rest] / no change (merge)
{\page}

${\footnote PINSRW,Flags affected}
K{\footnote PINSRW,PINSRW;PINSRW,Flags affected}
#{\footnote PINSRW::3}

{\fs20\b PINSRW}\tab{\b Flags affected}\par\par
None.
{\page}

${\footnote PINSRW,Exceptions}
K{\footnote PINSRW,PINSRW;PINSRW,Exceptions}
#{\footnote PINSRW::4}

{\fs20\b PINSRW}\tab{\b Exceptions}\par\par
Protected Mode Exceptions
\par 
\par #Invalid Opcode, The emulate instruction bit (EM) of the control register (CR0) is set to 1.
\par #Device Not Available, Save the floating-point or MMX state if the task switch bit (TS) of the control register (CR0) is set to 1.
\par #Stack Exception, During instruction execution, the stack segment limit was exceeded.
\par #General Protection, During instruction execution, the effective address of one of the segment registers used for the operand points to an illegal memory location.
\par #Page fault, A page fault resulted from the execution of the instruction.
\par #Float point exception pending, An exception is pending due to the floating-point execution unit.
\par #Alignment check, An unaligned memory reference resulted from the instruction execution, and the alignment mask bit (AM) of the control register (CR0) is set to 1. (In Protected Mode, CPL = 3.)
\par 
\par Real-Address Mode Exceptions
\par 
\par #Invalid Opcode, The emulate instruction bit (EM) of the control register (CR0) is set to 1.
\par #Device Not Available, Save the floating-point or MMX state if the task switch bit (TS) of the control register (CR0) is set to 1.
\par #Segment Overrun, One of the instruction data operands falls outside the address range 00000h to 0FFFFh.
\par #Float point exception pending, An exception is pending due to the floating-point execution unit.
\par 
\par Virtual-8086 Mode Exceptions
\par 
\par #Invalid Opcode, The emulate instruction bit (EM) of the control register (CR0) is set to 1.
\par #Device Not Available, Save the floating-point or MMX state if the task switch bit (TS) of the control register (CR0) is set to 1.
\par #Segment Overrun, One of the instruction data operands falls outside the address range 00000h to 0FFFFh.
\par #Page fault, A page fault resulted from the execution of the instruction.
\par #Float point exception pending, An exception is pending due to the floating-point execution unit.
\par #Alignment check, An unaligned memory reference resulted from the instruction execution, and the alignment mask bit (AM) of the control register (CR0) is set to 1. (In Protected Mode, CPL = 3.)
{\page}

${\footnote PINSRW,Opcode}
K{\footnote PINSRW,PINSRW;PINSRW,Opcode}
#{\footnote PINSRW::5}

{\fs20\b PINSRW}\tab{\b Opcode}\par\par
0F C4 /r PINSRW mmreg, reg32, imm8 or PINSRW mmreg, mem16, imm8
{\page}

${\footnote PMAXSW,Description}
K{\footnote PMAXSW,PMAXSW;PMAXSW,Description}
#{\footnote PMAXSW::1}

{\fs20\b PMAXSW}\tab{\b Description}\par\par
PMAXSW: Packed maximum signed word
\par 
\par The PMAXSW instruction operates on signed 16-bit data and selects the maximum signed value between source 1 and source 2 for each of the four word positions.
{\page}

${\footnote PMAXSW,Operation}
K{\footnote PMAXSW,PMAXSW;PMAXSW,Operation}
#{\footnote PMAXSW::2}

{\fs20\b PMAXSW}\tab{\b Operation}\par\par
PMAXSW mmreg1, mmreg2 performs the following signed operations:
\par 
\par mmreg1[15:0] = (mmreg1[15:0] > mmreg2[15:0]) ? mmreg1[15:0] : mmreg2[15:0]
\par mmreg1[31:16] = (mmreg1[31:16] > mmreg2[31:16]) ? mmreg1[31:16] : mmreg2[31:16]
\par mmreg1[47:32] = (mmreg1[47:32] > mmreg2[47:32]) ? mmreg1[47:32] : mmreg2[47:32]
\par mmreg1[63:48] = (mmreg1[63:48] > mmreg2[63:48]) ? mmreg1[63:48] : mmreg2[63:48]
\par 
\par PMAXSW mmreg, mem64 performs the following signed operations:
\par mmreg[15:0] = (mmreg[15:0] > mem64[15:0]) ? mmreg[15:0] : mem64[15:0]
\par mmreg[31:16] = (mmreg[31:16] > mem64[31:16]) ? mmreg[31:16] : mem64[31:16]
\par mmreg[47:32] = (mmreg[47:32] > mem64[47:32]) ? mmreg[47:32] : mem64[47:32]
\par mmreg[63:48] = (mmreg[63:48] > mem64[63:48]) ? mmreg[63:48] : mem64[63:48]
{\page}

${\footnote PMAXSW,Flags affected}
K{\footnote PMAXSW,PMAXSW;PMAXSW,Flags affected}
#{\footnote PMAXSW::3}

{\fs20\b PMAXSW}\tab{\b Flags affected}\par\par
None.
{\page}

${\footnote PMAXSW,Exceptions}
K{\footnote PMAXSW,PMAXSW;PMAXSW,Exceptions}
#{\footnote PMAXSW::4}

{\fs20\b PMAXSW}\tab{\b Exceptions}\par\par
Protected Mode Exceptions
\par 
\par #Invalid Opcode, The emulate instruction bit (EM) of the control register (CR0) is set to 1.
\par #Device Not Available, Save the floating-point or MMX state if the task switch bit (TS) of the control register (CR0) is set to 1.
\par #Stack Exception, During instruction execution, the stack segment limit was exceeded.
\par #General Protection, During instruction execution, the effective address of one of the segment registers used for the operand points to an illegal memory location.
\par #Page fault, A page fault resulted from the execution of the instruction.
\par #Float point exception pending, An exception is pending due to the floating-point execution unit.
\par #Alignment check, An unaligned memory reference resulted from the instruction execution, and the alignment mask bit (AM) of the control register (CR0) is set to 1. (In Protected Mode, CPL = 3.)
\par 
\par Real-Address Mode Exceptions
\par 
\par #Invalid Opcode, The emulate instruction bit (EM) of the control register (CR0) is set to 1.
\par #Device Not Available, Save the floating-point or MMX state if the task switch bit (TS) of the control register (CR0) is set to 1.
\par #Segment Overrun, One of the instruction data operands falls outside the address range 00000h to 0FFFFh.
\par #Float point exception pending, An exception is pending due to the floating-point execution unit.
\par 
\par Virtual-8086 Mode Exceptions
\par 
\par #Invalid Opcode, The emulate instruction bit (EM) of the control register (CR0) is set to 1.
\par #Device Not Available, Save the floating-point or MMX state if the task switch bit (TS) of the control register (CR0) is set to 1.
\par #Segment Overrun, One of the instruction data operands falls outside the address range 00000h to 0FFFFh.
\par #Page fault, A page fault resulted from the execution of the instruction.
\par #Float point exception pending, An exception is pending due to the floating-point execution unit.
\par #Alignment check, An unaligned memory reference resulted from the instruction execution, and the alignment mask bit (AM) of the control register (CR0) is set to 1. (In Protected Mode, CPL = 3.)
{\page}

${\footnote PMAXSW,Opcode}
K{\footnote PMAXSW,PMAXSW;PMAXSW,Opcode}
#{\footnote PMAXSW::5}

{\fs20\b PMAXSW}\tab{\b Opcode}\par\par
0F EE /r PMAXSW mmreg1, mmreg2 or PMAXSW mmreg, mem64
{\page}

${\footnote PMAXUB,Description}
K{\footnote PMAXUB,PMAXUB;PMAXUB,Description}
#{\footnote PMAXUB::1}

{\fs20\b PMAXUB}\tab{\b Description}\par\par
PMAXUB: Packed maximum unsigned byte
\par 
\par The PMAXUB instruction operates on unsigned 8-bit data and selects the maximum unsigned value between source 1 and source 2 for each of the eight byte positions.
{\page}

${\footnote PMAXUB,Operation}
K{\footnote PMAXUB,PMAXUB;PMAXUB,Operation}
#{\footnote PMAXUB::2}

{\fs20\b PMAXUB}\tab{\b Operation}\par\par
PMAXUB mmreg1, mmreg2 performs the following unsigned operations:
\par 
\par mmreg1[7:0] = (mmreg1[7:0] > mmreg2[7:0]) ? mmreg1[7:0] : mmreg2[7:0]
\par mmreg1[15:8] = (mmreg1[15:8] > mmreg2[15:8]) ? mmreg1[15:8] : mmreg2[15:8]
\par mmreg1[23:16] = (mmreg1[23:16] > mmreg2[23:16]) ? mmreg1[23:16] : mmreg2[23:16]
\par mmreg1[31:24] = (mmreg1[31:24] > mmreg2[31:24]) ? mmreg1[31:24] : mmreg2[31:24]
\par mmreg1[39:32] = (mmreg1[39:32] > mmreg2[39:32]) ? mmreg1[39:32] : mmreg2[39:32]
\par mmreg1[47:40] = (mmreg1[47:40] > mmreg2[47:40]) ? mmreg1[47:40] : mmreg2[47:40]
\par mmreg1[55:48] = (mmreg1[55:48] > mmreg2[55:48]) ? mmreg1[55:48] : mmreg2[55:48]
\par mmreg1[63:56] = (mmreg1[63:56] > mmreg2[63:56]) ? mmreg1[63:56] : mmreg2[63:56]
\par 
\par PMAXUB mmreg, mem64 performs the following unsigned operations:
\par 
\par mmreg[7:0] = (mmreg[7:0] > mem64[7:0]) ? mmreg[7:0] : mem64[7:0]
\par mmreg[15:8] = (mmreg[15:8] > mem64[15:8]) ? mmreg[15:8] : mem64[15:8]
\par mmreg[23:16] = (mmreg[23:16] > mem64[23:16]) ? mmreg[23:16] : mem64[23:16]
\par mmreg[31:24] = (mmreg[31:24] > mem64[31:24]) ? mmreg[31:24] : mem64[31:24]
\par mmreg[39:32] = (mmreg[39:32] > mem64[39:32]) ? mmreg[39:32] : mem64[39:32]
\par mmreg[47:40] = (mmreg[47:40] > mem64[47:40]) ? mmreg[47:40] : mem64[47:40]
\par mmreg[55:48] = (mmreg[55:48] > mem64[55:48]) ? mmreg[55:48] : mem64[55:48]
\par mmreg[63:56] = (mmreg[63:56] > mem64[63:56]) ? mmreg[63:56] : mem64[63:56]
{\page}

${\footnote PMAXUB,Flags affected}
K{\footnote PMAXUB,PMAXUB;PMAXUB,Flags affected}
#{\footnote PMAXUB::3}

{\fs20\b PMAXUB}\tab{\b Flags affected}\par\par
None.
{\page}

${\footnote PMAXUB,Exceptions}
K{\footnote PMAXUB,PMAXUB;PMAXUB,Exceptions}
#{\footnote PMAXUB::4}

{\fs20\b PMAXUB}\tab{\b Exceptions}\par\par
Protected Mode Exceptions
\par 
\par #Invalid Opcode, The emulate instruction bit (EM) of the control register (CR0) is set to 1.
\par #Device Not Available, Save the floating-point or MMX state if the task switch bit (TS) of the control register (CR0) is set to 1.
\par #Stack Exception, During instruction execution, the stack segment limit was exceeded.
\par #General Protection, During instruction execution, the effective address of one of the segment registers used for the operand points to an illegal memory location.
\par #Page fault, A page fault resulted from the execution of the instruction.
\par #Float point exception pending, An exception is pending due to the floating-point execution unit.
\par #Alignment check, An unaligned memory reference resulted from the instruction execution, and the alignment mask bit (AM) of the control register (CR0) is set to 1. (In Protected Mode, CPL = 3.)
\par 
\par Real-Address Mode Exceptions
\par 
\par #Invalid Opcode, The emulate instruction bit (EM) of the control register (CR0) is set to 1.
\par #Device Not Available, Save the floating-point or MMX state if the task switch bit (TS) of the control register (CR0) is set to 1.
\par #Segment Overrun, One of the instruction data operands falls outside the address range 00000h to 0FFFFh.
\par #Float point exception pending, An exception is pending due to the floating-point execution unit.
\par 
\par Virtual-8086 Mode Exceptions
\par 
\par #Invalid Opcode, The emulate instruction bit (EM) of the control register (CR0) is set to 1.
\par #Device Not Available, Save the floating-point or MMX state if the task switch bit (TS) of the control register (CR0) is set to 1.
\par #Segment Overrun, One of the instruction data operands falls outside the address range 00000h to 0FFFFh.
\par #Page fault, A page fault resulted from the execution of the instruction.
\par #Float point exception pending, An exception is pending due to the floating-point execution unit.
\par #Alignment check, An unaligned memory reference resulted from the instruction execution, and the alignment mask bit (AM) of the control register (CR0) is set to 1. (In Protected Mode, CPL = 3.)
{\page}

${\footnote PMAXUB,Opcode}
K{\footnote PMAXUB,PMAXUB;PMAXUB,Opcode}
#{\footnote PMAXUB::5}

{\fs20\b PMAXUB}\tab{\b Opcode}\par\par
0F DE /r PMAXUB mmreg1, mmreg2 or PMAXUB mmreg, mem64
{\page}

${\footnote PMINSW,Description}
K{\footnote PMINSW,PMINSW;PMINSW,Description}
#{\footnote PMINSW::1}

{\fs20\b PMINSW}\tab{\b Description}\par\par
PMINSW: Packed minimum signed word
\par 
\par The PMINSW instruction operates on signed 16-bit data and selects the minimum arithmetic value between source 1 and source 2 for each word.
{\page}

${\footnote PMINSW,Operation}
K{\footnote PMINSW,PMINSW;PMINSW,Operation}
#{\footnote PMINSW::2}

{\fs20\b PMINSW}\tab{\b Operation}\par\par
PMINSW mmreg1, mmreg2 performs the following signed operations:
\par 
\par mmreg1[15:0] = (mmreg1[15:0] <= mmreg2[15:0]) ? mmreg1[15:0] : mmreg2[15:0]
\par mmreg1[31:16] = (mmreg1[31:16] <= mmreg2[31:16]) ? mmreg1[31:16] : mmreg2[31:16]
\par mmreg1[47:32] = (mmreg1[47:32] <= mmreg2[47:32]) ? mmreg1[47:32] : mmreg2[47:32]
\par mmreg1[63:48] = (mmreg1[63:48] <= mmreg2[63:48]) ? mmreg1[63:48] : mmreg2[63:48]
\par 
\par PMINSW mmreg, mem64 performs the following signed operations:
\par 
\par mmreg[15:0] = (mmreg[15:0] <= mem64[15:0]) ? mmreg[15:0] : mem64[15:0]
\par mmreg[31:16] = (mmreg[31:16] <= mem64[31:16]) ? mmreg[31:16] : mem64[31:16]
\par mmreg[47:32] = (mmreg[47:32] <= mem64[47:32]) ? mmreg[47:32] : mem64[47:32]
\par mmreg[63:48] = (mmreg[63:48] <= mem64[63:48]) ? mmreg[63:48] : mem64[63:48]
{\page}

${\footnote PMINSW,Flags affected}
K{\footnote PMINSW,PMINSW;PMINSW,Flags affected}
#{\footnote PMINSW::3}

{\fs20\b PMINSW}\tab{\b Flags affected}\par\par
None.
{\page}

${\footnote PMINSW,Exceptions}
K{\footnote PMINSW,PMINSW;PMINSW,Exceptions}
#{\footnote PMINSW::4}

{\fs20\b PMINSW}\tab{\b Exceptions}\par\par
Protected Mode Exceptions
\par 
\par #Invalid Opcode, The emulate instruction bit (EM) of the control register (CR0) is set to 1.
\par #Device Not Available, Save the floating-point or MMX state if the task switch bit (TS) of the control register (CR0) is set to 1.
\par #Stack Exception, During instruction execution, the stack segment limit was exceeded.
\par #General Protection, During instruction execution, the effective address of one of the segment registers used for the operand points to an illegal memory location.
\par #Page fault, A page fault resulted from the execution of the instruction.
\par #Float point exception pending, An exception is pending due to the floating-point execution unit.
\par #Alignment check, An unaligned memory reference resulted from the instruction execution, and the alignment mask bit (AM) of the control register (CR0) is set to 1. (In Protected Mode, CPL = 3.)
\par 
\par Real-Address Mode Exceptions
\par 
\par #Invalid Opcode, The emulate instruction bit (EM) of the control register (CR0) is set to 1.
\par #Device Not Available, Save the floating-point or MMX state if the task switch bit (TS) of the control register (CR0) is set to 1.
\par #Segment Overrun, One of the instruction data operands falls outside the address range 00000h to 0FFFFh.
\par #Float point exception pending, An exception is pending due to the floating-point execution unit.
\par 
\par Virtual-8086 Mode Exceptions
\par 
\par #Invalid Opcode, The emulate instruction bit (EM) of the control register (CR0) is set to 1.
\par #Device Not Available, Save the floating-point or MMX state if the task switch bit (TS) of the control register (CR0) is set to 1.
\par #Segment Overrun, One of the instruction data operands falls outside the address range 00000h to 0FFFFh.
\par #Page fault, A page fault resulted from the execution of the instruction.
\par #Float point exception pending, An exception is pending due to the floating-point execution unit.
\par #Alignment check, An unaligned memory reference resulted from the instruction execution, and the alignment mask bit (AM) of the control register (CR0) is set to 1. (In Protected Mode, CPL = 3.)
{\page}

${\footnote PMINSW,Opcode}
K{\footnote PMINSW,PMINSW;PMINSW,Opcode}
#{\footnote PMINSW::5}

{\fs20\b PMINSW}\tab{\b Opcode}\par\par
0F EA /r PMINSW mmreg1, mmreg2 or PMINSW mmreg, mem64
{\page}

${\footnote PMINUB,Description}
K{\footnote PMINUB,PMINUB;PMINUB,Description}
#{\footnote PMINUB::1}

{\fs20\b PMINUB}\tab{\b Description}\par\par
PMINUB: Packed minimum unsigned byte
\par 
\par The PMINUB instruction operates on unsigned 8-bit data and selects the minimum value between source 1 and source 2 for each byte position.
{\page}

${\footnote PMINUB,Operation}
K{\footnote PMINUB,PMINUB;PMINUB,Operation}
#{\footnote PMINUB::2}

{\fs20\b PMINUB}\tab{\b Operation}\par\par
PMINUB mmreg1, mmreg2 performs the following unsigned operations:
\par 
\par mmreg1[7:0] = (mmreg1[7:0] <= mmreg2[7:0]) ? mmreg1[7:0] : mmreg2[7:0]
\par mmreg1[15:8] = (mmreg1[15:8] <= mmreg2[15:8]) ? mmreg1[15:8] : mmreg2[15:8]
\par mmreg1[23:16] = (mmreg1[23:16] <= mmreg2[23:16]) ? mmreg1[23:16] : mmreg2[23:16]
\par mmreg1[31:24] = (mmreg1[31:24] <= mmreg2[31:24]) ? mmreg1[31:24] : mmreg2[31:24]
\par mmreg1[39:32] = (mmreg1[39:32] <= mmreg2[39:32]) ? mmreg1[39:32] : mmreg2[39:32]
\par mmreg1[47:40] = (mmreg1[47:40] <= mmreg2[47:40]) ? mmreg1[47:40] : mmreg2[47:40]
\par mmreg1[55:48] = (mmreg1[55:48] <= mmreg2[55:48]) ? mmreg1[55:48] : mmreg2[55:48]
\par mmreg1[63:56] = (mmreg1[63:56] <= mmreg2[63:56]) ? mmreg1[63:56] : mmreg2[63:56]
\par 
\par PMINUB mmreg1, mem64 performs the following unsigned operations:
\par 
\par mmreg[7:0] = (mmreg[7:0] <= mem64[7:0]) ? mmreg[7:0] : mem64[7:0]
\par mmreg[15:8] = (mmreg[15:8] <= mem64[15:8]) ? mmreg[15:8] : mem64[15:8]
\par mmreg[23:16] = (mmreg[23:16] <= mem64[23:16]) ? mmreg[23:16] : mem64[23:16]
\par mmreg[31:24] = (mmreg[31:24] <= mem64[31:24]) ? mmreg[31:24] : mem64[31:24]
\par mmreg[39:32] = (mmreg[39:32] <= mem64[39:32]) ? mmreg[39:32] : mem64[39:32]
\par mmreg[47:40] = (mmreg[47:40] <= mem64[47:40]) ? mmreg[47:40] : mem64[47:40]
\par mmreg[55:48] = (mmreg[55:48] <= mem64[55:48]) ? mmreg[55:48] : mem64[55:48]
\par mmreg[63:56] = (mmreg[63:56] <= mem64[63:56]) ? mmreg[63:56] : mem64[63:56]
{\page}

${\footnote PMINUB,Flags affected}
K{\footnote PMINUB,PMINUB;PMINUB,Flags affected}
#{\footnote PMINUB::3}

{\fs20\b PMINUB}\tab{\b Flags affected}\par\par
None.
{\page}

${\footnote PMINUB,Exceptions}
K{\footnote PMINUB,PMINUB;PMINUB,Exceptions}
#{\footnote PMINUB::4}

{\fs20\b PMINUB}\tab{\b Exceptions}\par\par
Protected Mode Exceptions
\par 
\par #Invalid Opcode, The emulate instruction bit (EM) of the control register (CR0) is set to 1.
\par #Device Not Available, Save the floating-point or MMX state if the task switch bit (TS) of the control register (CR0) is set to 1.
\par #Stack Exception, During instruction execution, the stack segment limit was exceeded.
\par #General Protection, During instruction execution, the effective address of one of the segment registers used for the operand points to an illegal memory location.
\par #Page fault, A page fault resulted from the execution of the instruction.
\par #Float point exception pending, An exception is pending due to the floating-point execution unit.
\par #Alignment check, An unaligned memory reference resulted from the instruction execution, and the alignment mask bit (AM) of the control register (CR0) is set to 1. (In Protected Mode, CPL = 3.)
\par 
\par Real-Address Mode Exceptions
\par 
\par #Invalid Opcode, The emulate instruction bit (EM) of the control register (CR0) is set to 1.
\par #Device Not Available, Save the floating-point or MMX state if the task switch bit (TS) of the control register (CR0) is set to 1.
\par #Segment Overrun, One of the instruction data operands falls outside the address range 00000h to 0FFFFh.
\par #Float point exception pending, An exception is pending due to the floating-point execution unit.
\par 
\par Virtual-8086 Mode Exceptions
\par 
\par #Invalid Opcode, The emulate instruction bit (EM) of the control register (CR0) is set to 1.
\par #Device Not Available, Save the floating-point or MMX state if the task switch bit (TS) of the control register (CR0) is set to 1.
\par #Segment Overrun, One of the instruction data operands falls outside the address range 00000h to 0FFFFh.
\par #Page fault, A page fault resulted from the execution of the instruction.
\par #Float point exception pending, An exception is pending due to the floating-point execution unit.
\par #Alignment check, An unaligned memory reference resulted from the instruction execution, and the alignment mask bit (AM) of the control register (CR0) is set to 1. (In Protected Mode, CPL = 3.)
{\page}

${\footnote PMINUB,Opcode}
K{\footnote PMINUB,PMINUB;PMINUB,Opcode}
#{\footnote PMINUB::5}

{\fs20\b PMINUB}\tab{\b Opcode}\par\par
0F DA /r PMINUB mmreg1, mmreg2 or PMINUB mmreg, mem64
{\page}

${\footnote PMOVMSKB,Description}
K{\footnote PMOVMSKB,PMOVMSKB;PMOVMSKB,Description}
#{\footnote PMOVMSKB::1}

{\fs20\b PMOVMSKB}\tab{\b Description}\par\par
PMOVMSKB: Move mask to integer register
\par 
\par The PMOVMSKB instruction selects the most significant bit from each byte position of an MMX register and collapses all eight bits into the least significant byte of an integer register.
{\page}

${\footnote PMOVMSKB,Operation}
K{\footnote PMOVMSKB,PMOVMSKB;PMOVMSKB,Operation}
#{\footnote PMOVMSKB::2}

{\fs20\b PMOVMSKB}\tab{\b Operation}\par\par
PMOVMSKB reg32, mmreg performs the following operations:
\par 
\par reg32[31:8] = 0
\par reg32[7] = mmreg[63]
\par reg32[6] = mmreg[55]
\par reg32[5] = mmreg[47]
\par reg32[4] = mmreg[39]
\par reg32[3] = mmreg[31]
\par reg32[2] = mmreg[23]
\par reg32[1] = mmreg[15]
\par reg32[0] = mmreg[7]
{\page}

${\footnote PMOVMSKB,Flags affected}
K{\footnote PMOVMSKB,PMOVMSKB;PMOVMSKB,Flags affected}
#{\footnote PMOVMSKB::3}

{\fs20\b PMOVMSKB}\tab{\b Flags affected}\par\par
None.
{\page}

${\footnote PMOVMSKB,Exceptions}
K{\footnote PMOVMSKB,PMOVMSKB;PMOVMSKB,Exceptions}
#{\footnote PMOVMSKB::4}

{\fs20\b PMOVMSKB}\tab{\b Exceptions}\par\par
Protected Mode Exceptions
\par 
\par #Invalid Opcode, The emulate instruction bit (EM) of the control register (CR0) is set to 1.
\par #Device Not Available, Save the floating-point or MMX state if the task switch bit (TS) of the control register (CR0) is set to 1.
\par #Stack Exception, During instruction execution, the stack segment limit was exceeded.
\par #General Protection, During instruction execution, the effective address of one of the segment registers used for the operand points to an illegal memory location.
\par #Page fault, A page fault resulted from the execution of the instruction.
\par #Float point exception pending, An exception is pending due to the floating-point execution unit.
\par #Alignment check, An unaligned memory reference resulted from the instruction execution, and the alignment mask bit (AM) of the control register (CR0) is set to 1. (In Protected Mode, CPL = 3.)
\par 
\par Real-Address Mode Exceptions
\par 
\par #Invalid Opcode, The emulate instruction bit (EM) of the control register (CR0) is set to 1.
\par #Device Not Available, Save the floating-point or MMX state if the task switch bit (TS) of the control register (CR0) is set to 1.
\par #Segment Overrun, One of the instruction data operands falls outside the address range 00000h to 0FFFFh.
\par #Float point exception pending, An exception is pending due to the floating-point execution unit.
\par 
\par Virtual-8086 Mode Exceptions
\par 
\par #Invalid Opcode, The emulate instruction bit (EM) of the control register (CR0) is set to 1.
\par #Device Not Available, Save the floating-point or MMX state if the task switch bit (TS) of the control register (CR0) is set to 1.
\par #Segment Overrun, One of the instruction data operands falls outside the address range 00000h to 0FFFFh.
\par #Page fault, A page fault resulted from the execution of the instruction.
\par #Float point exception pending, An exception is pending due to the floating-point execution unit.
\par #Alignment check, An unaligned memory reference resulted from the instruction execution, and the alignment mask bit (AM) of the control register (CR0) is set to 1. (In Protected Mode, CPL = 3.)
{\page}

${\footnote PMOVMSKB,Opcode}
K{\footnote PMOVMSKB,PMOVMSKB;PMOVMSKB,Opcode}
#{\footnote PMOVMSKB::5}

{\fs20\b PMOVMSKB}\tab{\b Opcode}\par\par
0F D7 /r PMOVMSKB reg32, mmreg
{\page}

${\footnote PMULHUW,Description}
K{\footnote PMULHUW,PMULHUW;PMULHUW,Description}
#{\footnote PMULHUW::1}

{\fs20\b PMULHUW}\tab{\b Description}\par\par
PMULHUW: Packed multiply high unsigned word
\par 
\par The PMULHUW instruction multiplies the four unsigned words in the source operand with the four unsigned words in the destination operand. The upper 16 bits of the 32-bit intermediate result is placed into the destination operand.
{\page}

${\footnote PMULHUW,Operation}
K{\footnote PMULHUW,PMULHUW;PMULHUW,Operation}
#{\footnote PMULHUW::2}

{\fs20\b PMULHUW}\tab{\b Operation}\par\par
PMULHUW mmreg1, mmreg2 performs the following operations:
\par 
\par mmreg1[15:0] = (mmreg1[15:0] * mmreg2[15:0])[31:16]
\par mmreg1[31:16] = (mmreg1[31:16] * mmreg2[31:16])[31:16]
\par mmreg1[47:32] = (mmreg1[47:32] * mmreg2[47:32])[31:16]
\par mmreg1[63:48] = (mmreg1[63:48] * mmreg2[63:48])[31:16]
\par PMULHUW mmreg, mem64 performs the following operations:
\par 
\par mmreg[15:0] = (mmreg[15:0] * mem64[15:0])[31:16]
\par mmreg[31:16] = (mmreg[31:16] * mem64[31:16])[31:16]
\par mmreg[47:32] = (mmreg[47:32] * mem64[47:32])[31:16]
\par mmreg[63:48] = (mmreg[63:48] * mem64[63:48])[31:16]
{\page}

${\footnote PMULHUW,Flags affected}
K{\footnote PMULHUW,PMULHUW;PMULHUW,Flags affected}
#{\footnote PMULHUW::3}

{\fs20\b PMULHUW}\tab{\b Flags affected}\par\par
None.
{\page}

${\footnote PMULHUW,Exceptions}
K{\footnote PMULHUW,PMULHUW;PMULHUW,Exceptions}
#{\footnote PMULHUW::4}

{\fs20\b PMULHUW}\tab{\b Exceptions}\par\par
Protected Mode Exceptions
\par 
\par #Invalid Opcode, The emulate instruction bit (EM) of the control register (CR0) is set to 1.
\par #Device Not Available, Save the floating-point or MMX state if the task switch bit (TS) of the control register (CR0) is set to 1.
\par #Stack Exception, During instruction execution, the stack segment limit was exceeded.
\par #General Protection, During instruction execution, the effective address of one of the segment registers used for the operand points to an illegal memory location.
\par #Page fault, A page fault resulted from the execution of the instruction.
\par #Float point exception pending, An exception is pending due to the floating-point execution unit.
\par #Alignment check, An unaligned memory reference resulted from the instruction execution, and the alignment mask bit (AM) of the control register (CR0) is set to 1. (In Protected Mode, CPL = 3.)
\par 
\par Real-Address Mode Exceptions
\par 
\par #Invalid Opcode, The emulate instruction bit (EM) of the control register (CR0) is set to 1.
\par #Device Not Available, Save the floating-point or MMX state if the task switch bit (TS) of the control register (CR0) is set to 1.
\par #Segment Overrun, One of the instruction data operands falls outside the address range 00000h to 0FFFFh.
\par #Float point exception pending, An exception is pending due to the floating-point execution unit.
\par 
\par Virtual-8086 Mode Exceptions
\par 
\par #Invalid Opcode, The emulate instruction bit (EM) of the control register (CR0) is set to 1.
\par #Device Not Available, Save the floating-point or MMX state if the task switch bit (TS) of the control register (CR0) is set to 1.
\par #Segment Overrun, One of the instruction data operands falls outside the address range 00000h to 0FFFFh.
\par #Page fault, A page fault resulted from the execution of the instruction.
\par #Float point exception pending, An exception is pending due to the floating-point execution unit.
\par #Alignment check, An unaligned memory reference resulted from the instruction execution, and the alignment mask bit (AM) of the control register (CR0) is set to 1. (In Protected Mode, CPL = 3.)
{\page}

${\footnote PMULHUW,Opcode}
K{\footnote PMULHUW,PMULHUW;PMULHUW,Opcode}
#{\footnote PMULHUW::5}

{\fs20\b PMULHUW}\tab{\b Opcode}\par\par
0F E4 /r PMULHUW mmreg1, mmreg2 or PMULHUW mmreg, mem64
{\page}

${\footnote PREFETCHNTA,Description}
K{\footnote PREFETCHNTA,PREFETCHNTA;PREFETCHT0,PREFETCHT0;PREFETCHT1,PREFETCHT1;PREFETCHT2,PREFETCHT2;PREFETCHNTA,Description;PREFETCHT0,Description;PREFETCHT1,Description;PREFETCHT2,Description}
#{\footnote PREFETCHNTA::1}
#{\footnote PREFETCHT0::1}
#{\footnote PREFETCHT1::1}
#{\footnote PREFETCHT2::1}

{\fs20\b PREFETCHNTA/PREFETCHT0/PREFETCHT1/PREFETCHT2}\tab{\b Description}\par\par
PREFETCHNTA: Move data closer to the processor using the NTA reference.
\par PREFETCHT0: Move data closer to the processor using the T0 reference.
\par PREFETCHT1: Move data closer to the processor using the T1 reference.
\par PREFETCHT2: Move data closer to the processor using the T2 reference.
\par 
\par The prefetch instruction brings a cache line into the processor cache level(s) specified by a locality reference. The address of the prefetched cache line is specified by the mem8 value. The prefetch instruction loads a cache line even if the mem8 address is not aligned with the start of the line. If a cache level, which is closer than the locality reference, already has the cache line, or a memory fault is detected, then no bus cycle is initiated and the instruction is treated as a NOP.
\par 
\par The operation of the prefetch instructions is processor implementation dependent. The instructions can be ignored or changed by a processor implementation, though they will not change program behavior. The cache line size is also implementation dependent having a minimum size of 32 bytes. Bits 5:3 of the ModR/M byte indicate the cache locality references.
{\page}

${\footnote PREFETCHNTA,Operation}
K{\footnote PREFETCHNTA,PREFETCHNTA;PREFETCHT0,PREFETCHT0;PREFETCHT1,PREFETCHT1;PREFETCHT2,PREFETCHT2;PREFETCHNTA,Operation;PREFETCHT0,Operation;PREFETCHT1,Operation;PREFETCHT2,Operation}
#{\footnote PREFETCHNTA::2}
#{\footnote PREFETCHT0::2}
#{\footnote PREFETCHT1::2}
#{\footnote PREFETCHT2::2}

{\fs20\b PREFETCHNTA/PREFETCHT0/PREFETCHT1/PREFETCHT2}\tab{\b Operation}\par\par
NTA Move specified data into processor and minimize cache pollution.
\par T0 Move specified data into all cache levels.
\par T1 Move specified data into all cache levels except 0th level cache.
\par T2 Move specified data into all cache levels except 0th and 1st level caches.
\par 
\par Note: A 0th level cache is implementation dependent.
{\page}

${\footnote PREFETCHNTA,Flags affected}
K{\footnote PREFETCHNTA,PREFETCHNTA;PREFETCHT0,PREFETCHT0;PREFETCHT1,PREFETCHT1;PREFETCHT2,PREFETCHT2;PREFETCHNTA,Flags affected;PREFETCHT0,Flags affected;PREFETCHT1,Flags affected;PREFETCHT2,Flags affected}
#{\footnote PREFETCHNTA::3}
#{\footnote PREFETCHT0::3}
#{\footnote PREFETCHT1::3}
#{\footnote PREFETCHT2::3}

{\fs20\b PREFETCHNTA/PREFETCHT0/PREFETCHT1/PREFETCHT2}\tab{\b Flags affected}\par\par
None.
{\page}

${\footnote PREFETCHNTA,Exceptions}
K{\footnote PREFETCHNTA,PREFETCHNTA;PREFETCHT0,PREFETCHT0;PREFETCHT1,PREFETCHT1;PREFETCHT2,PREFETCHT2;PREFETCHNTA,Exceptions;PREFETCHT0,Exceptions;PREFETCHT1,Exceptions;PREFETCHT2,Exceptions}
#{\footnote PREFETCHNTA::4}
#{\footnote PREFETCHT0::4}
#{\footnote PREFETCHT1::4}
#{\footnote PREFETCHT2::4}

{\fs20\b PREFETCHNTA/PREFETCHT0/PREFETCHT1/PREFETCHT2}\tab{\b Exceptions}\par\par
None.
{\page}

${\footnote PREFETCHNTA,Opcode}
K{\footnote PREFETCHNTA,PREFETCHNTA;PREFETCHT0,PREFETCHT0;PREFETCHT1,PREFETCHT1;PREFETCHT2,PREFETCHT2;PREFETCHNTA,Opcode;PREFETCHT0,Opcode;PREFETCHT1,Opcode;PREFETCHT2,Opcode}
#{\footnote PREFETCHNTA::5}
#{\footnote PREFETCHT0::5}
#{\footnote PREFETCHT1::5}
#{\footnote PREFETCHT2::5}

{\fs20\b PREFETCHNTA/PREFETCHT0/PREFETCHT1/PREFETCHT2}\tab{\b Opcode}\par\par
0F 18 /0 PREFETCHNTA mem8
\par 0F 18 /1 PREFETCHT0 mem8
\par 0F 18 /2 PREFETCHT1 mem8
\par 0F 18 /3 PREFETCHT2 mem8
{\page}

${\footnote PSADBW,Description}
K{\footnote PSADBW,PSADBW;PSADBW,Description}
#{\footnote PSADBW::1}

{\fs20\b PSADBW}\tab{\b Description}\par\par
PSADBW: Packed sum of absolute byte differences
\par 
\par The PSADBW instruction is the sum of the absolute value of the differences between each byte position of source 1 and source 2.
{\page}

${\footnote PSADBW,Operation}
K{\footnote PSADBW,PSADBW;PSADBW,Operation}
#{\footnote PSADBW::2}

{\fs20\b PSADBW}\tab{\b Operation}\par\par
PSADBW mmreg1, mmreg2 performs the following operations:
\par 
\par mmreg1[63:16] = 0
\par mmreg1[15:0] = abs(mmreg1[7:0] - mmreg2[7:0]) +
\par abs(mmreg1[15:8] - mmreg2[15:8]) +
\par abs(mmreg1[23:16] - mmreg2[23:16]) +
\par abs(mmreg1[31:24] - mmreg2[31:24]) +
\par abs(mmreg1[39:32] - mmreg2[39:32]) +
\par abs(mmreg1[47:40] - mmreg2[47:40]) +
\par abs(mmreg1[55:48] - mmreg2[55:48]) +
\par abs(mmreg1[63:56] - mmreg2[63:56])
\par 
\par PSADBW mmreg, mem64 performs the following operations:
\par 
\par mmreg[63:16] = 0
\par mmreg[15:0] = abs(mmreg[7:0] - mem64[7:0]) +
\par abs(mmreg[15:8] - mem64[15:8]) +
\par abs(mmreg[23:16] - mem64[23:16]) +
\par abs(mmreg[31:24] - mem64[31:24]) +
\par abs(mmreg[39:32] - mem64[39:32]) +
\par abs(mmreg[47:40] - mem64[47:40]) +
\par abs(mmreg[55:48] - mem64[55:48]) +
\par abs(mmreg[63:56] - mem64[63:56])
{\page}

${\footnote PSADBW,Flags affected}
K{\footnote PSADBW,PSADBW;PSADBW,Flags affected}
#{\footnote PSADBW::3}

{\fs20\b PSADBW}\tab{\b Flags affected}\par\par
None.
{\page}

${\footnote PSADBW,Exceptions}
K{\footnote PSADBW,PSADBW;PSADBW,Exceptions}
#{\footnote PSADBW::4}

{\fs20\b PSADBW}\tab{\b Exceptions}\par\par
Protected Mode Exceptions
\par 
\par #Invalid Opcode, The emulate instruction bit (EM) of the control register (CR0) is set to 1.
\par #Device Not Available, Save the floating-point or MMX state if the task switch bit (TS) of the control register (CR0) is set to 1.
\par #Stack Exception, During instruction execution, the stack segment limit was exceeded.
\par #General Protection, During instruction execution, the effective address of one of the segment registers used for the operand points to an illegal memory location.
\par #Page fault, A page fault resulted from the execution of the instruction.
\par #Float point exception pending, An exception is pending due to the floating-point execution unit.
\par #Alignment check, An unaligned memory reference resulted from the instruction execution, and the alignment mask bit (AM) of the control register (CR0) is set to 1. (In Protected Mode, CPL = 3.)
\par 
\par Real-Address Mode Exceptions
\par 
\par #Invalid Opcode, The emulate instruction bit (EM) of the control register (CR0) is set to 1.
\par #Device Not Available, Save the floating-point or MMX state if the task switch bit (TS) of the control register (CR0) is set to 1.
\par #Segment Overrun, One of the instruction data operands falls outside the address range 00000h to 0FFFFh.
\par #Float point exception pending, An exception is pending due to the floating-point execution unit.
\par 
\par Virtual-8086 Mode Exceptions
\par 
\par #Invalid Opcode, The emulate instruction bit (EM) of the control register (CR0) is set to 1.
\par #Device Not Available, Save the floating-point or MMX state if the task switch bit (TS) of the control register (CR0) is set to 1.
\par #Segment Overrun, One of the instruction data operands falls outside the address range 00000h to 0FFFFh.
\par #Page fault, A page fault resulted from the execution of the instruction.
\par #Float point exception pending, An exception is pending due to the floating-point execution unit.
\par #Alignment check, An unaligned memory reference resulted from the instruction execution, and the alignment mask bit (AM) of the control register (CR0) is set to 1. (In Protected Mode, CPL = 3.)
{\page}

${\footnote PSADBW,Opcode}
K{\footnote PSADBW,PSADBW;PSADBW,Opcode}
#{\footnote PSADBW::5}

{\fs20\b PSADBW}\tab{\b Opcode}\par\par
0F F6 /r PSADBW mmreg1, mmreg2 or PSADBW mmreg, mem64
{\page}

${\footnote PSHUFW,Description}
K{\footnote PSHUFW,PSHUFW;PSHUFW,Description}
#{\footnote PSHUFW::1}

{\fs20\b PSHUFW}\tab{\b Description}\par\par
PSHUFW: Packed shuffle word
\par 
\par The PSHUFW instruction rearranges the four words of an MMX register into one of 16 possible permutations as defined by an immediate byte.
{\page}

${\footnote PSHUFW,Operation}
K{\footnote PSHUFW,PSHUFW;PSHUFW,Operation}
#{\footnote PSHUFW::2}

{\fs20\b PSHUFW}\tab{\b Operation}\par\par
PSHUFW mmreg1, mmreg2, imm8 performs the following operations:
\par 
\par index3 = imm8[7:6] * 16
\par index2 = imm8[5:4] * 16
\par index1 = imm8[3:2] * 16
\par index0 = imm8[1:0] * 16
\par mmreg1[63:48] = mmreg2[index3+15:index3]
\par mmreg1[47:32] = mmreg2[index2+15:index2]
\par mmreg1[31:16] = mmreg2[index1+15:index1]
\par mmreg1[15:0] = mmreg2[index0+15:index0]
\par 
\par PSHUFW mmreg, mem64, imm8 performs the following operations:
\par 
\par index3 = imm8[7:6] * 16
\par index2 = imm8[5:4] * 16
\par index1 = imm8[3:2] * 16
\par index0 = imm8[1:0] * 16
\par mmreg[63:48] = mem64[index3+15:index3]
\par mmreg[47:32] = mem64[index2+15:index2]
\par mmreg[31:16] = mem64[index1+15:index1]
\par mmreg[15:0] = mem64[index0+15:index0]
{\page}

${\footnote PSHUFW,Flags affected}
K{\footnote PSHUFW,PSHUFW;PSHUFW,Flags affected}
#{\footnote PSHUFW::3}

{\fs20\b PSHUFW}\tab{\b Flags affected}\par\par
None.
{\page}

${\footnote PSHUFW,Exceptions}
K{\footnote PSHUFW,PSHUFW;PSHUFW,Exceptions}
#{\footnote PSHUFW::4}

{\fs20\b PSHUFW}\tab{\b Exceptions}\par\par
Protected Mode Exceptions
\par 
\par #Invalid Opcode, The emulate instruction bit (EM) of the control register (CR0) is set to 1.
\par #Device Not Available, Save the floating-point or MMX state if the task switch bit (TS) of the control register (CR0) is set to 1.
\par #Stack Exception, During instruction execution, the stack segment limit was exceeded.
\par #General Protection, During instruction execution, the effective address of one of the segment registers used for the operand points to an illegal memory location.
\par #Page fault, A page fault resulted from the execution of the instruction.
\par #Float point exception pending, An exception is pending due to the floating-point execution unit.
\par #Alignment check, An unaligned memory reference resulted from the instruction execution, and the alignment mask bit (AM) of the control register (CR0) is set to 1. (In Protected Mode, CPL = 3.)
\par 
\par Real-Address Mode Exceptions
\par 
\par #Invalid Opcode, The emulate instruction bit (EM) of the control register (CR0) is set to 1.
\par #Device Not Available, Save the floating-point or MMX state if the task switch bit (TS) of the control register (CR0) is set to 1.
\par #Segment Overrun, One of the instruction data operands falls outside the address range 00000h to 0FFFFh.
\par #Float point exception pending, An exception is pending due to the floating-point execution unit.
\par 
\par Virtual-8086 Mode Exceptions
\par 
\par #Invalid Opcode, The emulate instruction bit (EM) of the control register (CR0) is set to 1.
\par #Device Not Available, Save the floating-point or MMX state if the task switch bit (TS) of the control register (CR0) is set to 1.
\par #Segment Overrun, One of the instruction data operands falls outside the address range 00000h to 0FFFFh.
\par #Page fault, A page fault resulted from the execution of the instruction.
\par #Float point exception pending, An exception is pending due to the floating-point execution unit.
\par #Alignment check, An unaligned memory reference resulted from the instruction execution, and the alignment mask bit (AM) of the control register (CR0) is set to 1. (In Protected Mode, CPL = 3.)
{\page}

${\footnote PSHUFW,Opcode}
K{\footnote PSHUFW,PSHUFW;PSHUFW,Opcode}
#{\footnote PSHUFW::5}

{\fs20\b PSHUFW}\tab{\b Opcode}\par\par
0F 70 /r PSHUFW mmreg1, mmreg2, imm8 or PSHUFW mmreg, mem64, imm8
{\page}

${\footnote SFENCE,Description}
K{\footnote SFENCE,SFENCE;SFENCE,Description}
#{\footnote SFENCE::1}

{\fs20\b SFENCE}\tab{\b Description}\par\par
SFENCE: Store fence
\par 
\par The SFENCE instructions makes all previous writes globally visible before any later writes.
{\page}

${\footnote SFENCE,Operation}
K{\footnote SFENCE,SFENCE;SFENCE,Operation}
#{\footnote SFENCE::2}

{\fs20\b SFENCE}\tab{\b Operation}\par\par
See Description.
{\page}

${\footnote SFENCE,Flags affected}
K{\footnote SFENCE,SFENCE;SFENCE,Flags affected}
#{\footnote SFENCE::3}

{\fs20\b SFENCE}\tab{\b Flags affected}\par\par
None.
{\page}

${\footnote SFENCE,Exceptions}
K{\footnote SFENCE,SFENCE;SFENCE,Exceptions}
#{\footnote SFENCE::4}

{\fs20\b SFENCE}\tab{\b Exceptions}\par\par
None.
{\page}

${\footnote SFENCE,Opcode}
K{\footnote SFENCE,SFENCE;SFENCE,Opcode}
#{\footnote SFENCE::5}

{\fs20\b SFENCE}\tab{\b Opcode}\par\par
0F AE /7 SFENCE
{\page}

${\footnote BOUND,Description}
K{\footnote BOUND,BOUND;BOUND,Description}
#{\footnote BOUND::1}

{\fs20\b BOUND}\tab{\b Description}\par\par
BOUND: Check Array Index Against Bounds
\par 
\par Determines if the first operand (array index) is within the bounds of an array specified the second operand (bounds operand). The array index is a signed integer located in a register. The bounds operand is a memory location that contains a pair of signed doubleword-integers (when the operand-size attribute is 32) or a pair of signed word-integers (when the operand-size attribute is 16). The first doubleword (or word) is the lower bound of the array and the second doubleword (or word) is the upper bound of the array. The array index must be greater than or equal to the lower bound and less than or equal to the upper bound plus the operand size in bytes. If the index is not within bounds, a BOUND range exceeded exception (#BR) is signaled. (When a this exception is generated, the saved return instruction pointer points to the BOUND instruction.)
\par The bounds limit data structure (two words or doublewords containing the lower and upper limits of the array) is usually placed just before the array itself, making the limits addressable via a constant offset from the beginning of the array. Because the address of the array already will be present in a register, this practice avoids extra bus cycles to obtain the effective address of the array bounds.
{\page}

${\footnote BOUND,Operation}
K{\footnote BOUND,BOUND;BOUND,Operation}
#{\footnote BOUND::2}

{\fs20\b BOUND}\tab{\b Operation}\par\par
IF (ArrayIndex < LowerBound OR ArrayIndex > (UppderBound + OperandSize/8]))
\par (* Below lower bound or above upper bound *)
\par THEN
\par #BR;
\par FI;
{\page}

${\footnote BOUND,Flags affected}
K{\footnote BOUND,BOUND;BOUND,Flags affected}
#{\footnote BOUND::3}

{\fs20\b BOUND}\tab{\b Flags affected}\par\par
None.
{\page}

${\footnote BOUND,Exceptions}
K{\footnote BOUND,BOUND;BOUND,Exceptions}
#{\footnote BOUND::4}

{\fs20\b BOUND}\tab{\b Exceptions}\par\par
Protected Mode Exceptions
\par 
\par #BR If the bounds test fails.
\par #UD If second operand is not a memory location.
\par #GP(0) If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit. If the DS, ES, FS, or GS register contains a null segment selector.
\par #SS(0) If a memory operand effective address is outside the SS segment limit.
\par #PF(fault-code) If a page fault occurs.
\par #AC(0) If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.
\par 
\par Real-Address Mode Exceptions
\par 
\par #BR If the bounds test fails.
\par #UD If second operand is not a memory location.
\par #GP If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.
\par #SS If a memory operand effective address is outside the SS segment limit.
\par 
\par Virtual-8086 Mode Exceptions
\par 
\par #BR If the bounds test fails.
\par #UD If second operand is not a memory location.
\par #GP(0) If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.
\par #SS(0) If a memory operand effective address is outside the SS segment limit.
\par #PF(fault-code) If a page fault occurs.
\par #AC(0) If alignment checking is enabled and an unaligned memory reference is made.
{\page}

${\footnote BOUND,Opcode}
K{\footnote BOUND,BOUND;BOUND,Opcode}
#{\footnote BOUND::5}

{\fs20\b BOUND}\tab{\b Opcode}\par\par
62 / r BOUND r16,m16&16 Check if r16 (array index) is within bounds specified by m16&16
\par 62 / r BOUND r32,m32&32 Check if r32 (array index) is within bounds specified by m16&16
{\page}

${\footnote BSF,Description}
K{\footnote BSF,BSF;BSF,Description}
#{\footnote BSF::1}

{\fs20\b BSF}\tab{\b Description}\par\par
BSF: Bit Scan Forward
\par 
\par Searches the source operand (second operand) for the least significant set bit (1 bit). If a least significant 1 bit is found, its bit index is stored in the destination operand (first operand). The source operand can be a register or a memory location; the destination operand is a register. The bit index is an unsigned offset from bit 0 of the source operand. If the contents source operand are 0, the contents of the destination operand is undefined.
{\page}

${\footnote BSF,Operation}
K{\footnote BSF,BSF;BSF,Operation}
#{\footnote BSF::2}

{\fs20\b BSF}\tab{\b Operation}\par\par
IF SRC = 0
\par THEN
\par ZF <- 1;
\par DEST is undefined;
\par ELSE
\par ZF <- 0;
\par temp <- 0;
\par WHILE Bit(SRC, temp) = 0
\par DO
\par temp <- temp + 1;
\par DEST <- temp;
\par OD;
\par FI;
{\page}

${\footnote BSF,Flags affected}
K{\footnote BSF,BSF;BSF,Flags affected}
#{\footnote BSF::3}

{\fs20\b BSF}\tab{\b Flags affected}\par\par
The ZF flag is set to 1 if all the source operand is 0; otherwise, the ZF flag is cleared. The CF, OF, SF, AF, and PF, flags are undefined.
{\page}

${\footnote BSF,Exceptions}
K{\footnote BSF,BSF;BSF,Exceptions}
#{\footnote BSF::4}

{\fs20\b BSF}\tab{\b Exceptions}\par\par
Protected Mode Exceptions
\par 
\par #GP(0) If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit. If the DS, ES, FS, or GS register contains a null segment selector.
\par #SS(0) If a memory operand effective address is outside the SS segment limit.
\par #PF(fault-code) If a page fault occurs.
\par #AC(0) If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.
\par 
\par Real-Address Mode Exceptions
\par 
\par #GP If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.
\par #SS If a memory operand effective address is outside the SS segment limit.
\par 
\par Virtual-8086 Mode Exceptions
\par 
\par #GP(0) If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.
\par #SS(0) If a memory operand effective address is outside the SS segment limit.
\par #PF(fault-code) If a page fault occurs.
\par #AC(0) If alignment checking is enabled and an unaligned memory reference is made.
{\page}

${\footnote BSF,Opcode}
K{\footnote BSF,BSF;BSF,Opcode}
#{\footnote BSF::5}

{\fs20\b BSF}\tab{\b Opcode}\par\par
0F BC BSF r16,r/m16 Bit scan forward on r/m16
\par 0F BC BSF r32,r/m32 Bit scan forward on r/m32
{\page}

${\footnote BSR,Description}
K{\footnote BSR,BSR;BSR,Description}
#{\footnote BSR::1}

{\fs20\b BSR}\tab{\b Description}\par\par
BSR: Bit Scan Reverse
\par 
\par Searches the source operand (second operand) for the most significant set bit (1 bit). If a most significant 1 bit is found, its bit index is stored in the destination operand (first operand). The source operand can be a register or a memory location; the destination operand is a register. The bit index is an unsigned offset from bit 0 of the source operand. If the contents source operand are 0, the contents of the destination operand is undefined.
{\page}

${\footnote BSR,Operation}
K{\footnote BSR,BSR;BSR,Operation}
#{\footnote BSR::2}

{\fs20\b BSR}\tab{\b Operation}\par\par
IF SRC = 0
\par THEN
\par ZF <- 1;
\par DEST is undefined;
\par ELSE
\par ZF <- 0;
\par temp <- OperandSize ' 1;
\par WHILE Bit(SRC, temp) = 0
\par DO
\par temp <- temp - 1;
\par DEST <- temp;
\par OD;
\par FI;
{\page}

${\footnote BSR,Flags affected}
K{\footnote BSR,BSR;BSR,Flags affected}
#{\footnote BSR::3}

{\fs20\b BSR}\tab{\b Flags affected}\par\par
The ZF flag is set to 1 if all the source operand is 0; otherwise, the ZF flag is cleared. The CF, OF, SF, AF, and PF, flags are undefined.
{\page}

${\footnote BSR,Exceptions}
K{\footnote BSR,BSR;BSR,Exceptions}
#{\footnote BSR::4}

{\fs20\b BSR}\tab{\b Exceptions}\par\par
Protected Mode Exceptions
\par 
\par #GP(0) If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit. If the DS, ES, FS, or GS register contains a null segment selector.
\par #SS(0) If a memory operand effective address is outside the SS segment limit.
\par #PF(fault-code) If a page fault occurs.
\par #AC(0) If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.
\par 
\par Real-Address Mode Exceptions
\par #GP If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.
\par #SS If a memory operand effective address is outside the SS segment limit.
\par 
\par Virtual-8086 Mode Exceptions
\par 
\par #GP(0) If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.
\par #SS(0) If a memory operand effective address is outside the SS segment limit.
\par #PF(fault-code) If a page fault occurs.
\par #AC(0) If alignment checking is enabled and an unaligned memory reference is made.
{\page}

${\footnote BSR,Opcode}
K{\footnote BSR,BSR;BSR,Opcode}
#{\footnote BSR::5}

{\fs20\b BSR}\tab{\b Opcode}\par\par
0F BD BSR r16,r/m16 Bit scan reverse on r/m16
\par 0F BD BSR r32,r/m32 Bit scan reverse on r/m32
{\page}

${\footnote BSWAP,Description}
K{\footnote BSWAP,BSWAP;BSWAP,Description}
#{\footnote BSWAP::1}

{\fs20\b BSWAP}\tab{\b Description}\par\par
BSWAP: Byte Swap
\par 
\par Reverses the byte order of a 32-bit (destination) register: bits 0 through 7 are swapped with bits 24 through 31, and bits 8 through 15 are swapped with bits 16 through 23. This instruction is provided for converting little-endian values to big-endian format and vice versa.
\par To swap bytes in a word value (16-bit register), use the XCHG instruction. When the BSWAP instruction references a 16-bit register, the result is undefined.
\par 
\par Intel Architecture Compatibility
\par 
\par The BSWAP instruction is not supported on Intel Architecture processors earlier than the Intel486 processor family. For compatibility with this instruction, include functionally equivalent code for execution on Intel processors earlier than the Intel486 processor family.
{\page}

${\footnote BSWAP,Operation}
K{\footnote BSWAP,BSWAP;BSWAP,Operation}
#{\footnote BSWAP::2}

{\fs20\b BSWAP}\tab{\b Operation}\par\par
TEMP <- DEST
\par DEST(7..0) <- TEMP(31..24)
\par DEST(15..8) <- TEMP(23..16)
\par DEST(23..16) <- TEMP(15..8)
\par DEST(31..24) <- TEMP(7..0)
{\page}

${\footnote BSWAP,Flags affected}
K{\footnote BSWAP,BSWAP;BSWAP,Flags affected}
#{\footnote BSWAP::3}

{\fs20\b BSWAP}\tab{\b Flags affected}\par\par
None.
{\page}

${\footnote BSWAP,Exceptions}
K{\footnote BSWAP,BSWAP;BSWAP,Exceptions}
#{\footnote BSWAP::4}

{\fs20\b BSWAP}\tab{\b Exceptions}\par\par
(All Operating Modes)
\par None.
{\page}

${\footnote BSWAP,Opcode}
K{\footnote BSWAP,BSWAP;BSWAP,Opcode}
#{\footnote BSWAP::5}

{\fs20\b BSWAP}\tab{\b Opcode}\par\par
0F C8+ rd BSWAP r32 Reverses the byte order of a 32-bit register.
{\page}

${\footnote BT,Description}
K{\footnote BT,BT;BT,Description}
#{\footnote BT::1}

{\fs20\b BT}\tab{\b Description}\par\par
BT: Bit Test
\par 
\par Selects the bit in a bit string (specified with the first operand, called the bit base) at the bit-position designated by the bit offset operand (second operand) and stores the value of the bit in the CF flag. The bit base operand can be a register or a memory location; the bit offset operand can be a register or an immediate value. If the bit base operand specifies a register, the instruction takes the modulo 16 or 32 (depending on the register size) of the bit offset operand, allowing any bit position to be selected in a 16- or 32-bit register, respectively. If the bit base operand specifies a memory location, it represents the address of the byte in memory that contains the bit base (bit 0 of the specified byte) of the bit string. The offset operand then selects a bit position within the range -2 31 to 2 31 - 1 for a register offset and 0 to 31 for an immediate offset.
\par Some assemblers support immediate bit offsets larger than 31 by using the immediate bit offset field in combination with the displacement field of the memory operand. In this case, the low-order 3 or 5 bits (3 for 16-bit operands, 5 for 32-bit operands) of the immediate bit offset are stored in the immediate bit offset field, and the high-order bits are shifted and combined with the byte displacement in the addressing mode by the assembler. The processor will ignore the high order bits if they are not zero.
\par When accessing a bit in memory, the processor may access 4 bytes starting from the memory address for a 32-bit operand size, using by the following relationship:
\par 
\par Effective Address + (4 * (BitOffset DIV 32))
\par 
\par Or, it may access 2 bytes starting from the memory address for a 16-bit operand, using this rela-tionship:
\par 
\par Effective Address + (2 * (BitOffset DIV 16))
\par 
\par It may do so even when only a single byte needs to be accessed to reach the given bit. When using this bit addressing mechanism, software should avoid referencing areas of memory close to address space holes. In particular, it should avoid references to memory-mapped I/O registers. Instead, software should use the MOV instructions to load from or store to these addresses, and use the register form of these instructions to manipulate the data.
{\page}

${\footnote BT,Operation}
K{\footnote BT,BT;BT,Operation}
#{\footnote BT::2}

{\fs20\b BT}\tab{\b Operation}\par\par
CF <- Bit(BitBase, BitOffset)
{\page}

${\footnote BT,Flags affected}
K{\footnote BT,BT;BT,Flags affected}
#{\footnote BT::3}

{\fs20\b BT}\tab{\b Flags affected}\par\par
The CF flag contains the value of the selected bit. The OF, SF, ZF, AF, and PF flags are undefined.
{\page}

${\footnote BT,Exceptions}
K{\footnote BT,BT;BT,Exceptions}
#{\footnote BT::4}

{\fs20\b BT}\tab{\b Exceptions}\par\par
Protected Mode Exceptions
\par 
\par #GP(0) If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit. If the DS, ES, FS, or GS register contains a null segment selector.
\par #SS(0) If a memory operand effective address is outside the SS segment limit.
\par #PF(fault-code) If a page fault occurs.
\par #AC(0) If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.
\par 
\par Real-Address Mode Exceptions
\par 
\par #GP If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.
\par #SS If a memory operand effective address is outside the SS segment limit.
\par 
\par Virtual-8086 Mode Exceptions
\par 
\par #GP(0) If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.
\par #SS(0) If a memory operand effective address is outside the SS segment limit.
\par #PF(fault-code) If a page fault occurs.
\par #AC(0) If alignment checking is enabled and an unaligned memory reference is made.
{\page}

${\footnote BT,Opcode}
K{\footnote BT,BT;BT,Opcode}
#{\footnote BT::5}

{\fs20\b BT}\tab{\b Opcode}\par\par
0F A3 BT r/m16,r16 Store selected bit in CF flag
\par 0F A3 BT r/m32,r32 Store selected bit in CF flag
\par 0F BA /4 ib BT r/m16,imm8 Store selected bit in CF flag
\par 0F BA /4 ib BT r/m32,imm8 Store selected bit in CF flag
{\page}

${\footnote BTC,Description}
K{\footnote BTC,BTC;BTC,Description}
#{\footnote BTC::1}

{\fs20\b BTC}\tab{\b Description}\par\par
BTC: Bit Test and Complement
\par 
\par Selects the bit in a bit string (specified with the first operand, called the bit base) at the bit-position designated by the bit offset operand (second operand), stores the value of the bit in the CF flag, and complements the selected bit in the bit string. The bit base operand can be a register or a memory location; the bit offset operand can be a register or an immediate value. If the bit base operand specifies a register, the instruction takes the modulo 16 or 32 (depending on the register size) of the bit offset operand, allowing any bit position to be selected in a 16- or 32-bit register, respectively (see Figure 3-1). If the bit base operand specifies a memory location, it represents the address of the byte in memory that contains the bit base (bit 0 of the specified byte) of the bit string. The offset operand then selects a bit position within the range -2 31 to 2 31 - 1 for a register offset and 0 to 31 for an immediate offset.
\par Some assemblers support immediate bit offsets larger than 31 by using the immediate bit offset field in combination with the displacement field of the memory operand. See 'BT: Bit Test' for more information on this addressing mechanism.
{\page}

${\footnote BTC,Operation}
K{\footnote BTC,BTC;BTC,Operation}
#{\footnote BTC::2}

{\fs20\b BTC}\tab{\b Operation}\par\par
CF <- Bit(BitBase, BitOffset)
\par Bit(BitBase, BitOffset) <- NOT Bit(BitBase, BitOffset);
{\page}

${\footnote BTC,Flags affected}
K{\footnote BTC,BTC;BTC,Flags affected}
#{\footnote BTC::3}

{\fs20\b BTC}\tab{\b Flags affected}\par\par
The CF flag contains the value of the selected bit before it is complemented. The OF, SF, ZF, AF, and PF flags are undefined.
{\page}

${\footnote BTC,Exceptions}
K{\footnote BTC,BTC;BTC,Exceptions}
#{\footnote BTC::4}

{\fs20\b BTC}\tab{\b Exceptions}\par\par
Protected Mode Exceptions
\par 
\par #GP(0) If the destination operand points to a nonwritable segment. If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit. If the DS, ES, FS, or GS register contains a null segment selector.
\par #SS(0) If a memory operand effective address is outside the SS segment limit.
\par #PF(fault-code) If a page fault occurs.
\par #AC(0) If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.
\par 
\par Real-Address Mode Exceptions
\par 
\par #GP If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.
\par #SS If a memory operand effective address is outside the SS segment limit.
\par 
\par Virtual-8086 Mode Exceptions
\par 
\par #GP(0) If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.
\par #SS(0) If a memory operand effective address is outside the SS segment limit.
\par #PF(fault-code) If a page fault occurs.
\par #AC(0) If alignment checking is enabled and an unaligned memory reference is made.
{\page}

${\footnote BTC,Opcode}
K{\footnote BTC,BTC;BTC,Opcode}
#{\footnote BTC::5}

{\fs20\b BTC}\tab{\b Opcode}\par\par
0F BB BTC r/m16,r16 Store selected bit in CF flag and complement
\par 0F BB BTC r/m32,r32 Store selected bit in CF flag and complement
\par 0F BA /7 ib BTC r/m16,imm8 Store selected bit in CF flag and complement
\par 0F BA /7 ib BTC r/m32,imm8 Store selected bit in CF flag and complement
{\page}

${\footnote BTR,Description}
K{\footnote BTR,BTR;BTR,Description}
#{\footnote BTR::1}

{\fs20\b BTR}\tab{\b Description}\par\par
BTR: Bit Test and Reset
\par 
\par Selects the bit in a bit string (specified with the first operand, called the bit base) at the bit-position designated by the bit offset operand (second operand), stores the value of the bit in the CF flag, and clears the selected bit in the bit string to 0. The bit base operand can be a register or a memory location; the bit offset operand can be a register or an immediate value. If the bit base operand specifies a register, the instruction takes the modulo 16 or 32 (depending on the register size) of the bit offset operand, allowing any bit position to be selected in a 16- or 32-bit register, respectively. If the bit base operand specifies a memory location, it represents the address of the byte in memory that contains the bit base (bit 0 of the specified byte) of the bit string (see Figure 3-2). The offset operand then selects a bit position within the range -2 31 to 2 31 - 1 for a register offset and 0 to 31 for an immediate offset.
\par Some assemblers support immediate bit offsets larger than 31 by using the immediate bit offset field in combination with the displacement field of the memory operand. See 'BT--Bit Test' for more information on this addressing mechanism.
{\page}

${\footnote BTR,Operation}
K{\footnote BTR,BTR;BTR,Operation}
#{\footnote BTR::2}

{\fs20\b BTR}\tab{\b Operation}\par\par
CF <- Bit(BitBase, BitOffset)
\par Bit(BitBase, BitOffset) <- 0;
{\page}

${\footnote BTR,Flags affected}
K{\footnote BTR,BTR;BTR,Flags affected}
#{\footnote BTR::3}

{\fs20\b BTR}\tab{\b Flags affected}\par\par
The CF flag contains the value of the selected bit before it is cleared. The OF, SF, ZF, AF, and PF flags are undefined.
{\page}

${\footnote BTR,Exceptions}
K{\footnote BTR,BTR;BTR,Exceptions}
#{\footnote BTR::4}

{\fs20\b BTR}\tab{\b Exceptions}\par\par
Protected Mode Exceptions
\par 
\par #GP(0) If the destination operand points to a nonwritable segment. If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit. If the DS, ES, FS, or GS register contains a null segment selector.
\par #SS(0) If a memory operand effective address is outside the SS segment limit.
\par #PF(fault-code) If a page fault occurs.
\par #AC(0) If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.
\par 
\par Real-Address Mode Exceptions
\par 
\par #GP If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.
\par #SS If a memory operand effective address is outside the SS segment limit.
\par 
\par Virtual-8086 Mode Exceptions
\par 
\par #GP(0) If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.
\par #SS(0) If a memory operand effective address is outside the SS segment limit.
\par #PF(fault-code) If a page fault occurs.
\par #AC(0) If alignment checking is enabled and an unaligned memory reference is made.
{\page}

${\footnote BTR,Opcode}
K{\footnote BTR,BTR;BTR,Opcode}
#{\footnote BTR::5}

{\fs20\b BTR}\tab{\b Opcode}\par\par
0F B3 BTR r/m16,r16 Store selected bit in CF flag and clear
\par 0F B3 BTR r/m32,r32 Store selected bit in CF flag and clear
\par 0F BA /6 ib BTR r/m16,imm8 Store selected bit in CF flag and clear
\par 0F BA /6 ib BTR r/m32,imm8 Store selected bit in CF flag and clear
{\page}

${\footnote BTS,Description}
K{\footnote BTS,BTS;BTS,Description}
#{\footnote BTS::1}

{\fs20\b BTS}\tab{\b Description}\par\par
BTS: Bit Test and Set
\par 
\par Selects the bit in a bit string (specified with the first operand, called the bit base) at the bit-position designated by the bit offset operand (second operand), stores the value of the bit in the CF flag, and sets the selected bit in the bit string to 1. The bit base operand can be a register or a memory location; the bit offset operand can be a register or an immediate value. If the bit base operand specifies a register, the instruction takes the modulo 16 or 32 (depending on the register size) of the bit offset operand, allowing any bit position to be selected in a 16- or 32-bit register, respectively. If the bit base operand specifies a memory location, it represents the address of the byte in memory that contains the bit base (bit 0 of the specified byte) of the bit string. The offset operand then selects a bit position within the range -2 31 to 2 31 - 1 for a register offset and 0 to 31 for an immediate offset.
\par Some assemblers support immediate bit offsets larger than 31 by using the immediate bit offset field in combination with the displacement field of the memory operand. See 'BT--Bit Test' for more information on this addressing mechanism.
{\page}

${\footnote BTS,Operation}
K{\footnote BTS,BTS;BTS,Operation}
#{\footnote BTS::2}

{\fs20\b BTS}\tab{\b Operation}\par\par
CF <- Bit(BitBase, BitOffset)
\par Bit(BitBase, BitOffset) <- 1;
{\page}

${\footnote BTS,Flags affected}
K{\footnote BTS,BTS;BTS,Flags affected}
#{\footnote BTS::3}

{\fs20\b BTS}\tab{\b Flags affected}\par\par
The CF flag contains the value of the selected bit before it is set. The OF, SF, ZF, AF, and PF  flags are undefined.
{\page}

${\footnote BTS,Exceptions}
K{\footnote BTS,BTS;BTS,Exceptions}
#{\footnote BTS::4}

{\fs20\b BTS}\tab{\b Exceptions}\par\par
Protected Mode Exceptions
\par 
\par #GP(0) If the destination operand points to a nonwritable segment. If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit. If the DS, ES, FS, or GS register contains a null segment selector.
\par #SS(0) If a memory operand effective address is outside the SS segment limit.
\par #PF(fault-code) If a page fault occurs.
\par #AC(0) If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.
\par 
\par Real-Address Mode Exceptions
\par 
\par #GP If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.
\par #SS If a memory operand effective address is outside the SS segment limit.
\par 
\par Virtual-8086 Mode Exceptions
\par 
\par #GP If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.
\par #SS If a memory operand effective address is outside the SS segment limit.
\par #PF(fault-code) If a page fault occurs.
\par #AC(0) If alignment checking is enabled and an unaligned memory reference is made.
{\page}

${\footnote BTS,Opcode}
K{\footnote BTS,BTS;BTS,Opcode}
#{\footnote BTS::5}

{\fs20\b BTS}\tab{\b Opcode}\par\par
0F AB BTS r/m16,r16 Store selected bit in CF flag and set
\par 0F AB BTS r/m32,r32 Store selected bit in CF flag and set
\par 0F BA /5 ib BTS r/m16,imm8 Store selected bit in CF flag and set
\par 0F BA /5 ib BTS r/m32,imm8 Store selected bit in CF flag and set
{\page}

${\footnote CALL,Description}
K{\footnote CALL,CALL;CALL,Description}
#{\footnote CALL::1}

{\fs20\b CALL}\tab{\b Description}\par\par
CALL: Call Procedure
\par 
\par Saves procedure linking information on the stack and branches to the procedure (called proce-dure) specified with the destination (target) operand. The target operand specifies the address of the first instruction in the called procedure. This operand can be an immediate value, a general-purpose register, or a memory location.
\par This instruction can be used to execute four different types of calls:
\par 
\par - Near call--A call to a procedure within the current code segment (the segment currently pointed to by the CS register), sometimes referred to as an intrasegment call.
\par - Far call--A call to a procedure located in a different segment than the current code segment, sometimes referred to as an intersegment call.
\par - Inter-privilege-level far call--A far call to a procedure in a segment at a different privilege level than that of the currently executing program or procedure.
\par - Task switch--A call to a procedure located in a different task.
\par 
\par The latter two call types (inter-privilege-level call and task switch) can only be executed in protected mode.
\par 
\par Near Call.
\par 
\par When executing a near call, the processor pushes the value of the EIP register (which contains the offset of the instruction following the CALL instruction) onto the stack (for use later as a return-instruction pointer). The processor then branches to the address in the current code segment specified with the target operand. The target operand specifies either an absolute offset in the code segment (that is an offset from the base of the code segment) or a relative offset (a signed displacement relative to the current value of the instruction pointer in the EIP register, which points to the instruction following the CALL instruction). The CS register is not changed on near calls.
\par For a near call, an absolute offset is specified indirectly in a general-purpose register or a memory location (r/m16 or r/m32). The operand-size attribute determines the size of the target operand (16 or 32 bits). Absolute offsets are loaded directly into the EIP register. If the operand-size attribute is 16, the upper two bytes of the EIP register are cleared to 0s, resulting in a maximum instruction pointer size of 16 bits. (When accessing an absolute offset indirectly using the stack pointer [ESP] as a base register, the base value used is the value of the ESP before the instruction executes.)
\par A relative offset (rel16 or rel32) is generally specified as a label in assembly code, but at the machine code level, it is encoded as a signed, 16- or 32-bit immediate value. This value is added to the value in the EIP register. As with absolute offsets, the operand-size attribute determines the size of the target operand (16 or 32 bits).
\par 
\par Far Calls in Real-Address or Virtual-8086 Mode.
\par 
\par When executing a far call in real-address or virtual-8086 mode, the processor pushes the current value of both the CS and EIP registers onto the stack for use as a return-instruction pointer. The processor then performs a "far branch" to the code segment and offset specified with the target operand for the called proce-dure. Here the target operand specifies an absolute far address either directly with a pointer (ptr16:16 or ptr16:32) or indirectly with a memory location (m16:16 or m16:32). With the pointer method, the segment and offset of the called procedure is encoded in the instruction, using a 4-byte (16-bit operand size) or 6-byte (32-bit operand size) far address immediate. With the indirect method, the target operand specifies a memory location that contains a 4-byte (16-bit operand size) or 6-byte (32-bit operand size) far address.
\par The operand-size attribute determines the size of the offset (16 or 32 bits) in the far address. The far address is loaded directly into the CS and EIP registers. If the operand-size attribute is 16, the upper two bytes of the EIP register are cleared to 0s.
\par 
\par Far Calls in Protected Mode.
\par 
\par When the processor is operating in protected mode, the CALL instruction can be used to perform the following three types of far calls:
\par - Far call to the same privilege level.
\par - Far call to a different privilege level (inter-privilege level call).
\par - Task switch (far call to another task).
\par In protected mode, the processor always uses the segment selector part of the far address to access the corresponding descriptor in the GDT or LDT. The descriptor type (code segment, call gate, task gate, or TSS) and access rights determine the type of call operation to be performed. If the selected descriptor is for a code segment, a far call to a code segment at the same privilege level is performed. (If the selected code segment is at a different privilege level and the code segment is non-conforming, a general-protection exception is generated.) A far call to the same privilege level in protected mode is very similar to one carried out in real-address or virtual-8086 mode. The target operand specifies an absolute far address either directly with a pointer (ptr16:16 or ptr16:32) or indirectly with a memory location (m16:16 or m16:32).
\par The operand-size attribute determines the size of the offset (16 or 32 bits) in the far address. The new code segment selector and its descriptor are loaded into CS register, and the offset from the instruction is loaded into the EIP register.
\par Note that a call gate (described in the next paragraph) can also be used to perform far call to a code segment at the same privilege level. Using this mechanism provides an extra level of indirection and is the preferred method of making calls between 16-bit and 32-bit code segments. When executing an inter-privilege-level far call, the code segment for the procedure being called must be accessed through a call gate. The segment selector specified by the target operand identifies the call gate. Here again, the target operand can specify the call gate segment selector either directly with a pointer (ptr16:16 or ptr16:32) or indirectly with a memory location (m16:16 or m16:32). The processor obtains the segment selector for the new code segment and the new instruction pointer (offset) from the call gate descriptor.
\par (The offset from the target operand is ignored when a call gate is used.) On inter-privilege-level calls, the processor switches to the stack for the privilege level of the called procedure. The segment selector for the new stack segment is specified in the TSS for the currently running task. The branch to the new code segment occurs after the stack switch. (Note that when using a call gate to perform a far call to a segment at the same privilege level, no stack switch occurs.) On the new stack, the processor pushes the segment selector and stack pointer for the calling procedure's stack, an (optional) set of parameters from the calling procedures stack, and the segment selector and instruction pointer for the calling procedure's code segment.
\par (A value in the call gate descriptor determines how many parameters to copy to the new stack.) Finally, the processor branches to the address of the procedure being called within the new code segment.
\par Executing a task switch with the CALL instruction, is somewhat similar to executing a call through a call gate. Here the target operand specifies the segment selector of the task gate for the task being switched to (and the offset in the target operand is ignored.) The task gate in turn points to the TSS for the task, which contains the segment selectors for the task's code and stack segments. The TSS also contains the EIP value for the next instruction that was to be executed before the task was suspended. This instruction pointer value is loaded into EIP register so that the task begins executing again at this next instruction. The CALL instruction can also specify the segment selector of the TSS directly, which eliminates the indirection of the task gate.
\par Note that when you execute at task switch with a CALL instruction, the nested task flag (NT) is set in the EFLAGS register and the new TSS's previous task link field is loaded with the old tasks TSS selector. Code is expected to suspend this nested task by executing an IRET instruction, which, because the NT flag is set, will automatically use the previous task link to return to the calling task. Switching tasks with the CALL instruction differs in this regard from the JMP instruction which does not set the NT flag and therefore does not expect an IRET instruction to suspend the task.
\par 
\par Mixing 16-Bit and 32-Bit Calls.
\par 
\par When making far calls between 16-bit and 32-bit code segments, the calls should be made through a call gate. If the far call is from a 32-bit code segment to a 16-bit code segment, the call should be made from the first 64 KBytes of the 32-bit code segment. This is because the operand-size attribute of the instruction is set to 16, so only a 16-bit return address offset is saved.
\par Also, the call should be made using a 16-bit call gate so that 16-bit values will be pushed on the stack.
{\page}

${\footnote CALL,Operation}
K{\footnote CALL,CALL;CALL,Operation}
#{\footnote CALL::2}

{\fs20\b CALL}\tab{\b Operation}\par\par
IF near call
\par THEN IF near relative call
\par IF the instruction pointer is not within code segment limit THEN #GP(0); FI;
\par THEN IF OperandSize = 32
\par THEN
\par IF stack not large enough for a 4-byte return address THEN #SS(0); FI;
\par Push(EIP);
\par EIP <- EIP + DEST; (* DEST is rel32 *)
\par ELSE (* OperandSize = 16 *)
\par IF stack not large enough for a 2-byte return address THEN #SS(0); FI;
\par Push(IP);
\par EIP <- (EIP + DEST) AND 0000FFFFH; (* DEST is rel16 *)
\par FI;
\par FI;
\par ELSE (* near absolute call *)
\par IF the instruction pointer is not within code segment limit THEN #GP(0); FI;
\par IF OperandSize = 32
\par THEN
\par IF stack not large enough for a 4-byte return address THEN #SS(0); FI;
\par Push(EIP);
\par EIP <- DEST; (* DEST is r/m32 *)
\par ELSE (* OperandSize = 16 *)
\par IF stack not large enough for a 2-byte return address THEN #SS(0); FI;
\par Push(IP);
\par EIP <- DEST AND 0000FFFFH; (* DEST is r/m16 *)
\par FI;
\par FI:
\par FI;
\par IF far call AND (PE = 0 OR (PE = 1 AND VM = 1)) (* real-address or virtual-8086 mode *)
\par THEN
\par IF OperandSize = 32
\par THEN
\par IF stack not large enough for a 6-byte return address THEN #SS(0); FI;
\par IF the instruction pointer is not within code segment limit THEN #GP(0); FI;
\par Push(CS); (* padded with 16 high-order bits *)
\par Push(EIP);
\par CS <- DEST[47:32]; (* DEST is ptr16:32 or [ m16:32] *)
\par EIP <- DEST[31:0]; (* DEST is ptr16:32 or [ m16:32] *)
\par ELSE (* OperandSize = 16 *)
\par IF stack not large enough for a 4-byte return address THEN #SS(0); FI;
\par IF the instruction pointer is not within code segment limit THEN #GP(0); FI;
\par Push(CS);
\par Push(IP);
\par CS <- DEST[31:16]; (* DEST is ptr16:16 or [ m16:16] *)
\par EIP <- DEST[15:0]; (* DEST is ptr16:16 or [ m16:16] *)
\par EIP <- EIP AND 0000FFFFH; (* clear upper 16 bits *)
\par FI;
\par FI;
\par IF far call AND (PE = 1 AND VM = 0) (* Protected mode, not virtual-8086 mode *)
\par THEN
\par IF segment selector in target operand null THEN #GP(0); FI;
\par IF segment selector index not within descriptor table limits
\par THEN #GP(new code segment selector);
\par FI;
\par Read type and access rights of selected segment descriptor;
\par IF segment type is not a conforming or nonconforming code segment, call gate, task gate, or TSS THEN #GP(segment selector); FI;
\par Depending on type and access rights
\par GO TO CONFORMING-CODE-SEGMENT;
\par GO TO NONCONFORMING-CODE-SEGMENT;
\par GO TO CALL-GATE;
\par GO TO TASK-GATE;
\par GO TO TASK-STATE-SEGMENT;
\par FI;
\par 
\par CONFORMING-CODE-SEGMENT:
\par IF DPL > CPL THEN #GP(new code segment selector); FI;
\par IF segment not present THEN #NP(new code segment selector); FI;
\par IF OperandSize = 32
\par THEN
\par IF stack not large enough for a 6-byte return address THEN #SS(0); FI;
\par IF the instruction pointer is not within code segment limit THEN #GP(0); FI;
\par Push(CS); (* padded with 16 high-order bits *)
\par Push(EIP);
\par CS <- DEST(NewCodeSegmentSelector);
\par (* segment descriptor information also loaded *)
\par CS(RPL) <- CPL
\par EIP <- DEST(offset);
\par 
\par IF stack not large enough for a 4-byte return address THEN #SS(0); FI;
\par IF the instruction pointer is not within code segment limit THEN #GP(0); FI;
\par Push(CS);
\par Push(IP);
\par CS <- DEST(NewCodeSegmentSelector);
\par (* segment descriptor information also loaded *)
\par CS(RPL) <- CPL
\par EIP <- DEST(offset) AND 0000FFFFH; (* clear upper 16 bits *)
\par FI;
\par END;
\par 
\par NONCONFORMING-CODE-SEGMENT:
\par IF (RPL > CPL) OR (DPL != CPL) THEN #GP(new code segment selector); FI;
\par IF segment not present THEN #NP(new code segment selector); FI;
\par IF stack not large enough for return address THEN #SS(0); FI;
\par tempEIP <- DEST(offset)
\par IF OperandSize=16
\par THEN
\par tempEIP <- tempEIP AND 0000FFFFH; (* clear upper 16 bits *)
\par FI;
\par IF tempEIP outside code segment limit THEN #GP(0); FI;
\par IF OperandSize = 32
\par THEN
\par Push(CS); (* padded with 16 high-order bits *)
\par Push(EIP);
\par CS <- DEST(NewCodeSegmentSelector);
\par (* segment descriptor information also loaded *)
\par CS(RPL) <- CPL;
\par EIP <- tempEIP;
\par ELSE (* OperandSize = 16 *)
\par Push(CS);
\par Push(IP);
\par CS <- DEST(NewCodeSegmentSelector);
\par (* segment descriptor information also loaded *)
\par CS(RPL) <- CPL;
\par EIP <- tempEIP;
\par FI;
\par END;
\par 
\par CALL-GATE:
\par IF call gate DPL < CPL or RPL THEN #GP(call gate selector); FI;
\par IF call gate not present THEN #NP(call gate selector); FI;
\par IF call gate code-segment selector is null THEN #GP(0); FI;
\par IF call gate code-segment selector index is outside descriptor table limits
\par THEN #GP(code segment selector); FI;
\par Read code segment descriptor;
\par IF code-segment segment descriptor does not indicate a code segment
\par OR code-segment segment descriptor DPL > CPL
\par THEN #GP(code segment selector); FI;
\par IF code segment not present THEN #NP(new code segment selector); FI;
\par IF code segment is non-conforming AND DPL < CPL
\par THEN go to MORE-PRIVILEGE;
\par ELSE go to SAME-PRIVILEGE;
\par FI;
\par END;
\par 
\par MORE-PRIVILEGE:
\par IF current TSS is 32-bit TSS
\par THEN
\par TSSstackAddress <- new code segment (DPL * 8) + 4
\par IF (TSSstackAddress + 7) > TSS limit
\par THEN #TS(current TSS selector); FI;
\par newSS <- TSSstackAddress + 4;
\par newESP <- stack address;
\par ELSE (* TSS is 16-bit *)
\par TSSstackAddress <- new code segment (DPL * 4) + 2
\par IF (TSSstackAddress + 4) > TSS limit
\par THEN #TS(current TSS selector); FI;
\par newESP <- TSSstackAddress;
\par newSS <- TSSstackAddress + 2;
\par FI;
\par IF stack segment selector is null THEN #TS(stack segment selector); FI;
\par IF stack segment selector index is not within its descriptor table limits
\par THEN #TS(SS selector); FI
\par Read code segment descriptor;
\par IF stack segment selector's RPL != DPL of code segment
\par OR stack segment DPL != DPL of code segment
\par OR stack segment is not a writable data segment
\par THEN #TS(SS selector); FI
\par IF stack segment not present THEN #SS(SS selector); FI;
\par IF CallGateSize = 32
\par THEN
\par IF stack does not have room for parameters plus 16 bytes
\par THEN #SS(SS selector); FI;
\par IF CallGate(InstructionPointer) not within code segment limit THEN #GP(0); FI;
\par SS <- newSS;
\par (* segment descriptor information also loaded *)
\par ESP <- newESP;
\par CS:EIP <- CallGate(CS:InstructionPointer);
\par (* segment descriptor information also loaded *)
\par Push(oldSS:oldESP); (* from calling procedure *)
\par temp <- parameter count from call gate, masked to 5 bits;
\par Push(parameters from calling procedure's stack, temp)
\par Push(oldCS:oldEIP); (* return address to calling procedure *)
\par ELSE (* CallGateSize = 16 *)
\par IF stack does not have room for parameters plus 8 bytes
\par THEN #SS(SS selector); FI;
\par IF (CallGate(InstructionPointer) AND FFFFH) not within code segment limit
\par THEN #GP(0); FI;
\par SS <- newSS;
\par (* segment descriptor information also loaded *)
\par ESP <- newESP;
\par CS:IP <- CallGate(CS:InstructionPointer);
\par (* segment descriptor information also loaded *)
\par Push(oldSS:oldESP); (* from calling procedure *)
\par temp <- parameter count from call gate, masked to 5 bits;
\par Push(parameters from calling procedure's stack, temp)
\par Push(oldCS:oldEIP); (* return address to calling procedure *)
\par FI;
\par CPL <- CodeSegment(DPL)
\par CS(RPL) <- CPL
\par END;
\par 
\par SAME-PRIVILEGE:
\par IF CallGateSize = 32
\par THEN
\par IF stack does not have room for 8 bytes
\par THEN #SS(0); FI;
\par IF EIP not within code segment limit then #GP(0); FI;
\par CS:EIP <- CallGate(CS:EIP) (* segment descriptor information also loaded *)
\par Push(oldCS:oldEIP); (* return address to calling procedure *)
\par ELSE (* CallGateSize = 16 *)
\par IF stack does not have room for parameters plus 4 bytes
\par THEN #SS(0); FI;
\par IF IP not within code segment limit THEN #GP(0); FI;
\par CS:IP <- CallGate(CS:instruction pointer)
\par (* segment descriptor information also loaded *)
\par Push(oldCS:oldIP); (* return address to calling procedure *)
\par FI;
\par CS(RPL) <- CPL
\par END;
\par 
\par TASK-GATE:
\par IF task gate DPL < CPL or RPL
\par THEN #GP(task gate selector);
\par FI;
\par IF task gate not present
\par THEN #NP(task gate selector);
\par FI;
\par Read the TSS segment selector in the task-gate descriptor;
\par IF TSS segment selector local/global bit is set to local
\par OR index not within GDT limits
\par THEN #GP(TSS selector);
\par FI;
\par Access TSS descriptor in GDT;
\par IF TSS descriptor specifies that the TSS is busy (low-order 5 bits set to 00001)
\par THEN #GP(TSS selector);
\par FI;
\par IF TSS not present
\par THEN #NP(TSS selector);
\par FI;
\par SWITCH-TASKS (with nesting) to TSS;
\par IF EIP not within code segment limit
\par THEN #GP(0);
\par FI;
\par END;
\par 
\par TASK-STATE-SEGMENT:
\par IF TSS DPL < CPL or RPL
\par OR TSS descriptor indicates TSS not available
\par THEN #GP(TSS selector);
\par FI;
\par IF TSS is not present
\par THEN #NP(TSS selector);
\par FI;
\par SWITCH-TASKS (with nesting) to TSS
\par IF EIP not within code segment limit
\par THEN #GP(0);
\par FI;
\par END;
{\page}

${\footnote CALL,Flags affected}
K{\footnote CALL,CALL;CALL,Flags affected}
#{\footnote CALL::3}

{\fs20\b CALL}\tab{\b Flags affected}\par\par
All flags are affected if a task switch occurs; no flags are affected if a task switch does not occur.
{\page}

${\footnote CALL,Exceptions}
K{\footnote CALL,CALL;CALL,Exceptions}
#{\footnote CALL::4}

{\fs20\b CALL}\tab{\b Exceptions}\par\par
Protected Mode Exceptions
\par 
\par #GP(0)
\par If target offset in destination operand is beyond the new code segment limit. If the segment selector in the destination operand is null. If the code segment selector in the gate is null.
\par If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit. If the DS, ES, FS, or GS register is used to access memory and it contains a null segment selector.
\par #GP(selector)
\par If code segment or gate or TSS selector index is outside descriptor table limits. If the segment descriptor pointed to by the segment selector in the destination operand is not for a conforming-code segment, noncon-forming-code segment, call gate, task gate, or task state segment.
\par If the DPL for a nonconforming-code segment is not equal to the CPL or the RPL for the segment's segment selector is greater than the CPL. If the DPL for a conforming-code segment is greater than the CPL. If the DPL from a call-gate, task-gate, or TSS segment descriptor is less than the CPL or than the RPL of the call-gate, task-gate, or TSS's segment selector.
\par If the segment descriptor for a segment selector from a call gate does not indicate it is a code segment. If the segment selector from a call gate is beyond the descriptor table limits. If the DPL for a code-segment obtained from a call gate is greater than the CPL.
\par If the segment selector for a TSS has its local/global bit set for local. If a TSS segment descriptor specifies that the TSS is busy or not available.
\par #SS(0)
\par 
\par 
\par If pushing the return address, parameters, or stack segment pointer onto the stack exceeds the bounds of the stack segment, when a stack switch occurs.
\par If the SS register is being loaded as part of a stack switch and the segment pointed to is marked not present. If stack segment does not have room for the return address, parameters, or stack segment pointer, when stack switch occurs.
\par #NP(selector)
\par If a code segment, data segment, stack segment, call gate, task gate, or TSS is not present.
\par #TS(selector)
\par If the new stack segment selector and ESP are beyond the end of the TSS. If the new stack segment selector is null. If the RPL of the new stack segment selector in the TSS is not equal to the DPL of the code segment being accessed.
\par If DPL of the stack segment descriptor for the new stack segment is not equal to the DPL of the code segment descriptor. If the new stack segment is not a writable data segment. If segment-selector index for stack segment is outside descriptor table limits.
\par #PF(fault-code)
\par If a page fault occurs.
\par #AC(0)
\par If an unaligned memory access occurs when the CPL is 3 and alignment checking is enabled.
\par 
\par Real-Address Mode Exceptions
\par 
\par #GP If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit. If the target offset is beyond the code segment limit.
\par 
\par Virtual-8086 Mode Exceptions
\par 
\par #GP(0) If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit. If the target offset is beyond the code segment limit.
\par #PF(fault-code) If a page fault occurs.
\par #AC(0) If an unaligned memory access occurs when alignment checking is enabled.
{\page}

${\footnote CALL,Opcode}
K{\footnote CALL,CALL;CALL,Opcode}
#{\footnote CALL::5}

{\fs20\b CALL}\tab{\b Opcode}\par\par
E8 cw CALL rel16 Call near, relative, displacement relative to next instruction
\par E8 cd CALL rel32 Call near, relative, displacement relative to next instruction
\par FF /2 CALL r/m16 Call near, absolute indirect, address given in r/m16
\par FF /2 CALL r/m32 Call near, absolute indirect, address given in r/m32
\par 9A cd CALL ptr16:16 Call far, absolute, address given in operand
\par 9A cp CALL ptr16:32 Call far, absolute, address given in operand
\par FF /3 CALL m16:16 Call far, absolute indirect, address given in m16:16
\par FF /3 CALL m16:32 Call far, absolute indirect, address given in m16:32
{\page}

${\footnote CBW,Description}
K{\footnote CBW,CBW;CWDE,CWDE;CBW,Description;CWDE,Description}
#{\footnote CBW::1}
#{\footnote CWDE::1}

{\fs20\b CBW/CWDE}\tab{\b Description}\par\par
CBW/CWDE--Convert Byte to Word/Convert Word to Doubleword
\par 
\par Double the size of the source operand by means of sign extension. The CBW (convert byte to word) instruction copies the sign (bit 7) in the source operand into every bit in the AH register. The CWDE (convert word to doubleword) instruction copies the sign (bit 15) of the word in the AX register into the higher 16 bits of the EAX register.
\par The CBW and CWDE mnemonics reference the same opcode. The CBW instruction is intended for use when the operand-size attribute is 16 and the CWDE instruction for when the operand-size attribute is 32. Some assemblers may force the operand size to 16 when CBW is used and to 32 when CWDE is used. Others may treat these mnemonics as synonyms (CBW/CWDE) and use the current setting of the operand-size attribute to determine the size of values to be converted, regardless of the mnemonic used.
\par The CWDE instruction is different from the CWD (convert word to double) instruction. The CWD instruction uses the DX:AX register pair as a destination operand; whereas, the CWDE instruction uses the EAX register as a destination.
{\page}

${\footnote CBW,Operation}
K{\footnote CBW,CBW;CWDE,CWDE;CBW,Operation;CWDE,Operation}
#{\footnote CBW::2}
#{\footnote CWDE::2}

{\fs20\b CBW/CWDE}\tab{\b Operation}\par\par
IF OperandSize = 16 (* instruction = CBW *)
\par THEN AX <- SignExtend(AL);
\par ELSE (* OperandSize = 32, instruction = CWDE *)
\par EAX <- SignExtend(AX);
\par FI;
{\page}

${\footnote CBW,Flags affected}
K{\footnote CBW,CBW;CWDE,CWDE;CBW,Flags affected;CWDE,Flags affected}
#{\footnote CBW::3}
#{\footnote CWDE::3}

{\fs20\b CBW/CWDE}\tab{\b Flags affected}\par\par
None.
{\page}

${\footnote CBW,Exceptions}
K{\footnote CBW,CBW;CWDE,CWDE;CBW,Exceptions;CWDE,Exceptions}
#{\footnote CBW::4}
#{\footnote CWDE::4}

{\fs20\b CBW/CWDE}\tab{\b Exceptions}\par\par
(All Operating Modes)
\par None.
{\page}

${\footnote CBW,Opcode}
K{\footnote CBW,CBW;CWDE,CWDE;CBW,Opcode;CWDE,Opcode}
#{\footnote CBW::5}
#{\footnote CWDE::5}

{\fs20\b CBW/CWDE}\tab{\b Opcode}\par\par
98 CBW AX <- sign-extend of AL
\par 98 CWDE EAX <- sign-extend of AX
{\page}

${\footnote CLC,Description}
K{\footnote CLC,CLC;CLC,Description}
#{\footnote CLC::1}

{\fs20\b CLC}\tab{\b Description}\par\par
CLC: Clear Carry Flag
\par 
\par Clears the CF flag in the EFLAGS register.
{\page}

${\footnote CLC,Operation}
K{\footnote CLC,CLC;CLC,Operation}
#{\footnote CLC::2}

{\fs20\b CLC}\tab{\b Operation}\par\par
CF <- 0;
{\page}

${\footnote CLC,Flags affected}
K{\footnote CLC,CLC;CLC,Flags affected}
#{\footnote CLC::3}

{\fs20\b CLC}\tab{\b Flags affected}\par\par
The CF flag is cleared to 0. The OF, ZF, SF, AF, and PF flags are unaffected.
{\page}

${\footnote CLC,Exceptions}
K{\footnote CLC,CLC;CLC,Exceptions}
#{\footnote CLC::4}

{\fs20\b CLC}\tab{\b Exceptions}\par\par
(All Operating Modes)
\par None.
{\page}

${\footnote CLC,Opcode}
K{\footnote CLC,CLC;CLC,Opcode}
#{\footnote CLC::5}

{\fs20\b CLC}\tab{\b Opcode}\par\par
F8 CLC Clear CF flag
{\page}

${\footnote CLD,Description}
K{\footnote CLD,CLD;CLD,Description}
#{\footnote CLD::1}

{\fs20\b CLD}\tab{\b Description}\par\par
CLD: Clear Direction Flag
\par 
\par Clears the DF flag in the EFLAGS register. When the DF flag is set to 0, string operations increment the index registers (ESI and/or EDI).
{\page}

${\footnote CLD,Operation}
K{\footnote CLD,CLD;CLD,Operation}
#{\footnote CLD::2}

{\fs20\b CLD}\tab{\b Operation}\par\par
DF <- 0;
{\page}

${\footnote CLD,Flags affected}
K{\footnote CLD,CLD;CLD,Flags affected}
#{\footnote CLD::3}

{\fs20\b CLD}\tab{\b Flags affected}\par\par
The DF flag is cleared to 0. The CF, OF, ZF, SF, AF, and PF flags are unaffected.
{\page}

${\footnote CLD,Exceptions}
K{\footnote CLD,CLD;CLD,Exceptions}
#{\footnote CLD::4}

{\fs20\b CLD}\tab{\b Exceptions}\par\par
(All Operating Modes)
\par None.
{\page}

${\footnote CLD,Opcode}
K{\footnote CLD,CLD;CLD,Opcode}
#{\footnote CLD::5}

{\fs20\b CLD}\tab{\b Opcode}\par\par
FC CLD Clear DF flag
{\page}

${\footnote CLI,Description}
K{\footnote CLI,CLI;CLI,Description}
#{\footnote CLI::1}

{\fs20\b CLI}\tab{\b Description}\par\par
CLI: Clear Interrupt Flag
\par 
\par Clears the IF flag in the EFLAGS register. No other flags are affected. Clearing the IF flag causes the processor to ignore maskable external interrupts. The IF flag and the CLI and STI instruction have no affect on the generation of exceptions and NMI interrupts.
{\page}

${\footnote CLI,Operation}
K{\footnote CLI,CLI;CLI,Operation}
#{\footnote CLI::2}

{\fs20\b CLI}\tab{\b Operation}\par\par
IF PE = 0 (* Executing in real-address mode *)
\par THEN
\par IF <- 0;
\par ELSE
\par IF VM = 0 (* Executing in protected mode *)
\par THEN
\par IF CPL  IOPL
\par THEN
\par IF <- 0;
\par ELSE
\par #GP(0);
\par FI;
\par FI;
\par ELSE (* Executing in Virtual-8086 mode *)
\par IF IOPL = 3
\par THEN
\par IF <- 0
\par ELSE
\par #GP(0);
\par FI;
\par FI;
\par FI;
{\page}

${\footnote CLI,Flags affected}
K{\footnote CLI,CLI;CLI,Flags affected}
#{\footnote CLI::3}

{\fs20\b CLI}\tab{\b Flags affected}\par\par
The IF is cleared to 0 if the CPL is equal to or less than the IOPL; otherwise, it is not affected. The other flags in the EFLAGS register are unaffected.
{\page}

${\footnote CLI,Exceptions}
K{\footnote CLI,CLI;CLI,Exceptions}
#{\footnote CLI::4}

{\fs20\b CLI}\tab{\b Exceptions}\par\par
Protected Mode Exceptions
\par 
\par #GP(0) If the CPL is greater (has less privilege) than the IOPL of the current program or procedure.
\par 
\par Real-Address Mode Exceptions
\par 
\par None.
\par 
\par Virtual-8086 Mode Exceptions
\par 
\par #GP(0) If the CPL is greater (has less privilege) than the IOPL of the current program or procedure.
{\page}

${\footnote CLI,Opcode}
K{\footnote CLI,CLI;CLI,Opcode}
#{\footnote CLI::5}

{\fs20\b CLI}\tab{\b Opcode}\par\par
FA CLI Clear interrupt flag; interrupts disabled when interrupt flag cleared
{\page}

${\footnote CLTS,Description}
K{\footnote CLTS,CLTS;CLTS,Description}
#{\footnote CLTS::1}

{\fs20\b CLTS}\tab{\b Description}\par\par
CLTS: Clear Task-Switched Flag in CR0
\par 
\par Clears the task-switched (TS) flag in the CR0 register. This instruction is intended for use in operating-system procedures. It is a privileged instruction that can only be executed at a CPL of 0. It is allowed to be executed in real-address mode to allow initialization for protected mode. The processor sets the TS flag every time a task switch occurs. The flag is used to synchronize the saving of FPU context in multitasking applications.
{\page}

${\footnote CLTS,Operation}
K{\footnote CLTS,CLTS;CLTS,Operation}
#{\footnote CLTS::2}

{\fs20\b CLTS}\tab{\b Operation}\par\par
CR0(TS) <- 0;
{\page}

${\footnote CLTS,Flags affected}
K{\footnote CLTS,CLTS;CLTS,Flags affected}
#{\footnote CLTS::3}

{\fs20\b CLTS}\tab{\b Flags affected}\par\par
The TS flag in CR0 register is cleared.
{\page}

${\footnote CLTS,Exceptions}
K{\footnote CLTS,CLTS;CLTS,Exceptions}
#{\footnote CLTS::4}

{\fs20\b CLTS}\tab{\b Exceptions}\par\par
Protected Mode Exceptions
\par 
\par #GP(0) If the CPL is greater than 0.
\par 
\par Real-Address Mode Exceptions
\par 
\par None.
\par 
\par Virtual-8086 Mode Exceptions
\par 
\par #GP(0) If the CPL is greater than 0.
{\page}

${\footnote CLTS,Opcode}
K{\footnote CLTS,CLTS;CLTS,Opcode}
#{\footnote CLTS::5}

{\fs20\b CLTS}\tab{\b Opcode}\par\par
0F 06 CLTS Clears TS flag in CR0
{\page}

${\footnote CMC,Description}
K{\footnote CMC,CMC;CMC,Description}
#{\footnote CMC::1}

{\fs20\b CMC}\tab{\b Description}\par\par
CMC: Complement Carry Flag
\par 
\par Complements the CF flag in the EFLAGS register.
{\page}

${\footnote CMC,Operation}
K{\footnote CMC,CMC;CMC,Operation}
#{\footnote CMC::2}

{\fs20\b CMC}\tab{\b Operation}\par\par
CF <- NOT CF;
{\page}

${\footnote CMC,Flags affected}
K{\footnote CMC,CMC;CMC,Flags affected}
#{\footnote CMC::3}

{\fs20\b CMC}\tab{\b Flags affected}\par\par
The CF flag contains the complement of its original value. The OF, ZF, SF, AF, and PF flags are unaffected.
{\page}

${\footnote CMC,Exceptions}
K{\footnote CMC,CMC;CMC,Exceptions}
#{\footnote CMC::4}

{\fs20\b CMC}\tab{\b Exceptions}\par\par
(All Operating Modes)
\par None.
{\page}

${\footnote CMC,Opcode}
K{\footnote CMC,CMC;CMC,Opcode}
#{\footnote CMC::5}

{\fs20\b CMC}\tab{\b Opcode}\par\par
F5 CMC Complement CF flag
{\page}

${\footnote CMOV,Description}
K{\footnote CMOV,CMOV;CMOVO,CMOVO;CMOVNO,CMOVNO;CMOVB,CMOVB;CMOVC,CMOVC;CMONVNAE,CMONVNAE;CMONAE,CMONAE;CMOVNB,CMOVNB;CMOVNC,CMOVNC;CMOVE,CMOVE;CMOVZ,CMOVZ;CMOVNZ,CMOVNZ;CMOVNE,CMOVNE;CMOVBE,CMOVBE;CMOVNA,CMOVNA;CMOVA,CMOVA;CMOVNBE,CMOVNBE;CMOVS,CMOVS;CMOVNS,CMOVNS;CMOVP,CMOVP;CMOVPE,CMOVPE;CMOVNP,CMOVNP;CMOVPO,CMOVPO;CMOVL,CMOVL;CMOVNGE,CMOVNGE;CMOVGE,CMOVGE;CMOVNL,CMOVNL;CMOVLE,CMOVLE;CMOVNG,CMOVNG;CMOVG,CMOVG;CMOVNLE,CMOVNLE;CMOV,Description;CMOVO,Description;CMOVNO,Description;CMOVB,Description;CMOVC,Description;CMONVNAE,Description;CMONAE,Description;CMOVNB,Description;CMOVNC,Description;CMOVE,Description;CMOVZ,Description;CMOVNZ,Description;CMOVNE,Description;CMOVBE,Description;CMOVNA,Description;CMOVA,Description;CMOVNBE,Description;CMOVS,Description;CMOVNS,Description;CMOVP,Description;CMOVPE,Description;CMOVNP,Description;CMOVPO,Description;CMOVL,Description;CMOVNGE,Description;CMOVGE,Description;CMOVNL,Description;CMOVLE,Description;CMOVNG,Description;CMOVG,Description;CMOVNLE,Description}
#{\footnote CMOV::1}
#{\footnote CMOVO::1}
#{\footnote CMOVNO::1}
#{\footnote CMOVB::1}
#{\footnote CMOVC::1}
#{\footnote CMONVNAE::1}
#{\footnote CMONAE::1}
#{\footnote CMOVNB::1}
#{\footnote CMOVNC::1}
#{\footnote CMOVE::1}
#{\footnote CMOVZ::1}
#{\footnote CMOVNZ::1}
#{\footnote CMOVNE::1}
#{\footnote CMOVBE::1}
#{\footnote CMOVNA::1}
#{\footnote CMOVA::1}
#{\footnote CMOVNBE::1}
#{\footnote CMOVS::1}
#{\footnote CMOVNS::1}
#{\footnote CMOVP::1}
#{\footnote CMOVPE::1}
#{\footnote CMOVNP::1}
#{\footnote CMOVPO::1}
#{\footnote CMOVL::1}
#{\footnote CMOVNGE::1}
#{\footnote CMOVGE::1}
#{\footnote CMOVNL::1}
#{\footnote CMOVLE::1}
#{\footnote CMOVNG::1}
#{\footnote CMOVG::1}
#{\footnote CMOVNLE::1}

{\fs20\b CMOV/CMOVO/CMOVNO/CMOVB/CMOVC/CMONVNAE/CMONAE/CMOVNB/CMOVNC/CMOVE/CMOVZ/CMOVNZ/CMOVNE/CMOVBE/CMOVNA/CMOVA/CMOVNBE/CMOVS/CMOVNS/CMOVP/CMOVPE/CMOVNP/CMOVPO/CMOVL/CMOVNGE/CMOVGE/CMOVNL/CMOVLE/CMOVNG/CMOVG/CMOVNLE}\tab{\b Description}\par\par
CMOV cc: Conditional Move
\par 
\par The CMOVcc instructions check the state of one or more of the status flags in the EFLAGS register (CF, OF, PF, SF, and ZF) and perform a move operation if the flags are in a specified state (or condition). A condition code (cc) is associated with each instruction to indicate the condition being tested for. If the condition is not satisfied, a move is not performed and execution continues with the instruction following the CMOVcc instruction.
\par These instructions can move a 16- or 32-bit value from memory to a general-purpose register or from one general-purpose register to another. Conditional moves of 8-bit register operands are not supported.
\par The conditions for each CMOVcc mnemonic is given in the description column of the opcode table. The terms 'less' and 'greater' are used for comparisons of signed integers and the terms 'above' and 'below' are used for unsigned integers.
\par Because a particular state of the status flags can sometimes be interpreted in two ways, two mnemonics are defined for some opcodes. For example, the CMOVA (conditional move if above) instruction and the CMOVNBE (conditional move if not below or equal) instruction are alternate mnemonics for the opcode 0F 47H.
\par The CMOVcc instructions are new for the Pentium Pro processor family; however, they may not be supported by all the processors in the family. Software can determine if the CMOVcc instructions are supported by checking the processor's feature information with the CPUID instruction.
{\page}

${\footnote CMOV,Operation}
K{\footnote CMOV,CMOV;CMOVO,CMOVO;CMOVNO,CMOVNO;CMOVB,CMOVB;CMOVC,CMOVC;CMONVNAE,CMONVNAE;CMONAE,CMONAE;CMOVNB,CMOVNB;CMOVNC,CMOVNC;CMOVE,CMOVE;CMOVZ,CMOVZ;CMOVNZ,CMOVNZ;CMOVNE,CMOVNE;CMOVBE,CMOVBE;CMOVNA,CMOVNA;CMOVA,CMOVA;CMOVNBE,CMOVNBE;CMOVS,CMOVS;CMOVNS,CMOVNS;CMOVP,CMOVP;CMOVPE,CMOVPE;CMOVNP,CMOVNP;CMOVPO,CMOVPO;CMOVL,CMOVL;CMOVNGE,CMOVNGE;CMOVGE,CMOVGE;CMOVNL,CMOVNL;CMOVLE,CMOVLE;CMOVNG,CMOVNG;CMOVG,CMOVG;CMOVNLE,CMOVNLE;CMOV,Operation;CMOVO,Operation;CMOVNO,Operation;CMOVB,Operation;CMOVC,Operation;CMONVNAE,Operation;CMONAE,Operation;CMOVNB,Operation;CMOVNC,Operation;CMOVE,Operation;CMOVZ,Operation;CMOVNZ,Operation;CMOVNE,Operation;CMOVBE,Operation;CMOVNA,Operation;CMOVA,Operation;CMOVNBE,Operation;CMOVS,Operation;CMOVNS,Operation;CMOVP,Operation;CMOVPE,Operation;CMOVNP,Operation;CMOVPO,Operation;CMOVL,Operation;CMOVNGE,Operation;CMOVGE,Operation;CMOVNL,Operation;CMOVLE,Operation;CMOVNG,Operation;CMOVG,Operation;CMOVNLE,Operation}
#{\footnote CMOV::2}
#{\footnote CMOVO::2}
#{\footnote CMOVNO::2}
#{\footnote CMOVB::2}
#{\footnote CMOVC::2}
#{\footnote CMONVNAE::2}
#{\footnote CMONAE::2}
#{\footnote CMOVNB::2}
#{\footnote CMOVNC::2}
#{\footnote CMOVE::2}
#{\footnote CMOVZ::2}
#{\footnote CMOVNZ::2}
#{\footnote CMOVNE::2}
#{\footnote CMOVBE::2}
#{\footnote CMOVNA::2}
#{\footnote CMOVA::2}
#{\footnote CMOVNBE::2}
#{\footnote CMOVS::2}
#{\footnote CMOVNS::2}
#{\footnote CMOVP::2}
#{\footnote CMOVPE::2}
#{\footnote CMOVNP::2}
#{\footnote CMOVPO::2}
#{\footnote CMOVL::2}
#{\footnote CMOVNGE::2}
#{\footnote CMOVGE::2}
#{\footnote CMOVNL::2}
#{\footnote CMOVLE::2}
#{\footnote CMOVNG::2}
#{\footnote CMOVG::2}
#{\footnote CMOVNLE::2}

{\fs20\b CMOV/CMOVO/CMOVNO/CMOVB/CMOVC/CMONVNAE/CMONAE/CMOVNB/CMOVNC/CMOVE/CMOVZ/CMOVNZ/CMOVNE/CMOVBE/CMOVNA/CMOVA/CMOVNBE/CMOVS/CMOVNS/CMOVP/CMOVPE/CMOVNP/CMOVPO/CMOVL/CMOVNGE/CMOVGE/CMOVNL/CMOVLE/CMOVNG/CMOVG/CMOVNLE}\tab{\b Operation}\par\par
temp <- DEST
\par IF condition TRUE
\par THEN
\par DEST <- SRC
\par ELSE
\par DEST <- temp
\par FI;
{\page}

${\footnote CMOV,Flags affected}
K{\footnote CMOV,CMOV;CMOVO,CMOVO;CMOVNO,CMOVNO;CMOVB,CMOVB;CMOVC,CMOVC;CMONVNAE,CMONVNAE;CMONAE,CMONAE;CMOVNB,CMOVNB;CMOVNC,CMOVNC;CMOVE,CMOVE;CMOVZ,CMOVZ;CMOVNZ,CMOVNZ;CMOVNE,CMOVNE;CMOVBE,CMOVBE;CMOVNA,CMOVNA;CMOVA,CMOVA;CMOVNBE,CMOVNBE;CMOVS,CMOVS;CMOVNS,CMOVNS;CMOVP,CMOVP;CMOVPE,CMOVPE;CMOVNP,CMOVNP;CMOVPO,CMOVPO;CMOVL,CMOVL;CMOVNGE,CMOVNGE;CMOVGE,CMOVGE;CMOVNL,CMOVNL;CMOVLE,CMOVLE;CMOVNG,CMOVNG;CMOVG,CMOVG;CMOVNLE,CMOVNLE;CMOV,Flags affected;CMOVO,Flags affected;CMOVNO,Flags affected;CMOVB,Flags affected;CMOVC,Flags affected;CMONVNAE,Flags affected;CMONAE,Flags affected;CMOVNB,Flags affected;CMOVNC,Flags affected;CMOVE,Flags affected;CMOVZ,Flags affected;CMOVNZ,Flags affected;CMOVNE,Flags affected;CMOVBE,Flags affected;CMOVNA,Flags affected;CMOVA,Flags affected;CMOVNBE,Flags affected;CMOVS,Flags affected;CMOVNS,Flags affected;CMOVP,Flags affected;CMOVPE,Flags affected;CMOVNP,Flags affected;CMOVPO,Flags affected;CMOVL,Flags affected;CMOVNGE,Flags affected;CMOVGE,Flags affected;CMOVNL,Flags affected;CMOVLE,Flags affected;CMOVNG,Flags affected;CMOVG,Flags affected;CMOVNLE,Flags affected}
#{\footnote CMOV::3}
#{\footnote CMOVO::3}
#{\footnote CMOVNO::3}
#{\footnote CMOVB::3}
#{\footnote CMOVC::3}
#{\footnote CMONVNAE::3}
#{\footnote CMONAE::3}
#{\footnote CMOVNB::3}
#{\footnote CMOVNC::3}
#{\footnote CMOVE::3}
#{\footnote CMOVZ::3}
#{\footnote CMOVNZ::3}
#{\footnote CMOVNE::3}
#{\footnote CMOVBE::3}
#{\footnote CMOVNA::3}
#{\footnote CMOVA::3}
#{\footnote CMOVNBE::3}
#{\footnote CMOVS::3}
#{\footnote CMOVNS::3}
#{\footnote CMOVP::3}
#{\footnote CMOVPE::3}
#{\footnote CMOVNP::3}
#{\footnote CMOVPO::3}
#{\footnote CMOVL::3}
#{\footnote CMOVNGE::3}
#{\footnote CMOVGE::3}
#{\footnote CMOVNL::3}
#{\footnote CMOVLE::3}
#{\footnote CMOVNG::3}
#{\footnote CMOVG::3}
#{\footnote CMOVNLE::3}

{\fs20\b CMOV/CMOVO/CMOVNO/CMOVB/CMOVC/CMONVNAE/CMONAE/CMOVNB/CMOVNC/CMOVE/CMOVZ/CMOVNZ/CMOVNE/CMOVBE/CMOVNA/CMOVA/CMOVNBE/CMOVS/CMOVNS/CMOVP/CMOVPE/CMOVNP/CMOVPO/CMOVL/CMOVNGE/CMOVGE/CMOVNL/CMOVLE/CMOVNG/CMOVG/CMOVNLE}\tab{\b Flags affected}\par\par
None.
{\page}

${\footnote CMOV,Exceptions}
K{\footnote CMOV,CMOV;CMOVO,CMOVO;CMOVNO,CMOVNO;CMOVB,CMOVB;CMOVC,CMOVC;CMONVNAE,CMONVNAE;CMONAE,CMONAE;CMOVNB,CMOVNB;CMOVNC,CMOVNC;CMOVE,CMOVE;CMOVZ,CMOVZ;CMOVNZ,CMOVNZ;CMOVNE,CMOVNE;CMOVBE,CMOVBE;CMOVNA,CMOVNA;CMOVA,CMOVA;CMOVNBE,CMOVNBE;CMOVS,CMOVS;CMOVNS,CMOVNS;CMOVP,CMOVP;CMOVPE,CMOVPE;CMOVNP,CMOVNP;CMOVPO,CMOVPO;CMOVL,CMOVL;CMOVNGE,CMOVNGE;CMOVGE,CMOVGE;CMOVNL,CMOVNL;CMOVLE,CMOVLE;CMOVNG,CMOVNG;CMOVG,CMOVG;CMOVNLE,CMOVNLE;CMOV,Exceptions;CMOVO,Exceptions;CMOVNO,Exceptions;CMOVB,Exceptions;CMOVC,Exceptions;CMONVNAE,Exceptions;CMONAE,Exceptions;CMOVNB,Exceptions;CMOVNC,Exceptions;CMOVE,Exceptions;CMOVZ,Exceptions;CMOVNZ,Exceptions;CMOVNE,Exceptions;CMOVBE,Exceptions;CMOVNA,Exceptions;CMOVA,Exceptions;CMOVNBE,Exceptions;CMOVS,Exceptions;CMOVNS,Exceptions;CMOVP,Exceptions;CMOVPE,Exceptions;CMOVNP,Exceptions;CMOVPO,Exceptions;CMOVL,Exceptions;CMOVNGE,Exceptions;CMOVGE,Exceptions;CMOVNL,Exceptions;CMOVLE,Exceptions;CMOVNG,Exceptions;CMOVG,Exceptions;CMOVNLE,Exceptions}
#{\footnote CMOV::4}
#{\footnote CMOVO::4}
#{\footnote CMOVNO::4}
#{\footnote CMOVB::4}
#{\footnote CMOVC::4}
#{\footnote CMONVNAE::4}
#{\footnote CMONAE::4}
#{\footnote CMOVNB::4}
#{\footnote CMOVNC::4}
#{\footnote CMOVE::4}
#{\footnote CMOVZ::4}
#{\footnote CMOVNZ::4}
#{\footnote CMOVNE::4}
#{\footnote CMOVBE::4}
#{\footnote CMOVNA::4}
#{\footnote CMOVA::4}
#{\footnote CMOVNBE::4}
#{\footnote CMOVS::4}
#{\footnote CMOVNS::4}
#{\footnote CMOVP::4}
#{\footnote CMOVPE::4}
#{\footnote CMOVNP::4}
#{\footnote CMOVPO::4}
#{\footnote CMOVL::4}
#{\footnote CMOVNGE::4}
#{\footnote CMOVGE::4}
#{\footnote CMOVNL::4}
#{\footnote CMOVLE::4}
#{\footnote CMOVNG::4}
#{\footnote CMOVG::4}
#{\footnote CMOVNLE::4}

{\fs20\b CMOV/CMOVO/CMOVNO/CMOVB/CMOVC/CMONVNAE/CMONAE/CMOVNB/CMOVNC/CMOVE/CMOVZ/CMOVNZ/CMOVNE/CMOVBE/CMOVNA/CMOVA/CMOVNBE/CMOVS/CMOVNS/CMOVP/CMOVPE/CMOVNP/CMOVPO/CMOVL/CMOVNGE/CMOVGE/CMOVNL/CMOVLE/CMOVNG/CMOVG/CMOVNLE}\tab{\b Exceptions}\par\par
Protected Mode Exceptions
\par 
\par #GP(0) If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit. If the DS, ES, FS, or GS register contains a null segment selector. 
\par #SS(0) If a memory operand effective address is outside the SS segment limit.
\par #PF(fault-code) If a page fault occurs.
\par #AC(0) If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.
\par 
\par Real-Address Mode Exceptions
\par 
\par #GP If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.
\par #SS If a memory operand effective address is outside the SS segment limit.
\par 
\par Virtual-8086 Mode Exceptions
\par 
\par #GP(0) If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.
\par #SS(0) If a memory operand effective address is outside the SS segment limit.
\par #PF(fault-code) If a page fault occurs.
\par #AC(0) If alignment checking is enabled and an unaligned memory reference is made.
{\page}

${\footnote CMOV,Opcode}
K{\footnote CMOV,CMOV;CMOVO,CMOVO;CMOVNO,CMOVNO;CMOVB,CMOVB;CMOVC,CMOVC;CMONVNAE,CMONVNAE;CMONAE,CMONAE;CMOVNB,CMOVNB;CMOVNC,CMOVNC;CMOVE,CMOVE;CMOVZ,CMOVZ;CMOVNZ,CMOVNZ;CMOVNE,CMOVNE;CMOVBE,CMOVBE;CMOVNA,CMOVNA;CMOVA,CMOVA;CMOVNBE,CMOVNBE;CMOVS,CMOVS;CMOVNS,CMOVNS;CMOVP,CMOVP;CMOVPE,CMOVPE;CMOVNP,CMOVNP;CMOVPO,CMOVPO;CMOVL,CMOVL;CMOVNGE,CMOVNGE;CMOVGE,CMOVGE;CMOVNL,CMOVNL;CMOVLE,CMOVLE;CMOVNG,CMOVNG;CMOVG,CMOVG;CMOVNLE,CMOVNLE;CMOV,Opcode;CMOVO,Opcode;CMOVNO,Opcode;CMOVB,Opcode;CMOVC,Opcode;CMONVNAE,Opcode;CMONAE,Opcode;CMOVNB,Opcode;CMOVNC,Opcode;CMOVE,Opcode;CMOVZ,Opcode;CMOVNZ,Opcode;CMOVNE,Opcode;CMOVBE,Opcode;CMOVNA,Opcode;CMOVA,Opcode;CMOVNBE,Opcode;CMOVS,Opcode;CMOVNS,Opcode;CMOVP,Opcode;CMOVPE,Opcode;CMOVNP,Opcode;CMOVPO,Opcode;CMOVL,Opcode;CMOVNGE,Opcode;CMOVGE,Opcode;CMOVNL,Opcode;CMOVLE,Opcode;CMOVNG,Opcode;CMOVG,Opcode;CMOVNLE,Opcode}
#{\footnote CMOV::5}
#{\footnote CMOVO::5}
#{\footnote CMOVNO::5}
#{\footnote CMOVB::5}
#{\footnote CMOVC::5}
#{\footnote CMONVNAE::5}
#{\footnote CMONAE::5}
#{\footnote CMOVNB::5}
#{\footnote CMOVNC::5}
#{\footnote CMOVE::5}
#{\footnote CMOVZ::5}
#{\footnote CMOVNZ::5}
#{\footnote CMOVNE::5}
#{\footnote CMOVBE::5}
#{\footnote CMOVNA::5}
#{\footnote CMOVA::5}
#{\footnote CMOVNBE::5}
#{\footnote CMOVS::5}
#{\footnote CMOVNS::5}
#{\footnote CMOVP::5}
#{\footnote CMOVPE::5}
#{\footnote CMOVNP::5}
#{\footnote CMOVPO::5}
#{\footnote CMOVL::5}
#{\footnote CMOVNGE::5}
#{\footnote CMOVGE::5}
#{\footnote CMOVNL::5}
#{\footnote CMOVLE::5}
#{\footnote CMOVNG::5}
#{\footnote CMOVG::5}
#{\footnote CMOVNLE::5}

{\fs20\b CMOV/CMOVO/CMOVNO/CMOVB/CMOVC/CMONVNAE/CMONAE/CMOVNB/CMOVNC/CMOVE/CMOVZ/CMOVNZ/CMOVNE/CMOVBE/CMOVNA/CMOVA/CMOVNBE/CMOVS/CMOVNS/CMOVP/CMOVPE/CMOVNP/CMOVPO/CMOVL/CMOVNGE/CMOVGE/CMOVNL/CMOVLE/CMOVNG/CMOVG/CMOVNLE}\tab{\b Opcode}\par\par
0F 47 /r CMOVA r16, r/m16 Move if above (CF=0 and ZF=0)
\par 0F 47 /r CMOVA r32, r/m32 Move if above (CF=0 and ZF=0)
\par 0F 43 /r CMOVAE r16, r/m16 Move if above or equal (CF=0)
\par 0F 43 /r CMOVAE r32, r/m32 Move if above or equal (CF=0)
\par 0F 42 /r CMOVB r16, r/m16 Move if below (CF=1)
\par 0F 42 /r CMOVB r32, r/m32 Move if below (CF=1)
\par 0F 46 /r CMOVBE r16, r/m16 Move if below or equal (CF=1 or ZF=1)
\par 0F 46 /r CMOVBE r32, r/m32 Move if below or equal (CF=1 or ZF=1)
\par 0F 42 /r CMOVC r16, r/m16 Move if carry (CF=1)
\par 0F 42 /r CMOVC r32, r/m32 Move if carry (CF=1)
\par 0F 44 /r CMOVE r16, r/m16 Move if equal (ZF=1)
\par 0F 44 /r CMOVE r32, r/m32 Move if equal (ZF=1)
\par 0F 4F /r CMOVG r16, r/m16 Move if greater (ZF=0 and SF=OF)
\par 0F 4F /r CMOVG r32, r/m32 Move if greater (ZF=0 and SF=OF)
\par 0F 4D /r CMOVGE r16, r/m16 Move if greater or equal (SF=OF)
\par 0F 4D /r CMOVGE r32, r/m32 Move if greater or equal (SF=OF)
\par 0F 4C /r CMOVL r16, r/m16 Move if less (SF<>OF)
\par 0F 4C /r CMOVL r32, r/m32 Move if less (SF<>OF)
\par 0F 4E /r CMOVLE r16, r/m16 Move if less or equal (ZF=1 or SF<>OF)
\par 0F 4E /r CMOVLE r32, r/m32 Move if less or equal (ZF=1 or SF<>OF)
\par 0F 46 /r CMOVNA r16, r/m16 Move if not above (CF=1 or ZF=1)
\par 0F 46 /r CMOVNA r32, r/m32 Move if not above (CF=1 or ZF=1)
\par 0F 42 /r CMOVNAE r16, r/m16 Move if not above or equal (CF=1)
\par 0F 42 /r CMOVNAE r32, r/m32 Move if not above or equal (CF=1)
\par 0F 43 /r CMOVNB r16, r/m16 Move if not below (CF=0)
\par 0F 43 /r CMOVNB r32, r/m32 Move if not below (CF=0)
\par 0F 47 /r CMOVNBE r16, r/m16 Move if not below or equal (CF=0 and ZF=0)
\par 0F 47 /r CMOVNBE r32, r/m32 Move if not below or equal (CF=0 and ZF=0)
\par 0F 43 /r CMOVNC r16, r/m16 Move if not carry (CF=0)
\par 0F 43 /r CMOVNC r32, r/m32 Move if not carry (CF=0)
\par 0F 45 /r CMOVNE r16, r/m16 Move if not equal (ZF=0)
\par 0F 45 /r CMOVNE r32, r/m32 Move if not equal (ZF=0)
\par 0F 4E /r CMOVNG r16, r/m16 Move if not greater (ZF=1 or SF<>OF)
\par 0F 4E /r CMOVNG r32, r/m32 Move if not greater (ZF=1 or SF<>OF)
\par 0F 4C /r CMOVNGE r16, r/m16 Move if not greater or equal (SF<>OF)
\par 0F 4C /r CMOVNGE r32, r/m32 Move if not greater or equal (SF<>OF)
\par 0F 4D /r CMOVNL r16, r/m16 Move if not less (SF=OF)
\par 0F 4D /r CMOVNL r32, r/m32 Move if not less (SF=OF)
\par 0F 4F /r CMOVNLE r16, r/m16 Move if not less or equal (ZF=0 and SF=OF)
\par 0F 4F /r CMOVNLE r32, r/m32 Move if not less or equal (ZF=0 and SF=OF)
\par 0F 41 /r CMOVNO r16, r/m16 Move if not overflow (OF=0)
\par 0F 41 /r CMOVNO r32, r/m32 Move if not overflow (OF=0)
\par 0F 4B /r CMOVNP r16, r/m16 Move if not parity (PF=0)
\par 0F 4B /r CMOVNP r32, r/m32 Move if not parity (PF=0)
\par 0F 49 /r CMOVNS r16, r/m16 Move if not sign (SF=0)
\par 0F 49 /r CMOVNS r32, r/m32 Move if not sign (SF=0)
\par 0F 45 /r CMOVNZ r16, r/m16 Move if not zero (ZF=0)
\par 0F 45 /r CMOVNZ r32, r/m32 Move if not zero (ZF=0)
\par 0F 40 /r CMOVO r16, r/m16 Move if overflow (OF=0)
\par 0F 40 /r CMOVO r32, r/m32 Move if overflow (OF=0)
\par 0F 4A /r CMOVP r16, r/m16 Move if parity (PF=1)
\par 0F 4A /r CMOVP r32, r/m32 Move if parity (PF=1)
\par 0F 4A /r CMOVPE r16, r/m16 Move if parity even (PF=1)
\par 0F 4A /r CMOVPE r32, r/m32 Move if parity even (PF=1)
\par 0F 4B /r CMOVPO r16, r/m16 Move if parity odd (PF=0)
\par 0F 4B /r CMOVPO r32, r/m32 Move if parity odd (PF=0)
\par 0F 48 /r CMOVS r16, r/m16 Move if sign (SF=1)
\par 0F 48 /r CMOVS r32, r/m32 Move if sign (SF=1)
\par 0F 44 /r CMOVZ r16, r/m16 Move if zero (ZF=1)
\par 0F 44 /r CMOVZ r32, r/m32 Move if zero (ZF=1)
{\page}

${\footnote CMP,Description}
K{\footnote CMP,CMP;CMP,Description}
#{\footnote CMP::1}

{\fs20\b CMP}\tab{\b Description}\par\par
CMP: Compare Two Operands
\par 
\par Compares the first source operand with the second source operand and sets the status flags in the EFLAGS register according to the results. The comparison is performed by subtracting the second operand from the first operand and then setting the status flags in the same manner as the SUB instruction. When an immediate value is used as an operand, it is sign-extended to the length of the first operand.
\par The CMP instruction is typically used in conjunction with a conditional jump (Jcc), condition move (CMOVcc), or SETcc instruction. The condition codes used by the Jcc, CMOVcc, and SETcc instructions are based on the results of a CMP instruction.
{\page}

${\footnote CMP,Operation}
K{\footnote CMP,CMP;CMP,Operation}
#{\footnote CMP::2}

{\fs20\b CMP}\tab{\b Operation}\par\par
temp <- SRC1 - SignExtend(SRC2);
\par ModifyStatusFlags; (* Modify status flags in the same manner as the SUB instruction*)
{\page}

${\footnote CMP,Flags affected}
K{\footnote CMP,CMP;CMP,Flags affected}
#{\footnote CMP::3}

{\fs20\b CMP}\tab{\b Flags affected}\par\par
The CF, OF, SF, ZF, AF, and PF flags are set according to the result.
{\page}

${\footnote CMP,Exceptions}
K{\footnote CMP,CMP;CMP,Exceptions}
#{\footnote CMP::4}

{\fs20\b CMP}\tab{\b Exceptions}\par\par
Protected Mode Exceptions
\par 
\par #GP(0) If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit. If the DS, ES, FS, or GS register contains a null segment selector.
\par #SS(0) If a memory operand effective address is outside the SS segment limit.
\par #PF(fault-code) If a page fault occurs.
\par #AC(0) If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.
\par 
\par Real-Address Mode Exceptions
\par 
\par #GP If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.
\par #SS If a memory operand effective address is outside the SS segment limit.
\par 
\par Virtual-8086 Mode Exceptions
\par 
\par #GP(0) If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.
\par #SS(0) If a memory operand effective address is outside the SS segment limit.
\par #PF(fault-code) If a page fault occurs.
\par #AC(0) If alignment checking is enabled and an unaligned memory reference is made.
{\page}

${\footnote CMP,Opcode}
K{\footnote CMP,CMP;CMP,Opcode}
#{\footnote CMP::5}

{\fs20\b CMP}\tab{\b Opcode}\par\par
3C ib CMP AL, imm8 Compare imm8 with AL
\par 3D iw CMP AX, imm16 Compare imm16 with AX
\par 3D id CMP EAX, imm32 Compare imm32 with EAX
\par 80 /7 ib CMP r/m8, imm8 Compare imm8 with r/m8
\par 81 /7 iw CMP r/m16, imm16 Compare imm16 with r/m16
\par 81 /7 id CMP r/m32,imm32 Compare imm32 with r/m32
\par 83 /7 ib CMP r/m16,imm8 Compare imm8 with r/m16
\par 83 /7 ib CMP r/m32,imm8 Compare imm8 with r/m32
\par 38 / r CMP r/m8,r8 Compare r8 with r/m8
\par 39 / r CMP r/m16,r16 Compare r16 with r/m16
\par 39 / r CMP r/m32,r32 Compare r32 with r/m32
\par 3A / r CMP r8,r/m8 Compare r/m8 with r8
\par 3B / r CMP r16,r/m16 Compare r/m16 with r16
\par 3B / r CMP r32,r/m32 Compare r/m32 with r32
{\page}

${\footnote CMPS,Description}
K{\footnote CMPS,CMPS;CMPSB,CMPSB;CMPSW,CMPSW;CMPSD,CMPSD;CMPS,Description;CMPSB,Description;CMPSW,Description;CMPSD,Description}
#{\footnote CMPS::1}
#{\footnote CMPSB::1}
#{\footnote CMPSW::1}
#{\footnote CMPSD::1}

{\fs20\b CMPS/CMPSB/CMPSW/CMPSD}\tab{\b Description}\par\par
CMPS/CMPSB/CMPSW/CMPSD: Compare String Operands
\par 
\par Compares the byte, word, or double word specified with the first source operand with the byte, word, or double word specified with the second source operand and sets the status flags in the EFLAGS register according to the results. Both the source operands are located in memory. The address of the first source operand is read from either the DS:ESI or the DS:SI registers (depending on the address-size attribute of the instruction, 32 or 16, respectively). The address of the second source operand is read from either the ES:EDI or the ES:DI registers (again depending on the address-size attribute of the instruction). The DS segment may be overridden with a segment override prefix, but the ES segment cannot be overridden.
\par At the assembly-code level, two forms of this instruction are allowed: the "explicit-operands" form and the "no-operands" form. The explicit-operands form (specified with the CMPS mnemonic) allows the two source operands to be specified explicitly. Here, the source operands should be symbols that indicate the size and location of the source values. This explicit-operands form is provided to allow documentation; however, note that the documentation provided by this form can be misleading. That is, the source operand symbols must specify the correct type (size) of the operands (bytes, words, or doublewords), but they do not have to specify the correct location.
\par The locations of the source operands are always specified by the DS:(E)SI and ES:(E)DI registers, which must be loaded correctly before the compare string instruction is executed.
\par The no-operands form provides "short forms" of the byte, word, and doubleword versions of the CMPS instructions. Here also the DS:(E)SI and ES:(E)DI registers are assumed by the processor to specify the location of the source operands. The size of the source operands is selected with the mnemonic: CMPSB (byte comparison), CMPSW (word comparison), or CMPSD (double-word comparison).
\par After the comparison, the (E)SI and (E)DI registers are incremented or decremented automatically according to the setting of the DF flag in the EFLAGS register. (If the DF flag is 0, the (E)SI and (E)DI register are incremented; if the DF flag is 1, the (E)SI and (E)DI registers are decremented.) The registers are incremented or decremented by 1 for byte operations, by 2 for word operations, or by 4 for doubleword operations.
\par The CMPS, CMPSB, CMPSW, and CMPSD instructions can be preceded by the REP prefix for block comparisons of ECX bytes, words, or doublewords. More often, however, these instructions will be used in a LOOP construct that takes some action based on the setting of the status flags before the next comparison is made.
{\page}

${\footnote CMPS,Operation}
K{\footnote CMPS,CMPS;CMPSB,CMPSB;CMPSW,CMPSW;CMPSD,CMPSD;CMPS,Operation;CMPSB,Operation;CMPSW,Operation;CMPSD,Operation}
#{\footnote CMPS::2}
#{\footnote CMPSB::2}
#{\footnote CMPSW::2}
#{\footnote CMPSD::2}

{\fs20\b CMPS/CMPSB/CMPSW/CMPSD}\tab{\b Operation}\par\par
temp <-SRC1 - SRC2;
\par SetStatusFlags(temp);
\par IF (byte comparison)
\par THEN IF DF = 0
\par THEN
\par (E)SI <- (E)SI + 1;
\par (E)DI <- (E)DI + 1;
\par ELSE
\par (E)SI <- (E)SI - 1;
\par (E)DI <- (E)DI - 1;
\par FI;
\par ELSE IF (word comparison)
\par THEN IF DF = 0
\par (E)SI <- (E)SI + 2;
\par (E)DI <- (E)DI + 2;
\par ELSE
\par (E)SI <- (E)SI - 2;
\par (E)DI <- (E)DI - 2;
\par FI;
\par ELSE (* doubleword comparison*)
\par THEN IF DF = 0
\par (E)SI <- (E)SI + 4;
\par (E)DI <- (E)DI + 4;
\par ELSE
\par (E)SI <- (E)SI - 4;
\par (E)DI <- (E)DI - 4;
\par FI;
\par FI;
{\page}

${\footnote CMPS,Flags affected}
K{\footnote CMPS,CMPS;CMPSB,CMPSB;CMPSW,CMPSW;CMPSD,CMPSD;CMPS,Flags affected;CMPSB,Flags affected;CMPSW,Flags affected;CMPSD,Flags affected}
#{\footnote CMPS::3}
#{\footnote CMPSB::3}
#{\footnote CMPSW::3}
#{\footnote CMPSD::3}

{\fs20\b CMPS/CMPSB/CMPSW/CMPSD}\tab{\b Flags affected}\par\par
The CF, OF, SF, ZF, AF, and PF flags are set according to the temporary result of the comparison.
{\page}

${\footnote CMPS,Exceptions}
K{\footnote CMPS,CMPS;CMPSB,CMPSB;CMPSW,CMPSW;CMPSD,CMPSD;CMPS,Exceptions;CMPSB,Exceptions;CMPSW,Exceptions;CMPSD,Exceptions}
#{\footnote CMPS::4}
#{\footnote CMPSB::4}
#{\footnote CMPSW::4}
#{\footnote CMPSD::4}

{\fs20\b CMPS/CMPSB/CMPSW/CMPSD}\tab{\b Exceptions}\par\par
Protected Mode Exceptions
\par 
\par #GP(0) If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit. If the DS, ES, FS, or GS register contains a null segment selector.
\par #SS(0) If a memory operand effective address is outside the SS segment limit.
\par #PF(fault-code) If a page fault occurs.
\par #AC(0) If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.
\par 
\par Real-Address Mode Exceptions
\par 
\par #GP If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.
\par #SS If a memory operand effective address is outside the SS segment limit.
\par 
\par Virtual-8086 Mode Exceptions
\par 
\par #GP(0) If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.
\par #SS(0) If a memory operand effective address is outside the SS segment limit.
\par #PF(fault-code) If a page fault occurs.
\par #AC(0) If alignment checking is enabled and an unaligned memory reference is made.
{\page}

${\footnote CMPS,Opcode}
K{\footnote CMPS,CMPS;CMPSB,CMPSB;CMPSW,CMPSW;CMPSD,CMPSD;CMPS,Opcode;CMPSB,Opcode;CMPSW,Opcode;CMPSD,Opcode}
#{\footnote CMPS::5}
#{\footnote CMPSB::5}
#{\footnote CMPSW::5}
#{\footnote CMPSD::5}

{\fs20\b CMPS/CMPSB/CMPSW/CMPSD}\tab{\b Opcode}\par\par
A6 CMPS m8, m8 Compares byte at address DS:(E)SI with byte at address ES:(E)DI and sets the status flags accordingly
\par A7 CMPS m16, m16 Compares word at address DS:(E)SI with word at address ES:(E)DI and sets the status flags accordingly
\par A7 CMPS m32, m32 Compares doubleword at address DS:(E)SI with doubleword at address ES:(E)DI and sets the status flags accordingly
\par A6 CMPSB Compares byte at address DS:(E)SI with byte at address ES:(E)DI and sets the status flags accordingly
\par A7 CMPSW Compares word at address DS:(E)SI with word at address ES:(E)DI and sets the status flags accordingly
\par A7 CMPSD Compares doubleword at address DS:(E)SI with doubleword at address ES:(E)DI and sets the status flags accordingly
{\page}

${\footnote CMPXCHG,Description}
K{\footnote CMPXCHG,CMPXCHG;CMPXCHG,Description}
#{\footnote CMPXCHG::1}

{\fs20\b CMPXCHG}\tab{\b Description}\par\par
CMPXCHG: Compare and Exchange
\par 
\par Compares the value in the AL, AX, or EAX register (depending on the size of the operand) with the first operand (destination operand). If the two values are equal, the second operand (source operand) is loaded into the destination operand. Otherwise, the destination operand is loaded into the AL, AX, or EAX register.
\par This instruction can be used with a LOCK prefix to allow the instruction to be executed atomically. To simplify the interface to the processor's bus, the destination operand receives a write cycle without regard to the result of the comparison. The destination operand is written back if the comparison fails; otherwise, the source operand is written into the destination. (The processor never produces a locked read without also producing a locked write.)
\par 
\par Intel Architecture Compatibility
\par 
\par This instruction is not supported on Intel processors earlier than the Intel486 processors.
{\page}

${\footnote CMPXCHG,Operation}
K{\footnote CMPXCHG,CMPXCHG;CMPXCHG,Operation}
#{\footnote CMPXCHG::2}

{\fs20\b CMPXCHG}\tab{\b Operation}\par\par
(* accumulator = AL, AX, or EAX, depending on whether *)
\par (* a byte, word, or doubleword comparison is being performed*)
\par IF accumulator = DEST
\par THEN
\par ZF <- 1
\par DEST <- SRC
\par ELSE
\par ZF <- 0
\par accumulator <- DEST
\par FI;
{\page}

${\footnote CMPXCHG,Flags affected}
K{\footnote CMPXCHG,CMPXCHG;CMPXCHG,Flags affected}
#{\footnote CMPXCHG::3}

{\fs20\b CMPXCHG}\tab{\b Flags affected}\par\par
The ZF flag is set if the values in the destination operand and register AL, AX, or EAX are equal; otherwise it is cleared. The CF, PF, AF, SF, and OF flags are set according to the results of the comparison operation.
{\page}

${\footnote CMPXCHG,Exceptions}
K{\footnote CMPXCHG,CMPXCHG;CMPXCHG,Exceptions}
#{\footnote CMPXCHG::4}

{\fs20\b CMPXCHG}\tab{\b Exceptions}\par\par
Protected Mode Exceptions
\par 
\par #GP(0) If the destination is located in a nonwritable segment. If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit. If the DS, ES, FS, or GS register contains a null segment selector.
\par #SS(0) If a memory operand effective address is outside the SS segment limit.
\par #PF(fault-code) If a page fault occurs.
\par #AC(0) If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.
\par 
\par Real-Address Mode Exceptions
\par 
\par #GP If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.
\par #SS If a memory operand effective address is outside the SS segment limit.
\par 
\par Virtual-8086 Mode Exceptions
\par 
\par #GP(0) If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.
\par #SS(0) If a memory operand effective address is outside the SS segment limit.
\par #PF(fault-code) If a page fault occurs.
\par #AC(0) If alignment checking is enabled and an unaligned memory reference is made.
{\page}

${\footnote CMPXCHG,Opcode}
K{\footnote CMPXCHG,CMPXCHG;CMPXCHG,Opcode}
#{\footnote CMPXCHG::5}

{\fs20\b CMPXCHG}\tab{\b Opcode}\par\par
0F B0/ r CMPXCHG r/m8,r8 Compare AL with r/m8. If equal, ZF is set and r8 is loaded into r/m8. Else, clear ZF and load r/m8 into AL.
\par 0F B1/ r CMPXCHG r/m16,r16 Compare AX with r/m16. If equal, ZF is set and r16 is loaded into r/m16. Else, clear ZF and load r/m16 into AL.
\par 0F B1/ r CMPXCHG r/m32,r32 Compare EAX with r/m32. If equal, ZF is set and r32 is loaded into r/m32. Else, clear ZF and load r/m32 into AL.
{\page}

${\footnote CMPXCHG8B,Description}
K{\footnote CMPXCHG8B,CMPXCHG8B;CMPXCHG8B,Description}
#{\footnote CMPXCHG8B::1}

{\fs20\b CMPXCHG8B}\tab{\b Description}\par\par
CMPXCHG8B: Compare and Exchange 8 Bytes
\par 
\par Compares the 64-bit value in EDX:EAX with the operand (destination operand). If the values are equal, the 64-bit value in ECX:EBX is stored in the destination operand. Otherwise, the value in the destination operand is loaded into EDX:EAX. The destination operand is an 8-byte memory location. For the EDX:EAX and ECX:EBX register pairs, EDX and ECX contain the high-order 32 bits and EAX and EBX contain the low-order 32 bits of a 64-bit value.
\par This instruction can be used with a LOCK prefix to allow the instruction to be executed atomically. To simplify the interface to the processor's bus, the destination operand receives a write cycle without regard to the result of the comparison. The destination operand is written back if the comparison fails; otherwise, the source operand is written into the destination. (The processor never produces a locked read without also producing a locked write.)
\par 
\par Intel Architecture Compatibility
\par 
\par This instruction is not supported on Intel processors earlier than the Pentium processors.
{\page}

${\footnote CMPXCHG8B,Operation}
K{\footnote CMPXCHG8B,CMPXCHG8B;CMPXCHG8B,Operation}
#{\footnote CMPXCHG8B::2}

{\fs20\b CMPXCHG8B}\tab{\b Operation}\par\par
IF (EDX:EAX = DEST)
\par ZF <- 1
\par DEST <- ECX:EBX
\par ELSE
\par ZF <- 0
\par EDX:EAX <- DEST
{\page}

${\footnote CMPXCHG8B,Flags affected}
K{\footnote CMPXCHG8B,CMPXCHG8B;CMPXCHG8B,Flags affected}
#{\footnote CMPXCHG8B::3}

{\fs20\b CMPXCHG8B}\tab{\b Flags affected}\par\par
The ZF flag is set if the destination operand and EDX:EAX are equal; otherwise it is cleared. The CF, PF, AF, SF, and OF flags are unaffected.
{\page}

${\footnote CMPXCHG8B,Exceptions}
K{\footnote CMPXCHG8B,CMPXCHG8B;CMPXCHG8B,Exceptions}
#{\footnote CMPXCHG8B::4}

{\fs20\b CMPXCHG8B}\tab{\b Exceptions}\par\par
Protected Mode Exceptions
\par 
\par #UD If the destination operand is not a memory location.
\par #GP(0) If the destination is located in a nonwritable segment. If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit. If the DS, ES, FS, or GS register contains a null segment selector.
\par #SS(0) If a memory operand effective address is outside the SS segment limit.
\par #PF(fault-code) If a page fault occurs.
\par #AC(0) If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.
\par 
\par Real-Address Mode Exceptions
\par 
\par #UD If the destination operand is not a memory location.
\par #GP If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.
\par #SS If a memory operand effective address is outside the SS segment limit.
\par 
\par Virtual-8086 Mode Exceptions
\par 
\par #UD If the destination operand is not a memory location.
\par #GP(0) If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.
\par #SS(0) If a memory operand effective address is outside the SS segment limit.
\par #PF(fault-code) If a page fault occurs.
\par #AC(0) If alignment checking is enabled and an unaligned memory reference is made.
{\page}

${\footnote CMPXCHG8B,Opcode}
K{\footnote CMPXCHG8B,CMPXCHG8B;CMPXCHG8B,Opcode}
#{\footnote CMPXCHG8B::5}

{\fs20\b CMPXCHG8B}\tab{\b Opcode}\par\par
0F C7 /1 m64 CMPXCHG8B m64 Compare EDX:EAX with m64. If equal, set ZF and load ECX:EBX into m64. Else, clear ZF and load m64 into EDX:EAX.
{\page}

${\footnote CWD,Description}
K{\footnote CWD,CWD;CDQ,CDQ;CWD,Description;CDQ,Description}
#{\footnote CWD::1}
#{\footnote CDQ::1}

{\fs20\b CWD/CDQ}\tab{\b Description}\par\par
CWD/CDQ: Convert Word to Doubleword/Convert Doubleword to Quadword
\par 
\par Doubles the size of the operand in register AX or EAX (depending on the operand size) by means of sign extension and stores the result in registers DX:AX or EDX:EAX, respectively.
\par The CWD instruction copies the sign (bit 15) of the value in the AX register into every bit position in the DX register. The CDQ instruction copies the sign (bit 31) of the value in the EAX register into every bit position in the EDX register. The CWD instruction can be used to produce a doubleword dividend from a word before a word division, and the CDQ instruction can be used to produce a quadword dividend from a double-word before doubleword division.
\par The CWD and CDQ mnemonics reference the same opcode. The CWD instruction is intended for use when the operand-size attribute is 16 and the CDQ instruction for when the operand-size attribute is 32. Some assemblers may force the operand size to 16 when CWD is used and to 32 when CDQ is used. Others may treat these mnemonics as synonyms (CWD/CDQ) and use the current setting of the operand-size attribute to determine the size of values to be converted, regardless of the mnemonic used.
{\page}

${\footnote CWD,Operation}
K{\footnote CWD,CWD;CDQ,CDQ;CWD,Operation;CDQ,Operation}
#{\footnote CWD::2}
#{\footnote CDQ::2}

{\fs20\b CWD/CDQ}\tab{\b Operation}\par\par
IF OperandSize = 16 (* CWD instruction *)
\par THEN DX <- SignExtend(AX);
\par ELSE (* OperandSize = 32, CDQ instruction *)
\par EDX <- SignExtend(EAX);
\par FI;
{\page}

${\footnote CWD,Flags affected}
K{\footnote CWD,CWD;CDQ,CDQ;CWD,Flags affected;CDQ,Flags affected}
#{\footnote CWD::3}
#{\footnote CDQ::3}

{\fs20\b CWD/CDQ}\tab{\b Flags affected}\par\par
None.
{\page}

${\footnote CWD,Exceptions}
K{\footnote CWD,CWD;CDQ,CDQ;CWD,Exceptions;CDQ,Exceptions}
#{\footnote CWD::4}
#{\footnote CDQ::4}

{\fs20\b CWD/CDQ}\tab{\b Exceptions}\par\par
(All Operating Modes)
\par None.
{\page}

${\footnote CWD,Opcode}
K{\footnote CWD,CWD;CDQ,CDQ;CWD,Opcode;CDQ,Opcode}
#{\footnote CWD::5}
#{\footnote CDQ::5}

{\fs20\b CWD/CDQ}\tab{\b Opcode}\par\par
99 CWD DX:AX <- sign-extend of AX
\par 99 CDQ EDX:EAX <- sign-extend of EAX
{\page}

${\footnote CPUID,Description}
K{\footnote CPUID,CPUID;CPUID,Description}
#{\footnote CPUID::1}

{\fs20\b CPUID}\tab{\b Description}\par\par
CPUID--CPU Identification
\par 
\par Provides processor identification information in registers EAX, EBX, ECX, and EDX. This information identifies Intel as the vendor, gives the family, model, and stepping of processor, feature information, and cache information. An input value loaded into the EAX register determines what information is returned.
\par The CPUID instruction can be executed at any privilege level to serialize instruction execution. Serializing instruction execution guarantees that any modifications to flags, registers, and memory for previous instructions are completed before the next instruction is fetched and executed. When the input value in register EAX is 0, the processor returns the highest value the CPUID instruction recognizes in the EAX register. A vendor identification string is returned in the EBX, EDX, and ECX registers. For Intel processors, the vendor identification string is "GenuineIntel" as follows:
\par 
\par EBX <- 756e6547h (* 'Genu', with G in the low nibble of BL *)
\par EDX <- 49656e69h (* 'ineI', with i in the low nibble of DL *)
\par ECX <- 6c65746eh (* 'ntel', with n in the low nibble of CL *)
\par 
\par Intel Architecture Compatibility
\par 
\par The CPUID instruction is not supported in early models of the Intel486 processor or in any Intel Architecture processor earlier than the Intel486 processor. The ID flag in the EFLAGS register can be used to determine if this instruction is supported. If a procedure is able to set or clear this flag, the CPUID is supported by the processor running the procedure.
{\page}

${\footnote CPUID,Operation}
K{\footnote CPUID,CPUID;CPUID,Operation}
#{\footnote CPUID::2}

{\fs20\b CPUID}\tab{\b Operation}\par\par
CASE (EAX) OF
\par EAX = 0:
\par EAX <- highest input value understood by CPUID; (* 2 for Pentium Pro processor *)
\par EBX <- Vendor identification string;
\par EDX <- Vendor identification string;
\par ECX <- Vendor identification string;
\par BREAK;
\par EAX = 1:
\par EAX[3:0] <- Stepping ID;
\par EAX[7:4] <- Model;
\par EAX[11:8] <- Family;
\par EAX[13:12] <- Processor type;
\par EAX[31:12] <- Reserved;
\par EBX <- Reserved;
{\page}

${\footnote CPUID,Flags affected}
K{\footnote CPUID,CPUID;CPUID,Flags affected}
#{\footnote CPUID::3}

{\fs20\b CPUID}\tab{\b Flags affected}\par\par
None.
{\page}

${\footnote CPUID,Exceptions}
K{\footnote CPUID,CPUID;CPUID,Exceptions}
#{\footnote CPUID::4}

{\fs20\b CPUID}\tab{\b Exceptions}\par\par
(All Operating Modes)
\par None.
{\page}

${\footnote CPUID,Opcode}
K{\footnote CPUID,CPUID;CPUID,Opcode}
#{\footnote CPUID::5}

{\fs20\b CPUID}\tab{\b Opcode}\par\par
0FA2 CPUID
{\page}

${\footnote CS:,Description}
K{\footnote CS:,CS:;CS:,Description}
#{\footnote CS:::1}

{\fs20\b CS:}\tab{\b Description}\par\par
Internal disassembler's symbol which indicates that the next command is used with the CS: segment.
{\page}

${\footnote CS:,Operation}
K{\footnote CS:,CS:;CS:,Operation}
#{\footnote CS:::2}

{\fs20\b CS:}\tab{\b Operation}\par\par
N/A
{\page}

${\footnote CS:,Flags affected}
K{\footnote CS:,CS:;CS:,Flags affected}
#{\footnote CS:::3}

{\fs20\b CS:}\tab{\b Flags affected}\par\par
N/A
{\page}

${\footnote CS:,Exceptions}
K{\footnote CS:,CS:;CS:,Exceptions}
#{\footnote CS:::4}

{\fs20\b CS:}\tab{\b Exceptions}\par\par
N/A
{\page}

${\footnote CS:,Opcode}
K{\footnote CS:,CS:;CS:,Opcode}
#{\footnote CS:::5}

{\fs20\b CS:}\tab{\b Opcode}\par\par
N/A
{\page}

${\footnote DAA,Description}
K{\footnote DAA,DAA;DAA,Description}
#{\footnote DAA::1}

{\fs20\b DAA}\tab{\b Description}\par\par
DAA: Decimal Adjust AL after Addition
\par 
\par Adjusts the sum of two packed BCD values to create a packed BCD result. The AL register is the implied source and destination operand. The DAA instruction is only useful when it follows an ADD instruction that adds (binary addition) two 2-digit, packed BCD values and stores a byte result in the AL register. The DAA instruction then adjusts the contents of the AL register to contain the correct 2-digit, packed BCD result. If a decimal carry is detected, the CF and AF flags are set accordingly.
{\page}

${\footnote DAA,Operation}
K{\footnote DAA,DAA;DAA,Operation}
#{\footnote DAA::2}

{\fs20\b DAA}\tab{\b Operation}\par\par
IF (((AL AND 0FH) > 9) or AF = 1)
\par THEN
\par AL <- AL + 6;
\par CF <- CF OR CarryFromLastAddition; (* CF OR carry from AL <- AL + 6 *)
\par AF <- 1;
\par ELSE
\par AF <- 0;
\par FI;
\par IF ((AL AND F0H) > 90H) or CF = 1)
\par THEN
\par AL <- AL + 60H;
\par CF <- 1;
\par ELSE
\par CF <- 0;
\par FI;
\par 
\par Example
\par 
\par ADD AL, BL
\par Before: AL=79H BL=35H EFLAGS(OSZAPC)=XXXXXX
\par After: AL=AEH BL=35H EFLAGS(0SZAPC)=110000
\par 
\par DAA
\par Before: AL=AEH BL=35H EFLAGS(OSZAPC)=110000
\par After: AL=14H BL=35H EFLAGS(0SZAPC)=X00111
{\page}

${\footnote DAA,Flags affected}
K{\footnote DAA,DAA;DAA,Flags affected}
#{\footnote DAA::3}

{\fs20\b DAA}\tab{\b Flags affected}\par\par
The CF and AF flags are set if the adjustment of the value results in a decimal carry in either digit of the result. The SF, ZF, and PF flags are set according to the result. The OF flag is undefined.
{\page}

${\footnote DAA,Exceptions}
K{\footnote DAA,DAA;DAA,Exceptions}
#{\footnote DAA::4}

{\fs20\b DAA}\tab{\b Exceptions}\par\par
(All Operating Modes)
\par None.
{\page}

${\footnote DAA,Opcode}
K{\footnote DAA,DAA;DAA,Opcode}
#{\footnote DAA::5}

{\fs20\b DAA}\tab{\b Opcode}\par\par
27 DAA Decimal adjust AL after addition
{\page}

${\footnote DAS,Description}
K{\footnote DAS,DAS;DAS,Description}
#{\footnote DAS::1}

{\fs20\b DAS}\tab{\b Description}\par\par
DAS: Decimal Adjust AL after Subtraction
\par 
\par Adjusts the result of the subtraction of two packed BCD values to create a packed BCD result. The AL register is the implied source and destination operand. The DAS instruction is only useful when it follows a SUB instruction that subtracts (binary subtraction) one 2-digit, packed BCD value from another and stores a byte result in the AL register. The DAS instruction then adjusts the contents of the AL register to contain the correct 2-digit, packed BCD result. If a decimal borrow is detected, the CF and AF flags are set accordingly.
{\page}

${\footnote DAS,Operation}
K{\footnote DAS,DAS;DAS,Operation}
#{\footnote DAS::2}

{\fs20\b DAS}\tab{\b Operation}\par\par
IF (AL AND 0FH) > 9 OR AF = 1
\par THEN
\par AL <- AL - 6;
\par CF <- CF OR BorrowFromLastSubtraction; (* CF OR borrow from AL <- AL - 6 *)
\par AF <- 1;
\par ELSE AF <- 0;
\par FI;
\par IF ((AL > 9FH) or CF = 1)
\par THEN
\par AL <- AL - 60H;
\par CF <- 1;
\par ELSE CF <- 0;
\par FI;
\par 
\par Example
\par 
\par SUB AL, BL
\par Before: AL=35H BL=47H EFLAGS(OSZAPC)=XXXXXX
\par After: AL=EEH BL=47H EFLAGS(0SZAPC)=010111
\par 
\par DAS
\par Before: AL=EEH BL=47H EFLAGS(OSZAPC)=010111
\par After: AL=88H BL=47H EFLAGS(0SZAPC)=X10111
{\page}

${\footnote DAS,Flags affected}
K{\footnote DAS,DAS;DAS,Flags affected}
#{\footnote DAS::3}

{\fs20\b DAS}\tab{\b Flags affected}\par\par
The CF and AF flags are set if the adjustment of the value results in a decimal borrow in either digit of the result. The SF, ZF, and PF flags are set according to the result. The OF flag is undefined.
{\page}

${\footnote DAS,Exceptions}
K{\footnote DAS,DAS;DAS,Exceptions}
#{\footnote DAS::4}

{\fs20\b DAS}\tab{\b Exceptions}\par\par
(All Operating Modes)
\par None.
{\page}

${\footnote DAS,Opcode}
K{\footnote DAS,DAS;DAS,Opcode}
#{\footnote DAS::5}

{\fs20\b DAS}\tab{\b Opcode}\par\par
2F DAS Decimal adjust AL after subtraction
{\page}

${\footnote DEC,Description}
K{\footnote DEC,DEC;DEC,Description}
#{\footnote DEC::1}

{\fs20\b DEC}\tab{\b Description}\par\par
DEC: Decrement by 1
\par 
\par Subtracts 1 from the destination operand, while preserving the state of the CF flag. The destination operand can be a register or a memory location. This instruction allows a loop counter to be updated without disturbing the CF flag. To perform a decrement operation that updates the CF flag, use a SUB instruction with an immediate operand of 1.)
{\page}

${\footnote DEC,Operation}
K{\footnote DEC,DEC;DEC,Operation}
#{\footnote DEC::2}

{\fs20\b DEC}\tab{\b Operation}\par\par
DEST <- DEST - 1;
{\page}

${\footnote DEC,Flags affected}
K{\footnote DEC,DEC;DEC,Flags affected}
#{\footnote DEC::3}

{\fs20\b DEC}\tab{\b Flags affected}\par\par
The CF flag is not affected. The OF, SF, ZF, AF, and PF flags are set according to the result.
{\page}

${\footnote DEC,Exceptions}
K{\footnote DEC,DEC;DEC,Exceptions}
#{\footnote DEC::4}

{\fs20\b DEC}\tab{\b Exceptions}\par\par
Protected Mode Exceptions
\par 
\par #GP(0) If the destination operand is located in a nonwritable segment. If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit. If the DS, ES, FS, or GS register contains a null segment selector.
\par #SS(0) If a memory operand effective address is outside the SS segment limit.
\par #PF(fault-code) If a page fault occurs.
\par #AC(0) If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.
\par 
\par Real-Address Mode Exceptions
\par 
\par #GP If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.
\par #SS If a memory operand effective address is outside the SS segment limit.
\par 
\par Virtual-8086 Mode Exceptions
\par 
\par #GP(0) If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.
\par #SS(0) If a memory operand effective address is outside the SS segment limit.
\par #PF(fault-code) If a page fault occurs.
\par #AC(0) If alignment checking is enabled and an unaligned memory reference is made.
{\page}

${\footnote DEC,Opcode}
K{\footnote DEC,DEC;DEC,Opcode}
#{\footnote DEC::5}

{\fs20\b DEC}\tab{\b Opcode}\par\par
FE /1 DEC r/m8 Decrement r/m8 by 1
\par FF /1 DEC r/m16 Decrement r/m16 by 1
\par FF /1 DEC r/m32 Decrement r/m32 by 1
\par 48+rw DEC r16 Decrement r16 by 1
\par 48+rd DEC r32 Decrement r32 by 1
{\page}

${\footnote DIV,Description}
K{\footnote DIV,DIV;DIV,Description}
#{\footnote DIV::1}

{\fs20\b DIV}\tab{\b Description}\par\par
DIV: Unsigned Divide
\par 
\par Divides (unsigned) the value in the AX register, DX:AX register pair, or EDX:EAX register pair (dividend) by the source operand (divisor) and stores the result in the AX (AH:AL), DX:AX, or EDX:EAX registers. The source operand can be a general-purpose register or a memory location.
\par The action of this instruction depends on the operand size, as shown in the following table:
\par 
\par Operand Size      Dividend Divisor Quotient Remainder [Maximum Quotient]
\par ------------------------------------------------------------------------
\par Word/byte            AX      r/m8     AL      AH             255
\par Doubleword/word     DX:AX    r/m16    AX      DX           65,535
\par Quadword/doubleword EDX:EAX  r/m32    EAX     EDX           2^32 - 1
\par 
\par Non-integral results are truncated (chopped) towards 0. The remainder is always less than the divisor in magnitude. Overflow is indicated with the #DE (divide error) exception rather than with the CF flag.
{\page}

${\footnote DIV,Operation}
K{\footnote DIV,DIV;DIV,Operation}
#{\footnote DIV::2}

{\fs20\b DIV}\tab{\b Operation}\par\par
IF SRC = 0
\par THEN #DE; (* divide error *)
\par FI;
\par IF OpernadSize = 8 (* word/byte operation *)
\par THEN
\par temp <- AX / SRC;
\par IF temp > FFH
\par THEN #DE; (* divide error *) ;
\par ELSE
\par AL <- temp;
\par AH <- AX MOD SRC;
\par FI;
\par ELSE
\par IF OperandSize = 16 (* doubleword/word operation *)
\par THEN
\par temp <- DX:AX / SRC;
\par IF temp > FFFFH
\par THEN #DE; (* divide error *) ;
\par ELSE
\par AX <- temp;
\par DX <- DX:AX MOD SRC;
\par FI;
\par ELSE (* quadword/doubleword operation *)
\par temp <- EDX:EAX / SRC;
\par IF temp > FFFFFFFFH
\par THEN #DE; (* divide error *) ;
\par ELSE
\par EAX <- temp;
\par EDX <- EDX:EAX MOD SRC;
\par FI;
\par FI;
\par FI;
{\page}

${\footnote DIV,Flags affected}
K{\footnote DIV,DIV;DIV,Flags affected}
#{\footnote DIV::3}

{\fs20\b DIV}\tab{\b Flags affected}\par\par
The CF, OF, SF, ZF, AF, and PF flags are undefined.
{\page}

${\footnote DIV,Exceptions}
K{\footnote DIV,DIV;DIV,Exceptions}
#{\footnote DIV::4}

{\fs20\b DIV}\tab{\b Exceptions}\par\par
Protected Mode Exceptions
\par 
\par #DE If the source operand (divisor) is 0. If the quotient is too large for the designated register.
\par #GP(0) If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit. If the DS, ES, FS, or GS register contains a null segment selector.
\par #SS(0) If a memory operand effective address is outside the SS segment limit.
\par #PF(fault-code) If a page fault occurs.
\par #AC(0) If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.
\par 
\par Real-Address Mode Exceptions
\par 
\par #DE If the source operand (divisor) is 0. If the quotient is too large for the designated register.
\par #GP If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit. If the DS, ES, FS, or GS register contains a null segment selector.
\par #SS(0) If a memory operand effective address is outside the SS segment limit.
\par 
\par Virtual-8086 Mode Exceptions
\par 
\par #DE If the source operand (divisor) is 0. If the quotient is too large for the designated register.
\par #GP(0) If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.
\par #SS If a memory operand effective address is outside the SS segment limit.
\par #PF(fault-code) If a page fault occurs.
\par #AC(0) If alignment checking is enabled and an unaligned memory reference is made.
{\page}

${\footnote DIV,Opcode}
K{\footnote DIV,DIV;DIV,Opcode}
#{\footnote DIV::5}

{\fs20\b DIV}\tab{\b Opcode}\par\par
F6 /6 DIV r/m8 Unsigned divide AX by r/m8; AL <- Quotient, AH <- Remainder
\par F7 /6 DIV r/m16 Unsigned divide DX:AX by r/m16; AX <- Quotient, DX <- Remainder
\par F7 /6 DIV r/m32 Unsigned divide EDX:EAX by r/m32 doubleword; EAX <- Quotient, EDX <- Remainder
{\page}

${\footnote DS:,Description}
K{\footnote DS:,DS:;DS:,Description}
#{\footnote DS:::1}

{\fs20\b DS:}\tab{\b Description}\par\par
Internal disassembler's symbol which indicates that the next command is used with the DS: segment.
{\page}

${\footnote DS:,Operation}
K{\footnote DS:,DS:;DS:,Operation}
#{\footnote DS:::2}

{\fs20\b DS:}\tab{\b Operation}\par\par
N/A
{\page}

${\footnote DS:,Flags affected}
K{\footnote DS:,DS:;DS:,Flags affected}
#{\footnote DS:::3}

{\fs20\b DS:}\tab{\b Flags affected}\par\par
N/A
{\page}

${\footnote DS:,Exceptions}
K{\footnote DS:,DS:;DS:,Exceptions}
#{\footnote DS:::4}

{\fs20\b DS:}\tab{\b Exceptions}\par\par
N/A
{\page}

${\footnote DS:,Opcode}
K{\footnote DS:,DS:;DS:,Opcode}
#{\footnote DS:::5}

{\fs20\b DS:}\tab{\b Opcode}\par\par
N/A
{\page}

${\footnote EMMS,Description}
K{\footnote EMMS,EMMS;EMMS,Description}
#{\footnote EMMS::1}

{\fs20\b EMMS}\tab{\b Description}\par\par
EMMS: Empty MMX(tm) State
\par 
\par Sets the values of all the tags in the FPU tag word to empty (all ones). This operation marks the MMX registers as available, so they can subsequently be used by floating-point instructions. All other MMX instructions (other than the EMMS instruction) set all the tags in FPU tag word to valid (all zeros).
\par The EMMS instruction must be used to clear the MMX state at the end of all MMX routines and before calling other procedures or subroutines that may execute floating-point instructions. If a floating-point instruction loads one of the registers in the FPU register stack before the FPU tag word has been reset by the EMMS instruction, a floating-point stack overflow can occur that will result in a floating-point exception or incorrect result.
{\page}

${\footnote EMMS,Operation}
K{\footnote EMMS,EMMS;EMMS,Operation}
#{\footnote EMMS::2}

{\fs20\b EMMS}\tab{\b Operation}\par\par
FPUTagWord <- FFFFH;
{\page}

${\footnote EMMS,Flags affected}
K{\footnote EMMS,EMMS;EMMS,Flags affected}
#{\footnote EMMS::3}

{\fs20\b EMMS}\tab{\b Flags affected}\par\par
None.
{\page}

${\footnote EMMS,Exceptions}
K{\footnote EMMS,EMMS;EMMS,Exceptions}
#{\footnote EMMS::4}

{\fs20\b EMMS}\tab{\b Exceptions}\par\par
Protected Mode Exceptions
\par 
\par #UD If EM in CR0 is set.
\par #NM If TS in CR0 is set.
\par #MF If there is a pending FPU exception.
\par 
\par Real-Address Mode Exceptions
\par 
\par #UD If EM in CR0 is set.
\par #NM If TS in CR0 is set.
\par #MF If there is a pending FPU exception.
\par 
\par Virtual-8086 Mode Exceptions
\par 
\par #UD If EM in CR0 is set.
\par #NM If TS in CR0 is set.
\par #MF If there is a pending FPU exception.
\par 
{\page}

${\footnote EMMS,Opcode}
K{\footnote EMMS,EMMS;EMMS,Opcode}
#{\footnote EMMS::5}

{\fs20\b EMMS}\tab{\b Opcode}\par\par
0F 77 EMMS Set the FP tag word to empty.
{\page}

${\footnote ENTER,Description}
K{\footnote ENTER,ENTER;ENTER,Description}
#{\footnote ENTER::1}

{\fs20\b ENTER}\tab{\b Description}\par\par
ENTER: Make Stack Frame for Procedure Parameters
\par 
\par Creates a stack frame for a procedure. The first operand (size operand) specifies the size of the stack frame (that is, the number of bytes of dynamic storage allocated on the stack for the procedure). The second operand (nesting level operand) gives the lexical nesting level (0 to 31) of the procedure. The nesting level determines the number of stack frame pointers that are copied into the "display area" of the new stack frame from the preceding frame. Both of these operands are immediate values.
\par The stack-size attribute determines whether the BP (16 bits) or EBP (32 bits) register specifies the current frame pointer and whether SP (16 bits) or ESP (32 bits) specifies the stack pointer. The ENTER and companion LEAVE instructions are provided to support block structured languages. The ENTER instruction (when used) is typically the first instruction in a procedure and is used to set up a new stack frame for a procedure. The LEAVE instruction is then used at the end of the procedure (just before the RET instruction) to release the stack frame. If the nesting level is 0, the processor pushes the frame pointer from the EBP register onto the stack, copies the current stack pointer from the ESP register into the EBP register, and loads the ESP register with the current stack-pointer value minus the value in the size operand. For nesting levels of 1 or greater, the processor pushes additional frame pointers on the stack before adjusting the stack pointer. These additional frame pointers provide the called procedure with access points to other nested frames on the stack.
{\page}

${\footnote ENTER,Operation}
K{\footnote ENTER,ENTER;ENTER,Operation}
#{\footnote ENTER::2}

{\fs20\b ENTER}\tab{\b Operation}\par\par
NestingLevel <- NestingLevel MOD 32
\par IF StackSize = 32
\par THEN
\par Push(EBP) ;
\par FrameTemp <- ESP;
\par ELSE (* StackSize = 16*)
\par Push(BP);
\par FrameTemp <- SP;
\par FI;
\par IF NestingLevel = 0
\par THEN GOTO CONTINUE;
\par FI;
\par IF (NestingLevel > 0)
\par FOR i <- 1 TO (NestingLevel - 1)
\par DO
\par IF OperandSize = 32
\par THEN
\par IF StackSize = 32
\par EBP <- EBP - 4;
\par Push([EBP]); (* doubleword push *)
\par ELSE (* StackSize = 16*)
\par BP <- BP - 4;
\par Push([BP]); (* doubleword push *)
\par FI;
\par ELSE (* OperandSize = 16 *)
\par IF StackSize = 32
\par THEN
\par EBP <- EBP - 2;
\par Push([EBP]); (* word push *)
\par ELSE (* StackSize = 16*)
\par BP <- BP - 2;
\par Push([BP]); (* word push *)
\par FI;
\par FI;
\par OD;
\par IF OperandSize = 32
\par THEN
\par Push(FrameTemp); (* doubleword push *)
\par ELSE (* OperandSize = 16 *)
\par Push(FrameTemp); (* word push *)
\par FI;
\par GOTO CONTINUE;
\par FI;
\par CONTINUE:
\par IF StackSize = 32
\par THEN
\par EBP <- FrameTemp
\par ESP <- EBP - Size;
\par ELSE (* StackSize = 16*)
\par BP <- FrameTemp
\par SP <- BP - Size;
\par FI;
\par END;
{\page}

${\footnote ENTER,Flags affected}
K{\footnote ENTER,ENTER;ENTER,Flags affected}
#{\footnote ENTER::3}

{\fs20\b ENTER}\tab{\b Flags affected}\par\par
None.
{\page}

${\footnote ENTER,Exceptions}
K{\footnote ENTER,ENTER;ENTER,Exceptions}
#{\footnote ENTER::4}

{\fs20\b ENTER}\tab{\b Exceptions}\par\par
Protected Mode Exceptions
\par 
\par #SS(0) If the new value of the SP or ESP register is outside the stack segment limit.
\par #PF(fault-code) If a page fault occurs.
\par 
\par Real-Address Mode Exceptions
\par 
\par #SS(0) If the new value of the SP or ESP register is outside the stack segment limit.
\par 
\par Virtual-8086 Mode Exceptions
\par 
\par #SS(0) If the new value of the SP or ESP register is outside the stack segment limit.
\par #PF(fault-code) If a page fault occurs.
{\page}

${\footnote ENTER,Opcode}
K{\footnote ENTER,ENTER;ENTER,Opcode}
#{\footnote ENTER::5}

{\fs20\b ENTER}\tab{\b Opcode}\par\par
C8 iw 00 ENTER imm16,0 Create a stack frame for a procedure
\par C8 iw 01 ENTER imm16,1 Create a nested stack frame for a procedure
\par C8 iw ib ENTER imm16,imm8 Create a nested stack frame for a procedure
{\page}

${\footnote ES:,Description}
K{\footnote ES:,ES:;ES:,Description}
#{\footnote ES:::1}

{\fs20\b ES:}\tab{\b Description}\par\par
Internal disassembler's symbol which indicates that the next command is used with the ES: segment.
{\page}

${\footnote ES:,Operation}
K{\footnote ES:,ES:;ES:,Operation}
#{\footnote ES:::2}

{\fs20\b ES:}\tab{\b Operation}\par\par
N/A
{\page}

${\footnote ES:,Flags affected}
K{\footnote ES:,ES:;ES:,Flags affected}
#{\footnote ES:::3}

{\fs20\b ES:}\tab{\b Flags affected}\par\par
N/A
{\page}

${\footnote ES:,Exceptions}
K{\footnote ES:,ES:;ES:,Exceptions}
#{\footnote ES:::4}

{\fs20\b ES:}\tab{\b Exceptions}\par\par
N/A
{\page}

${\footnote ES:,Opcode}
K{\footnote ES:,ES:;ES:,Opcode}
#{\footnote ES:::5}

{\fs20\b ES:}\tab{\b Opcode}\par\par
N/A
{\page}

${\footnote F2XM1,Description}
K{\footnote F2XM1,F2XM1;F2XM1,Description}
#{\footnote F2XM1::1}

{\fs20\b F2XM1}\tab{\b Description}\par\par
F2XM1: Compute 2^x -1
\par 
\par Calculates the exponential value of 2 to the power of the source operand minus 1. The source operand is located in register ST(0) and the result is also stored in ST(0). The value of the source operand must lie in the range -1.0 to +1.0. If the source value is outside this range, the result is undefined.
{\page}

${\footnote F2XM1,Operation}
K{\footnote F2XM1,F2XM1;F2XM1,Operation}
#{\footnote F2XM1::2}

{\fs20\b F2XM1}\tab{\b Operation}\par\par
ST(0) <- (2 ST(0) - 1);
{\page}

${\footnote F2XM1,Flags affected}
K{\footnote F2XM1,F2XM1;F2XM1,Flags affected}
#{\footnote F2XM1::3}

{\fs20\b F2XM1}\tab{\b Flags affected}\par\par
FPU Flags Affected
\par 
\par C1 Set to 0 if stack underflow occurred. Indicates rounding direction if the inexact-result exception (#P) is generated: 0 = not roundup; 1 = roundup. C0, C2, C3 Undefined.
{\page}

${\footnote F2XM1,Exceptions}
K{\footnote F2XM1,F2XM1;F2XM1,Exceptions}
#{\footnote F2XM1::4}

{\fs20\b F2XM1}\tab{\b Exceptions}\par\par
Floating-Point Exceptions
\par 
\par #IS Stack underflow occurred.
\par #IA Source operand is an SNaN value or unsupported format.
\par #D Result is a denormal value.
\par #U Result is too small for destination format.
\par #P Value cannot be represented exactly in destination format.
\par 
\par Protected Mode Exceptions
\par 
\par #NM EM or TS in CR0 is set.
\par 
\par Real-Address Mode Exceptions
\par 
\par #NM EM or TS in CR0 is set.
\par 
\par Virtual-8086 Mode Exceptions
\par 
\par #NM EM or TS in CR0 is set.
{\page}

${\footnote F2XM1,Opcode}
K{\footnote F2XM1,F2XM1;F2XM1,Opcode}
#{\footnote F2XM1::5}

{\fs20\b F2XM1}\tab{\b Opcode}\par\par
D9 F0 F2XM1 Replace ST(0) with (2^ST(0) - 1)
{\page}

${\footnote FABS,Description}
K{\footnote FABS,FABS;FABS,Description}
#{\footnote FABS::1}

{\fs20\b FABS}\tab{\b Description}\par\par
FABS: Absolute Value
\par 
\par Clears the sign bit of ST(0) to create the absolute value of the operand.
{\page}

${\footnote FABS,Operation}
K{\footnote FABS,FABS;FABS,Operation}
#{\footnote FABS::2}

{\fs20\b FABS}\tab{\b Operation}\par\par
ST(0) <- |ST(0)|
{\page}

${\footnote FABS,Flags affected}
K{\footnote FABS,FABS;FABS,Flags affected}
#{\footnote FABS::3}

{\fs20\b FABS}\tab{\b Flags affected}\par\par
C1 Set to 0 if stack underflow occurred; otherwise, cleared to 0. C0, C2, C3 Undefined.
{\page}

${\footnote FABS,Exceptions}
K{\footnote FABS,FABS;FABS,Exceptions}
#{\footnote FABS::4}

{\fs20\b FABS}\tab{\b Exceptions}\par\par
Floating-Point Exceptions
\par 
\par #IS Stack underflow occurred.
\par 
\par Protected Mode Exceptions
\par 
\par #NM EM or TS in CR0 is set.
\par 
\par Real-Address Mode Exceptions
\par 
\par #NM EM or TS in CR0 is set.
\par 
\par Virtual-8086 Mode Exceptions
\par 
\par #NM EM or TS in CR0 is set.
{\page}

${\footnote FABS,Opcode}
K{\footnote FABS,FABS;FABS,Opcode}
#{\footnote FABS::5}

{\fs20\b FABS}\tab{\b Opcode}\par\par
D9 E1 FABS Replace ST with its absolute value.
{\page}

${\footnote FADD,Description}
K{\footnote FADD,FADD;FADDP,FADDP;FIADD,FIADD;FADD,Description;FADDP,Description;FIADD,Description}
#{\footnote FADD::1}
#{\footnote FADDP::1}
#{\footnote FIADD::1}

{\fs20\b FADD/FADDP/FIADD}\tab{\b Description}\par\par
FADD/FADDP/FIADD: Add
\par 
\par Adds the destination and source operands and stores the sum in the destination location. The destination operand is always an FPU register; the source operand can be a register or a memory location. Source operands in memory can be in single-real, double-real, word-integer, or short-integer formats.
\par The no-operand version of the instruction adds the contents of the ST(0) register to the ST(1) register. The one-operand version adds the contents of a memory location (either a real or an integer value) to the contents of the ST(0) register. The two-operand version, adds the contents of the ST(0) register to the ST(i) register or vice versa. The value in ST(0) can be doubled by coding: FADD ST(0), ST(0);
\par The FADDP instructions perform the additional operation of popping the FPU register stack after storing the result. To pop the register stack, the processor marks the ST(0) register as empty and increments the stack pointer (TOP) by 1. (The no-operand version of the floating-point add instructions always results in the register stack being popped. In some assemblers, the mnemonic for this instruction is FADD rather than FADDP.)
\par The FIADD instructions convert an integer source operand to extended-real format before performing the addition.
\par When the sum of two operands with opposite signs is 0, the result is +0, except for the round toward -(infinity) mode, in which case the result is -0. When the source operand is an integer 0, it is treated as a +0. When both operand are infinities of the same sign, the result is (infinity) of the expected sign. If both operands are infinities of opposite signs, an invalid-operation exception is generated.
{\page}

${\footnote FADD,Operation}
K{\footnote FADD,FADD;FADDP,FADDP;FIADD,FIADD;FADD,Operation;FADDP,Operation;FIADD,Operation}
#{\footnote FADD::2}
#{\footnote FADDP::2}
#{\footnote FIADD::2}

{\fs20\b FADD/FADDP/FIADD}\tab{\b Operation}\par\par
IF instruction is FIADD
\par THEN
\par DEST <- DEST + ConvertExtendedReal(SRC);
\par ELSE (* source operand is real number *)
\par DEST <- DEST + SRC;
\par FI;
\par IF instruction = FADDP
\par THEN
\par PopRegisterStack;
\par FI;
{\page}

${\footnote FADD,Flags affected}
K{\footnote FADD,FADD;FADDP,FADDP;FIADD,FIADD;FADD,Flags affected;FADDP,Flags affected;FIADD,Flags affected}
#{\footnote FADD::3}
#{\footnote FADDP::3}
#{\footnote FIADD::3}

{\fs20\b FADD/FADDP/FIADD}\tab{\b Flags affected}\par\par
FPU Flags Affected
\par 
\par C1 Set to 0 if stack underflow occurred. Indicates rounding direction if the inexact-result exception (#P) is generated: 0 = not roundup; 1 = roundup. C0, C2, C3 Undefined.
{\page}

${\footnote FADD,Exceptions}
K{\footnote FADD,FADD;FADDP,FADDP;FIADD,FIADD;FADD,Exceptions;FADDP,Exceptions;FIADD,Exceptions}
#{\footnote FADD::4}
#{\footnote FADDP::4}
#{\footnote FIADD::4}

{\fs20\b FADD/FADDP/FIADD}\tab{\b Exceptions}\par\par
Floating-Point Exceptions
\par 
\par #IS Stack underflow occurred.
\par #IA Operand is an SNaN value or unsupported format. Operands are infinities of unlike sign.
\par #D Result is a denormal value.
\par #U Result is too small for destination format.
\par #O Result is too large for destination format.
\par #P Value cannot be represented exactly in destination format.
\par 
\par Protected Mode Exceptions
\par 
\par #GP(0) If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit. If the DS, ES, FS, or GS register contains a null segment selector.
\par #SS(0) If a memory operand effective address is outside the SS segment limit.
\par #NM EM or TS in CR0 is set.
\par #PF(fault-code) If a page fault occurs.
\par #AC(0) If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.
\par 
\par Real-Address Mode Exceptions
\par 
\par #GP If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.
\par #SS If a memory operand effective address is outside the SS segment limit.
\par #NM EM or TS in CR0 is set.
\par 
\par Virtual-8086 Mode Exceptions
\par 
\par #GP(0) If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.
\par #SS(0) If a memory operand effective address is outside the SS segment limit.
\par #NM EM or TS in CR0 is set.
\par #PF(fault-code) If a page fault occurs.
\par #AC(0) If alignment checking is enabled and an unaligned memory reference is made.
{\page}

${\footnote FADD,Opcode}
K{\footnote FADD,FADD;FADDP,FADDP;FIADD,FIADD;FADD,Opcode;FADDP,Opcode;FIADD,Opcode}
#{\footnote FADD::5}
#{\footnote FADDP::5}
#{\footnote FIADD::5}

{\fs20\b FADD/FADDP/FIADD}\tab{\b Opcode}\par\par
D8 /0 FADD m32 real Add m32real to ST(0) and store result in ST(0)
\par DC /0 FADD m64real Add m64real to ST(0) and store result in ST(0)
\par D8 C0+i FADD ST(0), ST(i) Add ST(0) to ST(i) and store result in ST(0)
\par DC C0+i FADD ST(i), ST(0) Add ST(i) to ST(0) and store result in ST(i)
\par DE C0+i FADDP ST(i), ST(0) Add ST(0) to ST(i), store result in ST(i), and pop the register stack
\par DE C1 FADDP Add ST(0) to ST(1), store result in ST(1), and pop the register stack
\par DA /0 FIADD m32int Add m32int to ST(0) and store result in ST(0)
\par DE /0 FIADD m16int Add m16int to ST(0) and store result in ST(0)
{\page}

${\footnote FBLD,Description}
K{\footnote FBLD,FBLD;FBLD,Description}
#{\footnote FBLD::1}

{\fs20\b FBLD}\tab{\b Description}\par\par
FBLD: Load Binary Coded Decimal
\par 
\par Converts the BCD source operand into extended-real format and pushes the value onto the FPU stack. The source operand is loaded without rounding errors. The sign of the source operand is preserved, including that of -0. The packed BCD digits are assumed to be in the range 0 through 9; the instruction does not check for invalid digits (AH through FH). Attempting to load an invalid encoding produces an undefined result.
{\page}

${\footnote FBLD,Operation}
K{\footnote FBLD,FBLD;FBLD,Operation}
#{\footnote FBLD::2}

{\fs20\b FBLD}\tab{\b Operation}\par\par
TOP <- TOP - 1;
\par ST(0) <- ExtendedReal(SRC);
{\page}

${\footnote FBLD,Flags affected}
K{\footnote FBLD,FBLD;FBLD,Flags affected}
#{\footnote FBLD::3}

{\fs20\b FBLD}\tab{\b Flags affected}\par\par
FPU Flags Affected
\par 
\par C1 Set to 1 if stack overflow occurred; otherwise, cleared to 0. C0, C2, C3 Undefined.
{\page}

${\footnote FBLD,Exceptions}
K{\footnote FBLD,FBLD;FBLD,Exceptions}
#{\footnote FBLD::4}

{\fs20\b FBLD}\tab{\b Exceptions}\par\par
Floating-Point Exceptions
\par 
\par #IS Stack overflow occurred.
\par 
\par Protected Mode Exceptions
\par 
\par #GP(0) If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit. If the DS, ES, FS, or GS register contains a null segment selector.
\par #SS(0) If a memory operand effective address is outside the SS segment limit.
\par #NM EM or TS in CR0 is set.
\par #PF(fault-code) If a page fault occurs.
\par #AC(0) If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.
\par 
\par Real-Address Mode Exceptions
\par 
\par #GP If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.
\par #SS If a memory operand effective address is outside the SS segment limit.
\par #NM EM or TS in CR0 is set.
\par 
\par Virtual-8086 Mode Exceptions
\par 
\par #GP(0) If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.
\par #SS(0) If a memory operand effective address is outside the SS segment limit.
\par #NM EM or TS in CR0 is set.
\par #PF(fault-code) If a page fault occurs.
\par #AC(0) If alignment checking is enabled and an unaligned memory reference is made.
{\page}

${\footnote FBLD,Opcode}
K{\footnote FBLD,FBLD;FBLD,Opcode}
#{\footnote FBLD::5}

{\fs20\b FBLD}\tab{\b Opcode}\par\par
DF /4 FBLD m80 dec Convert BCD value to real and push onto the FPU stack.
{\page}

${\footnote FBSTP,Description}
K{\footnote FBSTP,FBSTP;FBSTP,Description}
#{\footnote FBSTP::1}

{\fs20\b FBSTP}\tab{\b Description}\par\par
FBSTP: Store BCD Integer and Pop
\par 
\par Converts the value in the ST(0) register to an 18-digit packed BCD integer, stores the result in the destination operand, and pops the register stack. If the source value is a non-integral value, it is rounded to an integer value, according to rounding mode specified by the RC field of the FPU control word. To pop the register stack, the processor marks the ST(0) register as empty and increments the stack pointer (TOP) by 1.
\par The destination operand specifies the address where the first byte destination value is to be stored. The BCD value (including its sign bit) requires 10 bytes of space in memory. If the source value is too large for the destination format and the invalid-operation exception is not masked, an invalid-operation exception is generated and no value is stored in the destination operand. If the invalid-operation exception is masked, the packed BCD indefinite value is stored in memory. If the source value is a quiet NaN, an invalid-operation exception is generated. Quiet NaNs do not normally cause this exception to be generated.
{\page}

${\footnote FBSTP,Operation}
K{\footnote FBSTP,FBSTP;FBSTP,Operation}
#{\footnote FBSTP::2}

{\fs20\b FBSTP}\tab{\b Operation}\par\par
DEST <- BCD(ST(0));
\par PopRegisterStack;
{\page}

${\footnote FBSTP,Flags affected}
K{\footnote FBSTP,FBSTP;FBSTP,Flags affected}
#{\footnote FBSTP::3}

{\fs20\b FBSTP}\tab{\b Flags affected}\par\par
FPU Flags Affected
\par 
\par C1 Set to 0 if stack underflow occurred. Indicates rounding direction if the inexact exception (#P) is generated: 0 = not roundup; 1 = roundup. C0, C2, C3 Undefined.
{\page}

${\footnote FBSTP,Exceptions}
K{\footnote FBSTP,FBSTP;FBSTP,Exceptions}
#{\footnote FBSTP::4}

{\fs20\b FBSTP}\tab{\b Exceptions}\par\par
Floating-Point Exceptions
\par 
\par #IS Stack underflow occurred.
\par #IA Source operand is empty; contains a NaN, (infinity), or unsupported format; or contains value that exceeds 18 BCD digits in length.
\par #P Value cannot be represented exactly in destination format.
\par 
\par Protected Mode Exceptions
\par 
\par #GP(0) If a segment register is being loaded with a segment selector that points to a nonwritable segment. If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit. If the DS, ES, FS, or GS register contains a null segment selector.
\par #SS(0) If a memory operand effective address is outside the SS segment limit.
\par #NM EM or TS in CR0 is set.
\par #PF(fault-code) If a page fault occurs.
\par #AC(0) If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.
\par 
\par Real-Address Mode Exceptions
\par 
\par #GP If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.
\par #SS If a memory operand effective address is outside the SS segment limit.
\par #NM EM or TS in CR0 is set.
\par 
\par Virtual-8086 Mode Exceptions
\par 
\par #GP(0) If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.
\par #SS(0) If a memory operand effective address is outside the SS segment limit.
\par #NM EM or TS in CR0 is set.
\par #PF(fault-code) If a page fault occurs.
\par #AC(0) If alignment checking is enabled and an unaligned memory reference is made.
{\page}

${\footnote FBSTP,Opcode}
K{\footnote FBSTP,FBSTP;FBSTP,Opcode}
#{\footnote FBSTP::5}

{\fs20\b FBSTP}\tab{\b Opcode}\par\par
DF /6 FBSTP m80bcd Store ST(0) in m80bcd and pop ST(0).
{\page}

${\footnote FCHS,Description}
K{\footnote FCHS,FCHS;FCHS,Description}
#{\footnote FCHS::1}

{\fs20\b FCHS}\tab{\b Description}\par\par
FCHS: Change Sign
\par 
\par Complements the sign bit of ST(0). This operation changes a positive value into a negative value of equal magnitude or vice versa.
{\page}

${\footnote FCHS,Operation}
K{\footnote FCHS,FCHS;FCHS,Operation}
#{\footnote FCHS::2}

{\fs20\b FCHS}\tab{\b Operation}\par\par
SignBit(ST(0)) <- NOT (SignBit(ST(0)))
{\page}

${\footnote FCHS,Flags affected}
K{\footnote FCHS,FCHS;FCHS,Flags affected}
#{\footnote FCHS::3}

{\fs20\b FCHS}\tab{\b Flags affected}\par\par
FPU Flags Affected
\par 
\par C1 Set to 0 if stack underflow occurred; otherwise, cleared to 0. C0, C2, C3 Undefined.
{\page}

${\footnote FCHS,Exceptions}
K{\footnote FCHS,FCHS;FCHS,Exceptions}
#{\footnote FCHS::4}

{\fs20\b FCHS}\tab{\b Exceptions}\par\par
Floating-Point Exceptions
\par 
\par #IS Stack underflow occurred.
\par 
\par Protected Mode Exceptions
\par 
\par #NM EM or TS in CR0 is set.
\par 
\par Real-Address Mode Exceptions
\par 
\par #NM EM or TS in CR0 is set.
\par 
\par Virtual-8086 Mode Exceptions
\par 
\par #NM EM or TS in CR0 is set.
{\page}

${\footnote FCHS,Opcode}
K{\footnote FCHS,FCHS;FCHS,Opcode}
#{\footnote FCHS::5}

{\fs20\b FCHS}\tab{\b Opcode}\par\par
D9 E0 FCHS Complements sign of ST(0)
{\page}

${\footnote FCLEX,Description}
K{\footnote FCLEX,FCLEX;FNCLEX,FNCLEX;FCLEX,Description;FNCLEX,Description}
#{\footnote FCLEX::1}
#{\footnote FNCLEX::1}

{\fs20\b FCLEX/FNCLEX}\tab{\b Description}\par\par
FCLEX/FNCLEX: Clear Exceptions
\par 
\par Clears the floating-point exception flags (PE, UE, OE, ZE, DE, and IE), the exception summary status flag (ES), the stack fault flag (SF), and the busy flag (B) in the FPU status word. The FCLEX instruction checks for and handles any pending unmasked floating-point exceptions before clearing the exception flags; the FNCLEX instruction does not.
\par 
\par Intel Architecture Compatibility
\par 
\par When operating a Pentium or Intel486 processor in MS-DOS compatibility mode, it is possible (under unusual circumstances) for an FNCLEX instruction to be interrupted prior to being executed to handle a pending FPU exception. An FNCLEX instruction cannot be interrupted in this way on a Pentium Pro processor.
{\page}

${\footnote FCLEX,Operation}
K{\footnote FCLEX,FCLEX;FNCLEX,FNCLEX;FCLEX,Operation;FNCLEX,Operation}
#{\footnote FCLEX::2}
#{\footnote FNCLEX::2}

{\fs20\b FCLEX/FNCLEX}\tab{\b Operation}\par\par
FPUStatusWord[0..7] <- 0;
\par FPUStatusWord[15] <- 0;
{\page}

${\footnote FCLEX,Flags affected}
K{\footnote FCLEX,FCLEX;FNCLEX,FNCLEX;FCLEX,Flags affected;FNCLEX,Flags affected}
#{\footnote FCLEX::3}
#{\footnote FNCLEX::3}

{\fs20\b FCLEX/FNCLEX}\tab{\b Flags affected}\par\par
FPU Flags Affected
\par 
\par The PE, UE, OE, ZE, DE, IE, ES, SF, and B flags in the FPU status word are cleared. The C0, C1, C2, and C3 flags are undefined.
{\page}

${\footnote FCLEX,Exceptions}
K{\footnote FCLEX,FCLEX;FNCLEX,FNCLEX;FCLEX,Exceptions;FNCLEX,Exceptions}
#{\footnote FCLEX::4}
#{\footnote FNCLEX::4}

{\fs20\b FCLEX/FNCLEX}\tab{\b Exceptions}\par\par
Floating-Point Exceptions
\par 
\par None.
\par 
\par Protected Mode Exceptions
\par 
\par #NM EM or TS in CR0 is set.
\par 
\par Real-Address Mode Exceptions
\par 
\par #NM EM or TS in CR0 is set.
\par 
\par Virtual-8086 Mode Exceptions
\par 
\par #NM EM or TS in CR0 is set.
{\page}

${\footnote FCLEX,Opcode}
K{\footnote FCLEX,FCLEX;FNCLEX,FNCLEX;FCLEX,Opcode;FNCLEX,Opcode}
#{\footnote FCLEX::5}
#{\footnote FNCLEX::5}

{\fs20\b FCLEX/FNCLEX}\tab{\b Opcode}\par\par
9B DB E2 FCLEX Clear floating-point exception flags after checking for pending unmasked floating-point exceptions.
\par DB E2 FNCLEX Clear floating-point exception flags without checking for pending unmasked floating-point exceptions.
{\page}

${\footnote FCMOVB,Description}
K{\footnote FCMOVB,FCMOVB;FCMOVE,FCMOVE;FCMOVBE,FCMOVBE;FCMOVU,FCMOVU;FCMOVNB,FCMOVNB;FCMOVNE,FCMOVNE;FCMOVNBE,FCMOVNBE;FCMOVNU,FCMOVNU;FCMOVB,Description;FCMOVE,Description;FCMOVBE,Description;FCMOVU,Description;FCMOVNB,Description;FCMOVNE,Description;FCMOVNBE,Description;FCMOVNU,Description}
#{\footnote FCMOVB::1}
#{\footnote FCMOVE::1}
#{\footnote FCMOVBE::1}
#{\footnote FCMOVU::1}
#{\footnote FCMOVNB::1}
#{\footnote FCMOVNE::1}
#{\footnote FCMOVNBE::1}
#{\footnote FCMOVNU::1}

{\fs20\b FCMOVB/FCMOVE/FCMOVBE/FCMOVU/FCMOVNB/FCMOVNE/FCMOVNBE/FCMOVNU}\tab{\b Description}\par\par
FCMOV cc: Floating-Point Conditional Move
\par 
\par Tests the status flags in the EFLAGS register and moves the source operand (second operand) to the destination operand (first operand) if the given test condition is true. The source operand is always in the ST(i) register and the destination operand is always ST(0). The FCMOVcc instructions are useful for optimizing small IF constructions. They also help eliminate branching overhead for IF operations and the possibility of branch mispredictions by the processor. A processor may not support the FCMOVcc instructions. Software can check if the FCMOVcc instructions are supported by checking the processor's feature information with the CPUID instruction. If both the CMOV and FPU feature bits are set, the FCMOVcc instructions are supported.
\par 
\par Intel Architecture Compatibility
\par 
\par The FCMOVcc instructions were introduced to the Intel Architecture in the Pentium Pro processor family and is not available in earlier Intel Architecture processors.
{\page}

${\footnote FCMOVB,Operation}
K{\footnote FCMOVB,FCMOVB;FCMOVE,FCMOVE;FCMOVBE,FCMOVBE;FCMOVU,FCMOVU;FCMOVNB,FCMOVNB;FCMOVNE,FCMOVNE;FCMOVNBE,FCMOVNBE;FCMOVNU,FCMOVNU;FCMOVB,Operation;FCMOVE,Operation;FCMOVBE,Operation;FCMOVU,Operation;FCMOVNB,Operation;FCMOVNE,Operation;FCMOVNBE,Operation;FCMOVNU,Operation}
#{\footnote FCMOVB::2}
#{\footnote FCMOVE::2}
#{\footnote FCMOVBE::2}
#{\footnote FCMOVU::2}
#{\footnote FCMOVNB::2}
#{\footnote FCMOVNE::2}
#{\footnote FCMOVNBE::2}
#{\footnote FCMOVNU::2}

{\fs20\b FCMOVB/FCMOVE/FCMOVBE/FCMOVU/FCMOVNB/FCMOVNE/FCMOVNBE/FCMOVNU}\tab{\b Operation}\par\par
IF condition TRUE
\par ST(0) <- ST(i)
\par FI;
{\page}

${\footnote FCMOVB,Flags affected}
K{\footnote FCMOVB,FCMOVB;FCMOVE,FCMOVE;FCMOVBE,FCMOVBE;FCMOVU,FCMOVU;FCMOVNB,FCMOVNB;FCMOVNE,FCMOVNE;FCMOVNBE,FCMOVNBE;FCMOVNU,FCMOVNU;FCMOVB,Flags affected;FCMOVE,Flags affected;FCMOVBE,Flags affected;FCMOVU,Flags affected;FCMOVNB,Flags affected;FCMOVNE,Flags affected;FCMOVNBE,Flags affected;FCMOVNU,Flags affected}
#{\footnote FCMOVB::3}
#{\footnote FCMOVE::3}
#{\footnote FCMOVBE::3}
#{\footnote FCMOVU::3}
#{\footnote FCMOVNB::3}
#{\footnote FCMOVNE::3}
#{\footnote FCMOVNBE::3}
#{\footnote FCMOVNU::3}

{\fs20\b FCMOVB/FCMOVE/FCMOVBE/FCMOVU/FCMOVNB/FCMOVNE/FCMOVNBE/FCMOVNU}\tab{\b Flags affected}\par\par
FPU Flags Affected
\par 
\par C1 Set to 0 if stack underflow occurred. C0, C2, C3 Undefined.
{\page}

${\footnote FCMOVB,Exceptions}
K{\footnote FCMOVB,FCMOVB;FCMOVE,FCMOVE;FCMOVBE,FCMOVBE;FCMOVU,FCMOVU;FCMOVNB,FCMOVNB;FCMOVNE,FCMOVNE;FCMOVNBE,FCMOVNBE;FCMOVNU,FCMOVNU;FCMOVB,Exceptions;FCMOVE,Exceptions;FCMOVBE,Exceptions;FCMOVU,Exceptions;FCMOVNB,Exceptions;FCMOVNE,Exceptions;FCMOVNBE,Exceptions;FCMOVNU,Exceptions}
#{\footnote FCMOVB::4}
#{\footnote FCMOVE::4}
#{\footnote FCMOVBE::4}
#{\footnote FCMOVU::4}
#{\footnote FCMOVNB::4}
#{\footnote FCMOVNE::4}
#{\footnote FCMOVNBE::4}
#{\footnote FCMOVNU::4}

{\fs20\b FCMOVB/FCMOVE/FCMOVBE/FCMOVU/FCMOVNB/FCMOVNE/FCMOVNBE/FCMOVNU}\tab{\b Exceptions}\par\par
Floating-Point Exceptions
\par 
\par #IS Stack underflow occurred.
\par 
\par Integer Flags Affected
\par 
\par None.
\par 
\par Protected Mode Exceptions
\par 
\par #NM EM or TS in CR0 is set.
\par 
\par Real-Address Mode Exceptions
\par 
\par #NM EM or TS in CR0 is set.
\par 
\par Virtual-8086 Mode Exceptions
\par 
\par #NM EM or TS in CR0 is set.
{\page}

${\footnote FCMOVB,Opcode}
K{\footnote FCMOVB,FCMOVB;FCMOVE,FCMOVE;FCMOVBE,FCMOVBE;FCMOVU,FCMOVU;FCMOVNB,FCMOVNB;FCMOVNE,FCMOVNE;FCMOVNBE,FCMOVNBE;FCMOVNU,FCMOVNU;FCMOVB,Opcode;FCMOVE,Opcode;FCMOVBE,Opcode;FCMOVU,Opcode;FCMOVNB,Opcode;FCMOVNE,Opcode;FCMOVNBE,Opcode;FCMOVNU,Opcode}
#{\footnote FCMOVB::5}
#{\footnote FCMOVE::5}
#{\footnote FCMOVBE::5}
#{\footnote FCMOVU::5}
#{\footnote FCMOVNB::5}
#{\footnote FCMOVNE::5}
#{\footnote FCMOVNBE::5}
#{\footnote FCMOVNU::5}

{\fs20\b FCMOVB/FCMOVE/FCMOVBE/FCMOVU/FCMOVNB/FCMOVNE/FCMOVNBE/FCMOVNU}\tab{\b Opcode}\par\par
DA C0+i FCMOVB ST(0), ST(i) Move if below (CF=1)
\par DA C8+i FCMOVE ST(0), ST(i) Move if equal (ZF=1)
\par DA D0+i FCMOVBE ST(0), ST(i) Move if below or equal (CF=1 or ZF=1)
\par DA D8+i FCMOVU ST(0), ST(i) Move if unordered (PF=1)
\par DB C0+i FCMOVNB ST(0), ST(i) Move if not below (CF=0)
\par DB C8+i FCMOVNE ST(0), ST(i) Move if not equal (ZF=0)
\par DB D0+i FCMOVNBE ST(0), ST(i) Move if not below or equal (CF=0 and ZF=0)
\par DB D8+i FCMOVNU ST(0), ST(i) Move if not unordered (PF=0)
{\page}

${\footnote FCOM,Description}
K{\footnote FCOM,FCOM;FCOMP,FCOMP;FCOMPP,FCOMPP;FCOM,Description;FCOMP,Description;FCOMPP,Description}
#{\footnote FCOM::1}
#{\footnote FCOMP::1}
#{\footnote FCOMPP::1}

{\fs20\b FCOM/FCOMP/FCOMPP}\tab{\b Description}\par\par
FCOM/FCOMP/FCOMPP: Compare Real
\par 
\par Compares the contents of register ST(0) and source value and sets condition code flags C0, C2, and C3 in the FPU status word according to the results. The source operand can be a data register or a memory location. If no source operand is given, the value in ST(0) is compared with the value in ST(1). The sign of zero is ignored, so that -0.0 = +0.0.
\par 
\par NOTE:
\par * Flags not set if unmasked invalid-arithmetic-operand (#IA) exception is generated. This instruction checks the class of the numbers being compared. If either operand is a NaN or is in an unsupported format, an invalid-arithmetic-operand exception (#IA) is raised and, if the exception is masked, the condition flags are set to "unordered." If the invalid-arithmetic-operand exception is unmasked, the condition code flags are not set.
\par 
\par The FCOMP instruction pops the register stack following the comparison operation and the FCOMPP instruction pops the register stack twice following the comparison operation. To pop the register stack, the processor marks the ST(0) register as empty and increments the stack pointer (TOP) by 1.
\par The FCOM instructions perform the same operation as the FUCOM instructions. The only difference is how they handle QNaN operands. The FCOM instructions raise an invalid-arithmetic-operand exception (#IA) when either or both of the operands is a NaN value or is in an unsupported format. The FUCOM instructions perform the same operation as the FCOM instructions, except that they do not generate an invalid-arithmetic-operand exception for QNaNs.
{\page}

${\footnote FCOM,Operation}
K{\footnote FCOM,FCOM;FCOMP,FCOMP;FCOMPP,FCOMPP;FCOM,Operation;FCOMP,Operation;FCOMPP,Operation}
#{\footnote FCOM::2}
#{\footnote FCOMP::2}
#{\footnote FCOMPP::2}

{\fs20\b FCOM/FCOMP/FCOMPP}\tab{\b Operation}\par\par
CASE (relation of operands) OF
\par ST > SRC: C3, C2, C0 <- 000;
\par ST < SRC: C3, C2, C0 <- 001;
\par ST = SRC: C3, C2, C0 <- 100;
\par ESAC;
\par IF ST(0) or SRC = NaN or unsupported format
\par THEN
\par #IA
\par IF FPUControlWord.IM = 1
\par THEN
\par C3, C2, C0 <- 111;
\par FI;
\par FI;
\par IF instruction = FCOMP
\par THEN
\par PopRegisterStack;
\par FI;
\par IF instruction = FCOMPP
\par THEN
\par PopRegisterStack;
\par PopRegisterStack;
\par FI;
{\page}

${\footnote FCOM,Flags affected}
K{\footnote FCOM,FCOM;FCOMP,FCOMP;FCOMPP,FCOMPP;FCOM,Flags affected;FCOMP,Flags affected;FCOMPP,Flags affected}
#{\footnote FCOM::3}
#{\footnote FCOMP::3}
#{\footnote FCOMPP::3}

{\fs20\b FCOM/FCOMP/FCOMPP}\tab{\b Flags affected}\par\par
FPU Flags Affected
\par 
\par C1 Set to 0 if stack underflow occurred; otherwise, cleared to 0.
{\page}

${\footnote FCOM,Exceptions}
K{\footnote FCOM,FCOM;FCOMP,FCOMP;FCOMPP,FCOMPP;FCOM,Exceptions;FCOMP,Exceptions;FCOMPP,Exceptions}
#{\footnote FCOM::4}
#{\footnote FCOMP::4}
#{\footnote FCOMPP::4}

{\fs20\b FCOM/FCOMP/FCOMPP}\tab{\b Exceptions}\par\par
Floating-Point Exceptions
\par 
\par #IS Stack underflow occurred.
\par #IA One or both operands are NaN values or have unsupported formats. Register is marked empty.
\par #D One or both operands are denormal values.
\par 
\par Protected Mode Exceptions
\par 
\par #GP(0) If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit. If the DS, ES, FS, or GS register contains a null segment selector.
\par #SS(0) If a memory operand effective address is outside the SS segment limit.
\par #NM EM or TS in CR0 is set.
\par #PF(fault-code) If a page fault occurs.
\par #AC(0) If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.
\par 
\par Real-Address Mode Exceptions
\par 
\par #GP If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.
\par #SS If a memory operand effective address is outside the SS segment limit.
\par #NM EM or TS in CR0 is set.
\par 
\par Virtual-8086 Mode Exceptions
\par 
\par #GP(0) If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.
\par #SS(0) If a memory operand effective address is outside the SS segment limit.
\par #NM EM or TS in CR0 is set.
\par #PF(fault-code) If a page fault occurs.
\par #AC(0) If alignment checking is enabled and an unaligned memory reference is made.
{\page}

${\footnote FCOM,Opcode}
K{\footnote FCOM,FCOM;FCOMP,FCOMP;FCOMPP,FCOMPP;FCOM,Opcode;FCOMP,Opcode;FCOMPP,Opcode}
#{\footnote FCOM::5}
#{\footnote FCOMP::5}
#{\footnote FCOMPP::5}

{\fs20\b FCOM/FCOMP/FCOMPP}\tab{\b Opcode}\par\par
D8 /2 FCOM m32real Compare ST(0) with m32real.
\par DC /2 FCOM m64real Compare ST(0) with m64real.
\par D8 D0+i FCOM ST(i) Compare ST(0) with ST(i).
\par D8 D1 FCOM Compare ST(0) with ST(1).
\par D8 /3 FCOMP m32real Compare ST(0) with m32real and pop register stack.
\par DC /3 FCOMP m64real Compare ST(0) with m64real and pop register stack.
\par D8 D8+i FCOMP ST(i) Compare ST(0) with ST(i) and pop register stack.
\par D8 D9 FCOMP Compare ST(0) with ST(1) and pop register stack.
\par DE D9 FCOMPP Compare ST(0) with ST(1) and pop register stack twice.
{\page}

${\footnote FCOMI,Description}
K{\footnote FCOMI,FCOMI;FCOMIP,FCOMIP;FUCOMI,FUCOMI;FUCOMIP,FUCOMIP;FCOMI,Description;FCOMIP,Description;FUCOMI,Description;FUCOMIP,Description}
#{\footnote FCOMI::1}
#{\footnote FCOMIP::1}
#{\footnote FUCOMI::1}
#{\footnote FUCOMIP::1}

{\fs20\b FCOMI/FCOMIP/FUCOMI/FUCOMIP}\tab{\b Description}\par\par
FCOMI/FCOMIP/FUCOMI/FUCOMIP: Compare Real and Set EFLAGS
\par 
\par Compares the contents of register ST(0) and ST(i) and sets the status flags ZF, PF, and CF in the EFLAGS register according to the results. The sign of zero is ignored for comparisons, so that -0.0 = +0.0.
\par The FCOMI/FCOMIP instructions perform the same operation as the FUCOMI/FUCOMIP instructions. The only difference is how they handle QNaN operands. The FCOMI/FCOMIP instructions set the status flags to "unordered" and generate an invalid-arithmetic-operand exception (#IA) when either or both of the operands is a NaN value (SNaN or QNaN) or is in an unsupported format.
\par The FUCOMI/FUCOMIP instructions perform the same operation as the FCOMI/FCOMIP instructions, except that they do not generate an invalid-arithmetic-operand exception for QNaNs.
\par If invalid-operation exception is unmasked, the status flags are not set if the invalid-arithmetic-operand exception is generated. The FCOMIP and FUCOMIP instructions also pop the register stack following the comparison operation. To pop the register stack, the processor marks the ST(0) register as empty and increments the stack pointer (TOP) by 1.
\par 
\par Intel Architecture Compatibility
\par 
\par The FCOMI/FCOMIP/FUCOMI/FUCOMIP instructions were introduced to the Intel Architecture in the Pentium Pro processor family and are not available in earlier Intel Architecture processors.
{\page}

${\footnote FCOMI,Operation}
K{\footnote FCOMI,FCOMI;FCOMIP,FCOMIP;FUCOMI,FUCOMI;FUCOMIP,FUCOMIP;FCOMI,Operation;FCOMIP,Operation;FUCOMI,Operation;FUCOMIP,Operation}
#{\footnote FCOMI::2}
#{\footnote FCOMIP::2}
#{\footnote FUCOMI::2}
#{\footnote FUCOMIP::2}

{\fs20\b FCOMI/FCOMIP/FUCOMI/FUCOMIP}\tab{\b Operation}\par\par
CASE (relation of operands) OF
\par ST(0) > ST(i): ZF, PF, CF <- 000;
\par ST(0) < ST(i): ZF, PF, CF <- 001;
\par ST(0) = ST(i): ZF, PF, CF <- 100;
\par ESAC;
\par IF instruction is FCOMI or FCOMIP
\par THEN
\par IF ST(0) or ST(i) = NaN or unsupported format
\par THEN
\par #IA
\par IF FPUControlWord.IM = 1
\par THEN
\par ZF, PF, CF <- 111;
\par FI;
\par FI;
\par FI;
\par IF instruction is FUCOMI or FUCOMIP
\par THEN
\par IF ST(0) or ST(i) = QNaN, but not SNaN or unsupported format
\par THEN
\par ZF, PF, CF <- 111;
\par ELSE (* ST(0) or ST(i) is SNaN or unsupported format *)
\par #IA;
\par IF FPUControlWord.IM = 1
\par THEN
\par ZF, PF, CF <- 111;
\par FI;
\par FI;
\par FI;
\par IF instruction is FCOMIP or FUCOMIP
\par THEN
\par PopRegisterStack;
\par FI;
{\page}

${\footnote FCOMI,Flags affected}
K{\footnote FCOMI,FCOMI;FCOMIP,FCOMIP;FUCOMI,FUCOMI;FUCOMIP,FUCOMIP;FCOMI,Flags affected;FCOMIP,Flags affected;FUCOMI,Flags affected;FUCOMIP,Flags affected}
#{\footnote FCOMI::3}
#{\footnote FCOMIP::3}
#{\footnote FUCOMI::3}
#{\footnote FUCOMIP::3}

{\fs20\b FCOMI/FCOMIP/FUCOMI/FUCOMIP}\tab{\b Flags affected}\par\par
FPU Flags Affected
\par 
\par C1 Set to 0 if stack underflow occurred; otherwise, cleared to 0. C0, C2, C3 Not affected.
{\page}

${\footnote FCOMI,Exceptions}
K{\footnote FCOMI,FCOMI;FCOMIP,FCOMIP;FUCOMI,FUCOMI;FUCOMIP,FUCOMIP;FCOMI,Exceptions;FCOMIP,Exceptions;FUCOMI,Exceptions;FUCOMIP,Exceptions}
#{\footnote FCOMI::4}
#{\footnote FCOMIP::4}
#{\footnote FUCOMI::4}
#{\footnote FUCOMIP::4}

{\fs20\b FCOMI/FCOMIP/FUCOMI/FUCOMIP}\tab{\b Exceptions}\par\par
Floating-Point Exceptions
\par 
\par #IS Stack underflow occurred.
\par #IA (FCOMI or FCOMIP instruction) One or both operands are NaN values or have unsupported formats. (FUCOMI or FUCOMIP instruction) One or both operands are SNaN values (but not QNaNs) or have undefined formats. Detection of a QNaN value does not raise an invalid-operand exception.
\par 
\par Protected Mode Exceptions
\par 
\par #NM EM or TS in CR0 is set.
\par 
\par Real-Address Mode Exceptions
\par 
\par #NM EM or TS in CR0 is set.
\par 
\par Virtual-8086 Mode Exceptions
\par 
\par #NM EM or TS in CR0 is set.
{\page}

${\footnote FCOMI,Opcode}
K{\footnote FCOMI,FCOMI;FCOMIP,FCOMIP;FUCOMI,FUCOMI;FUCOMIP,FUCOMIP;FCOMI,Opcode;FCOMIP,Opcode;FUCOMI,Opcode;FUCOMIP,Opcode}
#{\footnote FCOMI::5}
#{\footnote FCOMIP::5}
#{\footnote FUCOMI::5}
#{\footnote FUCOMIP::5}

{\fs20\b FCOMI/FCOMIP/FUCOMI/FUCOMIP}\tab{\b Opcode}\par\par
DB F0+i FCOMI ST, ST(i) Compare ST(0) with ST(i) and set status flags accordingly
\par DF F0+i FCOMIP ST, ST(i) Compare ST(0) with ST(i), set status flags accordingly, and pop register stack
\par DB E8+i FUCOMI ST, ST(i) Compare ST(0) with ST(i), check for ordered values, and set status flags accordingly
\par DF E8+i FUCOMIP ST, ST(i) Compare ST(0) with ST(i), check for ordered values, set status flags accordingly, and pop register stack
{\page}

${\footnote FCOS,Description}
K{\footnote FCOS,FCOS;FCOS,Description}
#{\footnote FCOS::1}

{\fs20\b FCOS}\tab{\b Description}\par\par
FCOS: Cosine
\par 
\par Calculates the cosine of the source operand in register ST(0) and stores the result in ST(0). The source operand must be given in radians and must be within the range -2^63 to +2^63. If the source operand is outside the acceptable range, the C2 flag in the FPU status word is set, and the value in register ST(0) remains unchanged. The instruction does not raise an exception when the source operand is out of range. It is up to the program to check the C2 flag for out-of-range conditions. Source values outside the range -2^63 to +2^63 can be reduced to the range of the instruction by subtracting an appropriate integer multiple of 2p or by using the FPREM instruction with a divisor of 2p.
{\page}

${\footnote FCOS,Operation}
K{\footnote FCOS,FCOS;FCOS,Operation}
#{\footnote FCOS::2}

{\fs20\b FCOS}\tab{\b Operation}\par\par
IF |ST(0)| < 2 63
\par THEN
\par C2 <- 0;
\par ST(0) <- cosine(ST(0));
\par ELSE (*source operand is out-of-range *)
\par C2 <- 1;
\par FI;
{\page}

${\footnote FCOS,Flags affected}
K{\footnote FCOS,FCOS;FCOS,Flags affected}
#{\footnote FCOS::3}

{\fs20\b FCOS}\tab{\b Flags affected}\par\par
FPU Flags Affected
\par 
\par C1 Set to 0 if stack underflow occurred. Indicates rounding direction if the inexact-result exception (#P) is generated: 0 = not roundup; 1 = roundup. Undefined if C2 is 1. C2 Set to 1 if source operand is outside the range -2^63 to +2^63 ; otherwise, cleared to 0. C0, C3 Undefined.
{\page}

${\footnote FCOS,Exceptions}
K{\footnote FCOS,FCOS;FCOS,Exceptions}
#{\footnote FCOS::4}

{\fs20\b FCOS}\tab{\b Exceptions}\par\par
Floating-Point Exceptions
\par 
\par #IS Stack underflow occurred.
\par #IA Source operand is an SNaN value, (infinity), or unsupported format.
\par #D Result is a denormal value.
\par #U Result is too small for destination format.
\par #P Value cannot be represented exactly in destination format.
\par 
\par Protected Mode Exceptions
\par 
\par #NM EM or TS in CR0 is set.
\par 
\par Real-Address Mode Exceptions
\par 
\par #NM EM or TS in CR0 is set.
\par 
\par Virtual-8086 Mode Exceptions
\par 
\par #NM EM or TS in CR0 is set.
{\page}

${\footnote FCOS,Opcode}
K{\footnote FCOS,FCOS;FCOS,Opcode}
#{\footnote FCOS::5}

{\fs20\b FCOS}\tab{\b Opcode}\par\par
D9 FF FCOS Replace ST(0) with its cosine
{\page}

${\footnote FDECSTP,Description}
K{\footnote FDECSTP,FDECSTP;FDECSTP,Description}
#{\footnote FDECSTP::1}

{\fs20\b FDECSTP}\tab{\b Description}\par\par
FDECSTP: Decrement Stack-Top Pointer
\par 
\par Subtracts one from the TOP field of the FPU status word (decrements the top-of-stack pointer). If the TOP field contains a 0, it is set to 7. The effect of this instruction is to rotate the stack by one position. The contents of the FPU data registers and tag register are not affected.
{\page}

${\footnote FDECSTP,Operation}
K{\footnote FDECSTP,FDECSTP;FDECSTP,Operation}
#{\footnote FDECSTP::2}

{\fs20\b FDECSTP}\tab{\b Operation}\par\par
IF TOP = 0
\par THEN TOP <- 7;
\par ELSE TOP <- TOP - 1;
\par FI;
{\page}

${\footnote FDECSTP,Flags affected}
K{\footnote FDECSTP,FDECSTP;FDECSTP,Flags affected}
#{\footnote FDECSTP::3}

{\fs20\b FDECSTP}\tab{\b Flags affected}\par\par
FPU Flags Affected
\par 
\par The C1 flag is set to 0; otherwise, cleared to 0. The C0, C2, and C3 flags are undefined.
{\page}

${\footnote FDECSTP,Exceptions}
K{\footnote FDECSTP,FDECSTP;FDECSTP,Exceptions}
#{\footnote FDECSTP::4}

{\fs20\b FDECSTP}\tab{\b Exceptions}\par\par
Floating-Point Exceptions
\par 
\par None.
\par 
\par Protected Mode Exceptions
\par 
\par #NM EM or TS in CR0 is set.
\par 
\par Real-Address Mode Exceptions
\par 
\par #NM EM or TS in CR0 is set.
\par 
\par Virtual-8086 Mode Exceptions
\par 
\par #NM EM or TS in CR0 is set.
{\page}

${\footnote FDECSTP,Opcode}
K{\footnote FDECSTP,FDECSTP;FDECSTP,Opcode}
#{\footnote FDECSTP::5}

{\fs20\b FDECSTP}\tab{\b Opcode}\par\par
D9 F6 FDECSTP Decrement TOP field in FPU status word.
{\page}

${\footnote FDIV,Description}
K{\footnote FDIV,FDIV;FDIVP,FDIVP;FIDIV,FIDIV;FDIV,Description;FDIVP,Description;FIDIV,Description}
#{\footnote FDIV::1}
#{\footnote FDIVP::1}
#{\footnote FIDIV::1}

{\fs20\b FDIV/FDIVP/FIDIV}\tab{\b Description}\par\par
FDIV/FDIVP/FIDIV: Divide
\par 
\par Divides the destination operand by the source operand and stores the result in the destination location. The destination operand (dividend) is always in an FPU register; the source operand (divisor) can be a register or a memory location. Source operands in memory can be in single-real, double-real, word-integer, or short-integer formats.
\par The no-operand version of the instruction divides the contents of the ST(1) register by the contents of the ST(0) register. The one-operand version divides the contents of the ST(0) register by the contents of a memory location (either a real or an integer value). The two-operand version, divides the contents of the ST(0) register by the contents of the ST(i) register or vice versa.
\par The FDIVP instructions perform the additional operation of popping the FPU register stack after storing the result. To pop the register stack, the processor marks the ST(0) register as empty and increments the stack pointer (TOP) by 1. The no-operand version of the floating-point divide instructions always results in the register stack being popped. In some assemblers, the mnemonic for this instruction is FDIV rather than FDIVP.
\par The FIDIV instructions convert an integer source operand to extended-real format before performing the division. When the source operand is an integer 0, it is treated as a +0. If an unmasked divide by zero exception (#Z) is generated, no result is stored; if the exception is masked, an (infinity) of the appropriate sign is stored in the destination operand.
{\page}

${\footnote FDIV,Operation}
K{\footnote FDIV,FDIV;FDIVP,FDIVP;FIDIV,FIDIV;FDIV,Operation;FDIVP,Operation;FIDIV,Operation}
#{\footnote FDIV::2}
#{\footnote FDIVP::2}
#{\footnote FIDIV::2}

{\fs20\b FDIV/FDIVP/FIDIV}\tab{\b Operation}\par\par
IF SRC = 0
\par THEN
\par #Z
\par ELSE
\par IF instruction is FIDIV
\par THEN
\par DEST <- DEST / ConvertExtendedReal(SRC);
\par ELSE (* source operand is real number *)
\par DEST <- DEST / SRC;
\par FI;
\par FI;
\par IF instruction = FDIVP
\par THEN
\par PopRegisterStack
\par FI;
{\page}

${\footnote FDIV,Flags affected}
K{\footnote FDIV,FDIV;FDIVP,FDIVP;FIDIV,FIDIV;FDIV,Flags affected;FDIVP,Flags affected;FIDIV,Flags affected}
#{\footnote FDIV::3}
#{\footnote FDIVP::3}
#{\footnote FIDIV::3}

{\fs20\b FDIV/FDIVP/FIDIV}\tab{\b Flags affected}\par\par
FPU Flags Affected
\par 
\par C1 Set to 0 if stack underflow occurred. Indicates rounding direction if the inexact-result exception (#P) is generated: 0 = not roundup; 1 = roundup. C0, C2, C3 Undefined.
{\page}

${\footnote FDIV,Exceptions}
K{\footnote FDIV,FDIV;FDIVP,FDIVP;FIDIV,FIDIV;FDIV,Exceptions;FDIVP,Exceptions;FIDIV,Exceptions}
#{\footnote FDIV::4}
#{\footnote FDIVP::4}
#{\footnote FIDIV::4}

{\fs20\b FDIV/FDIVP/FIDIV}\tab{\b Exceptions}\par\par
Floating-Point Exceptions
\par 
\par #IS Stack underflow occurred.
\par #IA Operand is an SNaN value or unsupported format. (infinity) / (infinity); 0 / 0
\par #D Result is a denormal value.
\par #Z DEST / 0, where DEST is not equal to 0.
\par #U Result is too small for destination format.
\par #O Result is too large for destination format.
\par #P Value cannot be represented exactly in destination format.
\par 
\par Protected Mode Exceptions
\par 
\par #GP(0) If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit. If the DS, ES, FS, or GS register contains a null segment selector.
\par #SS(0) If a memory operand effective address is outside the SS segment limit.
\par #NM EM or TS in CR0 is set.
\par #PF(fault-code) If a page fault occurs.
\par #AC(0) If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.
\par 
\par Real-Address Mode Exceptions
\par 
\par #GP If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.
\par #SS If a memory operand effective address is outside the SS segment limit.
\par #NM EM or TS in CR0 is set.
\par 
\par Virtual-8086 Mode Exceptions
\par 
\par #GP(0) If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.
\par #SS(0) If a memory operand effective address is outside the SS segment limit.
\par #NM EM or TS in CR0 is set.
\par #PF(fault-code) If a page fault occurs.
\par #AC(0) If alignment checking is enabled and an unaligned memory reference is made.
{\page}

${\footnote FDIV,Opcode}
K{\footnote FDIV,FDIV;FDIVP,FDIVP;FIDIV,FIDIV;FDIV,Opcode;FDIVP,Opcode;FIDIV,Opcode}
#{\footnote FDIV::5}
#{\footnote FDIVP::5}
#{\footnote FIDIV::5}

{\fs20\b FDIV/FDIVP/FIDIV}\tab{\b Opcode}\par\par
D8 /6 FDIV m32real Divide ST(0) by m32real and store result in ST(0)
\par DC /6 FDIV m64real Divide ST(0) by m64real and store result in ST(0)
\par D8 F0+i FDIV ST(0), ST(i) Divide ST(0) by ST(i) and store result in ST(0)
\par DC F8+i FDIV ST(i), ST(0) Divide ST(i) by ST(0) and store result in ST(i)
\par DE F8+i FDIVP ST(i), ST(0) Divide ST(i) by ST(0), store result in ST(i), and pop the register stack
\par DE F9 FDIVP Divide ST(1) by ST(0), store result in ST(1), and pop the register stack
\par DA /6 FIDIV m32int Divide ST(0) by m32int and store result in ST(0)
\par DE /6 FIDIV m16int Divide ST(0) by m64int and store result in ST(0)
{\page}

${\footnote FDIVR,Description}
K{\footnote FDIVR,FDIVR;FDIVRP,FDIVRP;FIDIVR,FIDIVR;FDIVR,Description;FDIVRP,Description;FIDIVR,Description}
#{\footnote FDIVR::1}
#{\footnote FDIVRP::1}
#{\footnote FIDIVR::1}

{\fs20\b FDIVR/FDIVRP/FIDIVR}\tab{\b Description}\par\par
FDIVR/FDIVRP/FIDIVR: Reverse Divide
\par 
\par Divides the source operand by the destination operand and stores the result in the destination location. The destination operand (divisor) is always in an FPU register; the source operand (dividend) can be a register or a memory location. Source operands in memory can be in single-real, double-real, word-integer, or short-integer formats. These instructions perform the reverse operations of the FDIV, FDIVP, and FIDIV instructions. They are provided to support more efficient coding. The no-operand version of the instruction divides the contents of the ST(0) register by the contents of the ST(1) register. The one-operand version divides the contents of a memory location (either a real or an integer value) by the contents of the ST(0) register. The two-operand version, divides the contents of the ST(i) register by the contents of the ST(0) register or vice versa.
\par The FDIVRP instructions perform the additional operation of popping the FPU register stack after storing the result. To pop the register stack, the processor marks the ST(0) register as empty and increments the stack pointer (TOP) by 1. The no-operand version of the floating-point divide instructions always results in the register stack being popped. In some assemblers, the mnemonic for this instruction is FDIVR rather than FDIVRP.
\par The FIDIVR instructions convert an integer source operand to extended-real format before performing the division. If an unmasked divide by zero exception (#Z) is generated, no result is stored; if the exception is masked, an (infinity) of the appropriate sign is stored in the destination operand.
{\page}

${\footnote FDIVR,Operation}
K{\footnote FDIVR,FDIVR;FDIVRP,FDIVRP;FIDIVR,FIDIVR;FDIVR,Operation;FDIVRP,Operation;FIDIVR,Operation}
#{\footnote FDIVR::2}
#{\footnote FDIVRP::2}
#{\footnote FIDIVR::2}

{\fs20\b FDIVR/FDIVRP/FIDIVR}\tab{\b Operation}\par\par
IF DEST = 0
\par THEN
\par #Z
\par ELSE
\par IF instruction is FIDIVR
\par THEN
\par DEST <- ConvertExtendedReal(SRC) / DEST;
\par ELSE (* source operand is real number *)
\par DEST <- SRC / DEST;
\par FI;
\par FI;
\par IF instruction = FDIVRP
\par THEN
\par PopRegisterStack
\par FI;
{\page}

${\footnote FDIVR,Flags affected}
K{\footnote FDIVR,FDIVR;FDIVRP,FDIVRP;FIDIVR,FIDIVR;FDIVR,Flags affected;FDIVRP,Flags affected;FIDIVR,Flags affected}
#{\footnote FDIVR::3}
#{\footnote FDIVRP::3}
#{\footnote FIDIVR::3}

{\fs20\b FDIVR/FDIVRP/FIDIVR}\tab{\b Flags affected}\par\par
FPU Flags Affected
\par 
\par C1 Set to 0 if stack underflow occurred. Indicates rounding direction if the inexact-result exception (#P) is generated: 0 = not roundup; 1 = roundup. C0, C2, C3 Undefined.
{\page}

${\footnote FDIVR,Exceptions}
K{\footnote FDIVR,FDIVR;FDIVRP,FDIVRP;FIDIVR,FIDIVR;FDIVR,Exceptions;FDIVRP,Exceptions;FIDIVR,Exceptions}
#{\footnote FDIVR::4}
#{\footnote FDIVRP::4}
#{\footnote FIDIVR::4}

{\fs20\b FDIVR/FDIVRP/FIDIVR}\tab{\b Exceptions}\par\par
Floating-Point Exceptions
\par 
\par #IS Stack underflow occurred.
\par #IA Operand is an SNaN value or unsupported format. (infinity) / (infinity); 0 / 0
\par #D Result is a denormal value.
\par #Z SRC / 0, where SRC is not equal to 0.
\par #U Result is too small for destination format.
\par #O Result is too large for destination format.
\par #P Value cannot be represented exactly in destination format.
\par 
\par Protected Mode Exceptions
\par 
\par #GP(0) If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit. If the DS, ES, FS, or GS register contains a null segment selector.
\par #SS(0) If a memory operand effective address is outside the SS segment limit.
\par #NM EM or TS in CR0 is set.
\par #PF(fault-code) If a page fault occurs.
\par #AC(0) If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.
\par 
\par Real-Address Mode Exceptions
\par 
\par #GP If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.
\par #SS If a memory operand effective address is outside the SS segment limit.
\par #NM EM or TS in CR0 is set.
\par 
\par Virtual-8086 Mode Exceptions
\par 
\par #GP(0) If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.
\par #SS(0) If a memory operand effective address is outside the SS segment limit.
\par #NM EM or TS in CR0 is set.
\par #PF(fault-code) If a page fault occurs.
\par #AC(0) If alignment checking is enabled and an unaligned memory reference is made.
{\page}

${\footnote FDIVR,Opcode}
K{\footnote FDIVR,FDIVR;FDIVRP,FDIVRP;FIDIVR,FIDIVR;FDIVR,Opcode;FDIVRP,Opcode;FIDIVR,Opcode}
#{\footnote FDIVR::5}
#{\footnote FDIVRP::5}
#{\footnote FIDIVR::5}

{\fs20\b FDIVR/FDIVRP/FIDIVR}\tab{\b Opcode}\par\par
D8 /7 FDIVR m32real Divide m32real by ST(0) and store result in ST(0)
\par DC /7 FDIVR m64real Divide m64real by ST(0) and store result in ST(0)
\par D8 F8+i FDIVR ST(0), ST(i) Divide ST(i) by ST(0) and store result in ST(0)
\par DC F0+i FDIVR ST(i), ST(0) Divide ST(0) by ST(i) and store result in ST(i)
\par DE F0+i FDIVRP ST(i), ST(0) Divide ST(0) by ST(i), store result in ST(i), and pop the register stack
\par DE F1 FDIVRP Divide ST(0) by ST(1), store result in ST(1), and pop the register stack
\par DA /7 FIDIVR m32int Divide m32int by ST(0) and store result in ST(0)
\par DE /7 FIDIVR m16int Divide m64int by ST(0) and store result in ST(0)
{\page}

${\footnote FFREE,Description}
K{\footnote FFREE,FFREE;FFREE,Description}
#{\footnote FFREE::1}

{\fs20\b FFREE}\tab{\b Description}\par\par
FFREE: Free Floating-Point Register
\par 
\par Sets the tag in the FPU tag register associated with register ST(i) to empty (11B). The contents of ST(i) and the FPU stack-top pointer (TOP) are not affected.
{\page}

${\footnote FFREE,Operation}
K{\footnote FFREE,FFREE;FFREE,Operation}
#{\footnote FFREE::2}

{\fs20\b FFREE}\tab{\b Operation}\par\par
TAG(i) <- 11B;
{\page}

${\footnote FFREE,Flags affected}
K{\footnote FFREE,FFREE;FFREE,Flags affected}
#{\footnote FFREE::3}

{\fs20\b FFREE}\tab{\b Flags affected}\par\par
FPU Flags Affected
\par 
\par C0, C1, C2, C3 undefined.
{\page}

${\footnote FFREE,Exceptions}
K{\footnote FFREE,FFREE;FFREE,Exceptions}
#{\footnote FFREE::4}

{\fs20\b FFREE}\tab{\b Exceptions}\par\par
Floating-Point Exceptions
\par 
\par None.
\par 
\par Protected Mode Exceptions
\par 
\par #NM EM or TS in CR0 is set.
\par 
\par Real-Address Mode Exceptions
\par 
\par #NM EM or TS in CR0 is set.
\par 
\par Virtual-8086 Mode Exceptions
\par 
\par #NM EM or TS in CR0 is set.
{\page}

${\footnote FFREE,Opcode}
K{\footnote FFREE,FFREE;FFREE,Opcode}
#{\footnote FFREE::5}

{\fs20\b FFREE}\tab{\b Opcode}\par\par
DD C0+i FFREE ST(i) Sets tag for ST(i) to empty
{\page}

${\footnote FICOM,Description}
K{\footnote FICOM,FICOM;FICOMP,FICOMP;FICOM,Description;FICOMP,Description}
#{\footnote FICOM::1}
#{\footnote FICOMP::1}

{\fs20\b FICOM/FICOMP}\tab{\b Description}\par\par
FICOM/FICOMP: Compare Integer
\par 
\par Compares the value in ST(0) with an integer source operand and sets the condition code flags C0, C2, and C3 in the FPU status word according to the results. The integer value is converted to extended-real format before the comparison is made. These instructions perform an "unordered comparison." An unordered comparison also checks the class of the numbers being compared. If either operand is a NaN or is in an undefined format, the condition flags are set to "unordered." The sign of zero is ignored, so that -0.0 = +0.0. The FICOMP instructions pop the register stack following the comparison. To pop the register stack, the processor marks the ST(0) register empty and increments the stack pointer (TOP) by 1.
{\page}

${\footnote FICOM,Operation}
K{\footnote FICOM,FICOM;FICOMP,FICOMP;FICOM,Operation;FICOMP,Operation}
#{\footnote FICOM::2}
#{\footnote FICOMP::2}

{\fs20\b FICOM/FICOMP}\tab{\b Operation}\par\par
CASE (relation of operands) OF
\par ST(0) > SRC: C3, C2, C0 <- 000;
\par ST(0) < SRC: C3, C2, C0 <- 001;
\par ST(0) = SRC: C3, C2, C0 <- 100;
\par Unordered: C3, C2, C0 <- 111;
\par ESAC;
\par IF instruction = FICOMP
\par THEN
\par PopRegisterStack;
\par FI;
{\page}

${\footnote FICOM,Flags affected}
K{\footnote FICOM,FICOM;FICOMP,FICOMP;FICOM,Flags affected;FICOMP,Flags affected}
#{\footnote FICOM::3}
#{\footnote FICOMP::3}

{\fs20\b FICOM/FICOMP}\tab{\b Flags affected}\par\par
FPU Flags Affected
\par 
\par C1 Set to 0 if stack underflow occurred; otherwise, set to 0. C0, C2, C3 according to tables.
{\page}

${\footnote FICOM,Exceptions}
K{\footnote FICOM,FICOM;FICOMP,FICOMP;FICOM,Exceptions;FICOMP,Exceptions}
#{\footnote FICOM::4}
#{\footnote FICOMP::4}

{\fs20\b FICOM/FICOMP}\tab{\b Exceptions}\par\par
Floating-Point Exceptions
\par 
\par #IS Stack underflow occurred.
\par #IA One or both operands are NaN values or have unsupported formats.
\par #D One or both operands are denormal values.
\par 
\par Protected Mode Exceptions
\par 
\par #GP(0) If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit. If the DS, ES, FS, or GS register contains a null segment selector.
\par #SS(0) If a memory operand effective address is outside the SS segment limit.
\par #NM EM or TS in CR0 is set.
\par #PF(fault-code) If a page fault occurs.
\par #AC(0) If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.
\par 
\par Real-Address Mode Exceptions
\par 
\par #GP If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.
\par #SS If a memory operand effective address is outside the SS segment limit.
\par #NM EM or TS in CR0 is set.
\par 
\par Virtual-8086 Mode Exceptions
\par 
\par #GP(0) If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.
\par #SS(0) If a memory operand effective address is outside the SS segment limit.
\par #NM EM or TS in CR0 is set.
\par #PF(fault-code) If a page fault occurs.
\par #AC(0) If alignment checking is enabled and an unaligned memory reference is made.
{\page}

${\footnote FICOM,Opcode}
K{\footnote FICOM,FICOM;FICOMP,FICOMP;FICOM,Opcode;FICOMP,Opcode}
#{\footnote FICOM::5}
#{\footnote FICOMP::5}

{\fs20\b FICOM/FICOMP}\tab{\b Opcode}\par\par
DE /2 FICOM m16int Compare ST(0) with m16int
\par DA /2 FICOM m32int Compare ST(0) with m32int
\par DE /3 FICOMP m16int Compare ST(0) with m16int and pop stack register
\par DA /3 FICOMP m32int Compare ST(0) with m32int and pop stack register
{\page}

${\footnote FILD,Description}
K{\footnote FILD,FILD;FILD,Description}
#{\footnote FILD::1}

{\fs20\b FILD}\tab{\b Description}\par\par
FILD: Load Integer
\par 
\par Converts the signed-integer source operand into extended-real format and pushes the value onto the FPU register stack. The source operand can be a word, short, or long integer value. It is loaded without rounding errors. The sign of the source operand is preserved.
{\page}

${\footnote FILD,Operation}
K{\footnote FILD,FILD;FILD,Operation}
#{\footnote FILD::2}

{\fs20\b FILD}\tab{\b Operation}\par\par
TOP <- TOP - 1;
\par ST(0) <- ExtendedReal(SRC);
{\page}

${\footnote FILD,Flags affected}
K{\footnote FILD,FILD;FILD,Flags affected}
#{\footnote FILD::3}

{\fs20\b FILD}\tab{\b Flags affected}\par\par
FPU Flags Affected
\par 
\par C1 Set to 1 if stack overflow occurred; cleared to 0 otherwise. C0, C2, C3 Undefined.
{\page}

${\footnote FILD,Exceptions}
K{\footnote FILD,FILD;FILD,Exceptions}
#{\footnote FILD::4}

{\fs20\b FILD}\tab{\b Exceptions}\par\par
Floating-Point Exceptions
\par 
\par #IS Stack overflow occurred.
\par 
\par Protected Mode Exceptions
\par 
\par #GP(0) If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit. If the DS, ES, FS, or GS register contains a null segment selector.
\par #SS(0) If a memory operand effective address is outside the SS segment limit.
\par #NM EM or TS in CR0 is set.
\par #PF(fault-code) If a page fault occurs.
\par #AC(0) If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.
\par 
\par Real-Address Mode Exceptions
\par 
\par #GP If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.
\par #SS If a memory operand effective address is outside the SS segment limit.
\par #NM EM or TS in CR0 is set.
\par 
\par Virtual-8086 Mode Exceptions
\par 
\par #GP(0) If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.
\par #SS(0) If a memory operand effective address is outside the SS segment limit.
\par #NM EM or TS in CR0 is set.
\par #PF(fault-code) If a page fault occurs.
\par #AC(0) If alignment checking is enabled and an unaligned memory reference is made.
{\page}

${\footnote FILD,Opcode}
K{\footnote FILD,FILD;FILD,Opcode}
#{\footnote FILD::5}

{\fs20\b FILD}\tab{\b Opcode}\par\par
DF /0 FILD m16int Push m16int onto the FPU register stack.
\par DB /0 FILD m32int Push m32int onto the FPU register stack.
\par DF /5 FILD m64int Push m64int onto the FPU register stack.
{\page}

${\footnote FINCSTP,Description}
K{\footnote FINCSTP,FINCSTP;FINCSTP,Description}
#{\footnote FINCSTP::1}

{\fs20\b FINCSTP}\tab{\b Description}\par\par
FINCSTP: Increment Stack-Top Pointer
\par 
\par Adds one to the TOP field of the FPU status word (increments the top-of-stack pointer). If the TOP field contains a 7, it is set to 0. The effect of this instruction is to rotate the stack by one position. The contents of the FPU data registers and tag register are not affected. This operation is not equivalent to popping the stack, because the tag for the previous top-of-stack register is not marked empty.
{\page}

${\footnote FINCSTP,Operation}
K{\footnote FINCSTP,FINCSTP;FINCSTP,Operation}
#{\footnote FINCSTP::2}

{\fs20\b FINCSTP}\tab{\b Operation}\par\par
IF TOP = 7
\par THEN TOP <- 0;
\par ELSE TOP <- TOP + 1;
\par FI;
{\page}

${\footnote FINCSTP,Flags affected}
K{\footnote FINCSTP,FINCSTP;FINCSTP,Flags affected}
#{\footnote FINCSTP::3}

{\fs20\b FINCSTP}\tab{\b Flags affected}\par\par
FPU Flags Affected
\par 
\par The C1 flag is set to 0; otherwise, cleared to 0. The C0, C2, and C3 flags are undefined.
{\page}

${\footnote FINCSTP,Exceptions}
K{\footnote FINCSTP,FINCSTP;FINCSTP,Exceptions}
#{\footnote FINCSTP::4}

{\fs20\b FINCSTP}\tab{\b Exceptions}\par\par
Floating-Point Exceptions
\par 
\par None.
\par 
\par Protected Mode Exceptions
\par 
\par #NM EM or TS in CR0 is set.
\par 
\par Real-Address Mode Exceptions
\par 
\par #NM EM or TS in CR0 is set.
\par 
\par Virtual-8086 Mode Exceptions
\par 
\par #NM EM or TS in CR0 is set.
{\page}

${\footnote FINCSTP,Opcode}
K{\footnote FINCSTP,FINCSTP;FINCSTP,Opcode}
#{\footnote FINCSTP::5}

{\fs20\b FINCSTP}\tab{\b Opcode}\par\par
D9 F7 FINCSTP Increment the TOP field in the FPU status register
{\page}

${\footnote FINIT,Description}
K{\footnote FINIT,FINIT;FNINIT,FNINIT;FINIT,Description;FNINIT,Description}
#{\footnote FINIT::1}
#{\footnote FNINIT::1}

{\fs20\b FINIT/FNINIT}\tab{\b Description}\par\par
FINIT/FNINIT: Initialize Floating-Point Unit
\par 
\par Sets the FPU control, status, tag, instruction pointer, and data pointer registers to their default states. The FPU control word is set to 037FH (round to nearest, all exceptions masked, 64-bit precision). The status word is cleared (no exception flags set, TOP is set to 0). The data registers in the register stack are left unchanged, but they are all tagged as empty (11B). Both the instruction and data pointers are cleared. The FINIT instruction checks for and handles any pending unmasked floating-point exceptions before performing the initialization; the FNINIT instruction does not.
\par 
\par Intel Architecture Compatibility
\par 
\par When operating a Pentium or Intel486 processor in MS-DOS compatibility mode, it is possible (under unusual circumstances) for an FNINIT instruction to be interrupted prior to being executed to handle a pending FPU exception. An FNINIT instruction cannot be interrupted in this way on a Pentium Pro processor. In the Intel387 math coprocessor, the FINIT/FNINIT instruction does not clear the instruction and data pointers.
{\page}

${\footnote FINIT,Operation}
K{\footnote FINIT,FINIT;FNINIT,FNINIT;FINIT,Operation;FNINIT,Operation}
#{\footnote FINIT::2}
#{\footnote FNINIT::2}

{\fs20\b FINIT/FNINIT}\tab{\b Operation}\par\par
FPUControlWord <- 037FH;
\par FPUStatusWord <- 0;
\par FPUTagWord <- FFFFH;
\par FPUDataPointer <- 0;
\par FPUInstructionPointer <- 0;
\par FPULastInstructionOpcode <- 0;
{\page}

${\footnote FINIT,Flags affected}
K{\footnote FINIT,FINIT;FNINIT,FNINIT;FINIT,Flags affected;FNINIT,Flags affected}
#{\footnote FINIT::3}
#{\footnote FNINIT::3}

{\fs20\b FINIT/FNINIT}\tab{\b Flags affected}\par\par
FPU Flags Affected
\par 
\par C0, C1, C2, C3 cleared to 0.
{\page}

${\footnote FINIT,Exceptions}
K{\footnote FINIT,FINIT;FNINIT,FNINIT;FINIT,Exceptions;FNINIT,Exceptions}
#{\footnote FINIT::4}
#{\footnote FNINIT::4}

{\fs20\b FINIT/FNINIT}\tab{\b Exceptions}\par\par
Floating-Point Exceptions
\par 
\par None.
\par 
\par Protected Mode Exceptions
\par 
\par #NM EM or TS in CR0 is set.
\par 
\par Real-Address Mode Exceptions
\par 
\par #NM EM or TS in CR0 is set.
\par 
\par Virtual-8086 Mode Exceptions
\par 
\par #NM EM or TS in CR0 is set.
{\page}

${\footnote FINIT,Opcode}
K{\footnote FINIT,FINIT;FNINIT,FNINIT;FINIT,Opcode;FNINIT,Opcode}
#{\footnote FINIT::5}
#{\footnote FNINIT::5}

{\fs20\b FINIT/FNINIT}\tab{\b Opcode}\par\par
9B DB E3 FINIT Initialize FPU after checking for pending unmasked floating-point exceptions.
\par DB E3 FNINIT Initialize FPU without checking for pending unmasked floating-point exceptions.
{\page}

${\footnote FIST,Description}
K{\footnote FIST,FIST;FISTP,FISTP;FIST,Description;FISTP,Description}
#{\footnote FIST::1}
#{\footnote FISTP::1}

{\fs20\b FIST/FISTP}\tab{\b Description}\par\par
FIST/FISTP: Store Integer
\par 
\par The FIST instruction converts the value in the ST(0) register to a signed integer and stores the result in the destination operand. Values can be stored in word- or short-integer format. The destination operand specifies the address where the first byte of the destination value is to be stored. The FISTP instruction performs the same operation as the FIST instruction and then pops the register stack. To pop the register stack, the processor marks the ST(0) register as empty and increments the stack pointer (TOP) by 1. The FISTP instruction can also stores values in long-integer format.
\par If the source value is a non-integral value, it is rounded to an integer value, according to the rounding mode specified by the RC field of the FPU control word. If the value being stored is too large for the destination format, is an (infinity), is a NaN, or is in an unsupported format and if the invalid-arithmetic-operand exception (#IA) is unmasked, an invalid-operation exception is generated and no value is stored in the destination operand. If the invalid-operation exception is masked, the integer indefinite value is stored in the destination operand.
{\page}

${\footnote FIST,Operation}
K{\footnote FIST,FIST;FISTP,FISTP;FIST,Operation;FISTP,Operation}
#{\footnote FIST::2}
#{\footnote FISTP::2}

{\fs20\b FIST/FISTP}\tab{\b Operation}\par\par
DEST <- Integer(ST(0));
\par IF instruction = FISTP
\par THEN
\par PopRegisterStack;
\par FI;
{\page}

${\footnote FIST,Flags affected}
K{\footnote FIST,FIST;FISTP,FISTP;FIST,Flags affected;FISTP,Flags affected}
#{\footnote FIST::3}
#{\footnote FISTP::3}

{\fs20\b FIST/FISTP}\tab{\b Flags affected}\par\par
FPU Flags Affected
\par 
\par C1 Set to 0 if stack underflow occurred. Indicates rounding direction of if the inexact exception (#P) is generated: 0 = not roundup; 1 = roundup. Cleared to 0 otherwise. C0, C2, C3 Undefined.
{\page}

${\footnote FIST,Exceptions}
K{\footnote FIST,FIST;FISTP,FISTP;FIST,Exceptions;FISTP,Exceptions}
#{\footnote FIST::4}
#{\footnote FISTP::4}

{\fs20\b FIST/FISTP}\tab{\b Exceptions}\par\par
Floating-Point Exceptions
\par 
\par #IS Stack underflow occurred.
\par #IA Source operand is too large for the destination format. Source operand is a NaN value or unsupported format.
\par #P Value cannot be represented exactly in destination format.
\par 
\par Protected Mode Exceptions
\par 
\par #GP(0) If the destination is located in a nonwritable segment. If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit. If the DS, ES, FS, or GS register is used to access memory and it contains a null segment selector.
\par #SS(0) If a memory operand effective address is outside the SS segment limit.
\par #NM EM or TS in CR0 is set.
\par #PF(fault-code) If a page fault occurs.
\par #AC(0) If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.
\par 
\par Real-Address Mode Exceptions
\par 
\par #GP If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.
\par #SS If a memory operand effective address is outside the SS segment limit.
\par #NM EM or TS in CR0 is set.
\par 
\par Virtual-8086 Mode Exceptions
\par 
\par #GP(0) If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.
\par #SS(0) If a memory operand effective address is outside the SS segment limit.
\par #NM EM or TS in CR0 is set.
\par #PF(fault-code) If a page fault occurs.
\par #AC(0) If alignment checking is enabled and an unaligned memory reference is made.
{\page}

${\footnote FIST,Opcode}
K{\footnote FIST,FIST;FISTP,FISTP;FIST,Opcode;FISTP,Opcode}
#{\footnote FIST::5}
#{\footnote FISTP::5}

{\fs20\b FIST/FISTP}\tab{\b Opcode}\par\par
DF /2 FIST m16int Store ST(0) in m16int
\par DB /2 FIST m32int Store ST(0) in m32int
\par DF /3 FISTP m16int Store ST(0) in m16int and pop register stack
\par DB /3 FISTP m32int Store ST(0) in m32int and pop register stack
\par DF /7 FISTP m64int Store ST(0) in m64int and pop register stack
{\page}

${\footnote FLD,Description}
K{\footnote FLD,FLD;FLD,Description}
#{\footnote FLD::1}

{\fs20\b FLD}\tab{\b Description}\par\par
FLD: Load Real
\par 
\par Pushes the source operand onto the FPU register stack. If the source operand is in single- or double-real format, it is automatically converted to the extended-real format before being pushed on the stack. The FLD instruction can also push the value in a selected FPU register [ST(i)] onto the stack. Here, pushing register ST(0) duplicates the stack top.
{\page}

${\footnote FLD,Operation}
K{\footnote FLD,FLD;FLD,Operation}
#{\footnote FLD::2}

{\fs20\b FLD}\tab{\b Operation}\par\par
IF SRC is ST(i)
\par THEN
\par temp <- ST(i)
\par TOP <- TOP - 1;
\par IF SRC is memory-operand
\par THEN
\par ST(0) <- ExtendedReal(SRC);
\par ELSE (* SRC is ST(i) *)
\par ST(0) <- temp;
{\page}

${\footnote FLD,Flags affected}
K{\footnote FLD,FLD;FLD,Flags affected}
#{\footnote FLD::3}

{\fs20\b FLD}\tab{\b Flags affected}\par\par
FPU Flags Affected
\par 
\par C1 Set to 1 if stack overflow occurred; otherwise, cleared to 0. C0, C2, C3 Undefined.
{\page}

${\footnote FLD,Exceptions}
K{\footnote FLD,FLD;FLD,Exceptions}
#{\footnote FLD::4}

{\fs20\b FLD}\tab{\b Exceptions}\par\par
Floating-Point Exceptions
\par 
\par #IS Stack overflow occurred.
\par #IA Source operand is an SNaN value or unsupported format.
\par #D Source operand is a denormal value. Does not occur if the source operand is in extended-real format.
\par 
\par Protected Mode Exceptions
\par 
\par #GP(0) If destination is located in a nonwritable segment. If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit. If the DS, ES, FS, or GS register is used to access memory and it contains a null segment selector.
\par #SS(0) If a memory operand effective address is outside the SS segment limit.
\par #NM EM or TS in CR0 is set.
\par #PF(fault-code) If a page fault occurs.
\par #AC(0) If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.
\par 
\par Real-Address Mode Exceptions
\par 
\par #GP If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.
\par #SS If a memory operand effective address is outside the SS segment limit.
\par #NM EM or TS in CR0 is set.
\par 
\par Virtual-8086 Mode Exceptions
\par 
\par #GP(0) If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.
\par #SS(0) If a memory operand effective address is outside the SS segment limit.
\par #NM EM or TS in CR0 is set.
\par #PF(fault-code) If a page fault occurs.
\par #AC(0) If alignment checking is enabled and an unaligned memory reference is made.
{\page}

${\footnote FLD,Opcode}
K{\footnote FLD,FLD;FLD,Opcode}
#{\footnote FLD::5}

{\fs20\b FLD}\tab{\b Opcode}\par\par
D9 /0 FLD m32real Push m32real onto the FPU register stack.
\par DD /0 FLD m64real Push m64real onto the FPU register stack.
\par DB /5 FLD m80real Push m80real onto the FPU register stack.
\par D9 C0+i FLD ST(i) Push ST(i) onto the FPU register stack.
{\page}

${\footnote FLD1,Description}
K{\footnote FLD1,FLD1;FLDL2T,FLDL2T;FLDL2E,FLDL2E;FLDPI,FLDPI;FLDLG2,FLDLG2;FLDLN2,FLDLN2;FLDZ,FLDZ;FLD1,Description;FLDL2T,Description;FLDL2E,Description;FLDPI,Description;FLDLG2,Description;FLDLN2,Description;FLDZ,Description}
#{\footnote FLD1::1}
#{\footnote FLDL2T::1}
#{\footnote FLDL2E::1}
#{\footnote FLDPI::1}
#{\footnote FLDLG2::1}
#{\footnote FLDLN2::1}
#{\footnote FLDZ::1}

{\fs20\b FLD1/FLDL2T/FLDL2E/FLDPI/FLDLG2/FLDLN2/FLDZ}\tab{\b Description}\par\par
FLD1/FLDL2T/FLDL2E/FLDPI/FLDLG2/FLDLN2/FLDZ: Load Constant
\par 
\par Push one of seven commonly used constants (in extended-real format) onto the FPU register stack. The constants that can be loaded with these instructions include +1.0, +0.0, log 2 10, log 2 e, p, log 10 2, and log e 2. For each constant, an internal 66-bit constant is rounded (as specified by the RC field in the FPU control word) to external-real format. The inexact-result exception (#P) is not generated as a result of the rounding.
\par 
\par Intel Architecture Compatibility
\par 
\par When the RC field is set to round-to-nearest, the FPU produces the same constants that is produced by the Intel 8087 and Intel287 math coprocessors.
{\page}

${\footnote FLD1,Operation}
K{\footnote FLD1,FLD1;FLDL2T,FLDL2T;FLDL2E,FLDL2E;FLDPI,FLDPI;FLDLG2,FLDLG2;FLDLN2,FLDLN2;FLDZ,FLDZ;FLD1,Operation;FLDL2T,Operation;FLDL2E,Operation;FLDPI,Operation;FLDLG2,Operation;FLDLN2,Operation;FLDZ,Operation}
#{\footnote FLD1::2}
#{\footnote FLDL2T::2}
#{\footnote FLDL2E::2}
#{\footnote FLDPI::2}
#{\footnote FLDLG2::2}
#{\footnote FLDLN2::2}
#{\footnote FLDZ::2}

{\fs20\b FLD1/FLDL2T/FLDL2E/FLDPI/FLDLG2/FLDLN2/FLDZ}\tab{\b Operation}\par\par
TOP <- TOP - 1;
\par ST(0) <- CONSTANT;
{\page}

${\footnote FLD1,Flags affected}
K{\footnote FLD1,FLD1;FLDL2T,FLDL2T;FLDL2E,FLDL2E;FLDPI,FLDPI;FLDLG2,FLDLG2;FLDLN2,FLDLN2;FLDZ,FLDZ;FLD1,Flags affected;FLDL2T,Flags affected;FLDL2E,Flags affected;FLDPI,Flags affected;FLDLG2,Flags affected;FLDLN2,Flags affected;FLDZ,Flags affected}
#{\footnote FLD1::3}
#{\footnote FLDL2T::3}
#{\footnote FLDL2E::3}
#{\footnote FLDPI::3}
#{\footnote FLDLG2::3}
#{\footnote FLDLN2::3}
#{\footnote FLDZ::3}

{\fs20\b FLD1/FLDL2T/FLDL2E/FLDPI/FLDLG2/FLDLN2/FLDZ}\tab{\b Flags affected}\par\par
FPU Flags Affected
\par 
\par C1 Set to 1 if stack overflow occurred; otherwise, cleared to 0. C0, C2, C3 Undefined.
{\page}

${\footnote FLD1,Exceptions}
K{\footnote FLD1,FLD1;FLDL2T,FLDL2T;FLDL2E,FLDL2E;FLDPI,FLDPI;FLDLG2,FLDLG2;FLDLN2,FLDLN2;FLDZ,FLDZ;FLD1,Exceptions;FLDL2T,Exceptions;FLDL2E,Exceptions;FLDPI,Exceptions;FLDLG2,Exceptions;FLDLN2,Exceptions;FLDZ,Exceptions}
#{\footnote FLD1::4}
#{\footnote FLDL2T::4}
#{\footnote FLDL2E::4}
#{\footnote FLDPI::4}
#{\footnote FLDLG2::4}
#{\footnote FLDLN2::4}
#{\footnote FLDZ::4}

{\fs20\b FLD1/FLDL2T/FLDL2E/FLDPI/FLDLG2/FLDLN2/FLDZ}\tab{\b Exceptions}\par\par
Floating-Point Exceptions
\par 
\par #IS Stack overflow occurred.
\par 
\par Protected Mode Exceptions
\par 
\par #NM EM or TS in CR0 is set.
\par 
\par Real-Address Mode Exceptions
\par 
\par #NM EM or TS in CR0 is set.
\par 
\par Virtual-8086 Mode Exceptions
\par 
\par #NM EM or TS in CR0 is set.
{\page}

${\footnote FLD1,Opcode}
K{\footnote FLD1,FLD1;FLDL2T,FLDL2T;FLDL2E,FLDL2E;FLDPI,FLDPI;FLDLG2,FLDLG2;FLDLN2,FLDLN2;FLDZ,FLDZ;FLD1,Opcode;FLDL2T,Opcode;FLDL2E,Opcode;FLDPI,Opcode;FLDLG2,Opcode;FLDLN2,Opcode;FLDZ,Opcode}
#{\footnote FLD1::5}
#{\footnote FLDL2T::5}
#{\footnote FLDL2E::5}
#{\footnote FLDPI::5}
#{\footnote FLDLG2::5}
#{\footnote FLDLN2::5}
#{\footnote FLDZ::5}

{\fs20\b FLD1/FLDL2T/FLDL2E/FLDPI/FLDLG2/FLDLN2/FLDZ}\tab{\b Opcode}\par\par
D9 E8 FLD1 Push +1.0 onto the FPU register stack.
\par D9 E9 FLDL2T Push log 2 10 onto the FPU register stack.
\par D9 EA FLDL2E Push log 2 e onto the FPU register stack.
\par D9 EB FLDPI Push p onto the FPU register stack.
\par D9 EC FLDLG2 Push log 10 2 onto the FPU register stack.
\par D9 ED FLDLN2 Push log e 2 onto the FPU register stack.
\par D9 EE FLDZ Push +0.0 onto the FPU register stack.
{\page}

${\footnote FLDCW,Description}
K{\footnote FLDCW,FLDCW;FLDCW,Description}
#{\footnote FLDCW::1}

{\fs20\b FLDCW}\tab{\b Description}\par\par
FLDCW: Load Control Word
\par 
\par Loads the 16-bit source operand into the FPU control word. The source operand is a memory location. This instruction is typically used to establish or change the FPU's mode of operation. If one or more exception flags are set in the FPU status word prior to loading a new FPU control word and the new control word unmasks one or more of those exceptions, a floating-point exception will be generated upon execution of the next floating-point instruction (except for the no-wait floating-point instructions). To avoid raising exceptions when changing FPU operating modes, clear any pending exceptions (using the FCLEX or FNCLEX instruction) before loading the new control word.
{\page}

${\footnote FLDCW,Operation}
K{\footnote FLDCW,FLDCW;FLDCW,Operation}
#{\footnote FLDCW::2}

{\fs20\b FLDCW}\tab{\b Operation}\par\par
FPUControlWord <- SRC;
{\page}

${\footnote FLDCW,Flags affected}
K{\footnote FLDCW,FLDCW;FLDCW,Flags affected}
#{\footnote FLDCW::3}

{\fs20\b FLDCW}\tab{\b Flags affected}\par\par
FPU Flags Affected
\par 
\par C0, C1, C2, C3 undefined.
{\page}

${\footnote FLDCW,Exceptions}
K{\footnote FLDCW,FLDCW;FLDCW,Exceptions}
#{\footnote FLDCW::4}

{\fs20\b FLDCW}\tab{\b Exceptions}\par\par
Floating-Point Exceptions
\par 
\par None; however, this operation might unmask a pending exception in the FPU status word. That exception is then generated upon execution of the next "waiting" floating-point instruction.
\par 
\par Protected Mode Exceptions
\par 
\par #GP(0) If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit. If the DS, ES, FS, or GS register is used to access memory and it contains a null segment selector.
\par #SS(0) If a memory operand effective address is outside the SS segment limit.
\par #NM EM or TS in CR0 is set.
\par #PF(fault-code) If a page fault occurs.
\par #AC(0) If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.
\par 
\par Real-Address Mode Exceptions
\par 
\par #GP If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.
\par #SS If a memory operand effective address is outside the SS segment limit.
\par #NM EM or TS in CR0 is set.
\par 
\par Virtual-8086 Mode Exceptions
\par 
\par #GP(0) If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.
\par #SS(0) If a memory operand effective address is outside the SS segment limit.
\par #NM EM or TS in CR0 is set.
\par #PF(fault-code) If a page fault occurs.
\par #AC(0) If alignment checking is enabled and an unaligned memory reference is made.
{\page}

${\footnote FLDCW,Opcode}
K{\footnote FLDCW,FLDCW;FLDCW,Opcode}
#{\footnote FLDCW::5}

{\fs20\b FLDCW}\tab{\b Opcode}\par\par
D9 /5 FLDCW m2byte Load FPU control word from m2byte.
{\page}

${\footnote FLDENV,Description}
K{\footnote FLDENV,FLDENV;FLDENV,Description}
#{\footnote FLDENV::1}

{\fs20\b FLDENV}\tab{\b Description}\par\par
FLDENV: Load FPU Environment
\par 
\par Loads the complete FPU operating environment from memory into the FPU registers. The source operand specifies the first byte of the operating-environment data in memory. This data is typically written to the specified memory location by a FSTENV or FNSTENV instruction. The FPU operating environment consists of the FPU control word, status word, tag word, instruction pointer, data pointer, and last opcode. In virtual-8086 mode, the real mode layouts are used. The FLDENV instruction should be executed in the same operating mode as the corresponding FSTENV/FNSTENV instruction. If one or more unmasked exception flags are set in the new FPU status word, a floating-point exception will be generated upon execution of the next floating-point instruction (except for the no-wait floating-point instructions). To avoid generating exceptions when loading a new environment, clear all the exception flags in the FPU status word that is being loaded.
{\page}

${\footnote FLDENV,Operation}
K{\footnote FLDENV,FLDENV;FLDENV,Operation}
#{\footnote FLDENV::2}

{\fs20\b FLDENV}\tab{\b Operation}\par\par
FPUControlWord <- SRC(FPUControlWord);
\par FPUStatusWord <- SRC(FPUStatusWord);
\par FPUTagWord <- SRC(FPUTagWord);
\par FPUDataPointer <- SRC(FPUDataPointer);
\par FPUInstructionPointer <- SRC(FPUInstructionPointer);
\par FPULastInstructionOpcode <- SRC(FPULastInstructionOpcode);
{\page}

${\footnote FLDENV,Flags affected}
K{\footnote FLDENV,FLDENV;FLDENV,Flags affected}
#{\footnote FLDENV::3}

{\fs20\b FLDENV}\tab{\b Flags affected}\par\par
FPU Flags Affected
\par 
\par The C0, C1, C2, C3 flags are loaded.
{\page}

${\footnote FLDENV,Exceptions}
K{\footnote FLDENV,FLDENV;FLDENV,Exceptions}
#{\footnote FLDENV::4}

{\fs20\b FLDENV}\tab{\b Exceptions}\par\par
Floating-Point Exceptions
\par 
\par None; however, if an unmasked exception is loaded in the status word, it is generated upon execution of the next "waiting" floating-point instruction.
\par 
\par Protected Mode Exceptions
\par 
\par #GP(0) If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit. If the DS, ES, FS, or GS register is used to access memory and it contains a null segment selector.
\par #SS(0) If a memory operand effective address is outside the SS segment limit.
\par #NM EM or TS in CR0 is set.
\par #PF(fault-code) If a page fault occurs.
\par #AC(0) If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.
\par 
\par Real-Address Mode Exceptions
\par 
\par #GP If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.
\par #SS If a memory operand effective address is outside the SS segment limit.
\par #NM EM or TS in CR0 is set.
\par 
\par Virtual-8086 Mode Exceptions
\par 
\par #GP(0) If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.
\par #SS(0) If a memory operand effective address is outside the SS segment limit.
\par #NM EM or TS in CR0 is set.
\par #PF(fault-code) If a page fault occurs.
\par #AC(0) If alignment checking is enabled and an unaligned memory reference is made.
{\page}

${\footnote FLDENV,Opcode}
K{\footnote FLDENV,FLDENV;FLDENV,Opcode}
#{\footnote FLDENV::5}

{\fs20\b FLDENV}\tab{\b Opcode}\par\par
D9 /4 FLDENV m14/28byte Load FPU environment from m14byte or m28byte.
{\page}

${\footnote FMUL,Description}
K{\footnote FMUL,FMUL;FMULP,FMULP;FIMUL,FIMUL;FMUL,Description;FMULP,Description;FIMUL,Description}
#{\footnote FMUL::1}
#{\footnote FMULP::1}
#{\footnote FIMUL::1}

{\fs20\b FMUL/FMULP/FIMUL}\tab{\b Description}\par\par
FMUL/FMULP/FIMUL: Multiply
\par 
\par Multiplies the destination and source operands and stores the product in the destination location. The destination operand is always an FPU data register; the source operand can be an FPU data register or a memory location. Source operands in memory can be in single-real, double-real, word-integer, or short-integer formats.
\par The no-operand version of the instruction multiplies the contents of the ST(1) register by the contents of the ST(0) register and stores the product in the ST(1) register. The one-operand version multiplies the contents of the ST(0) register by the contents of a memory location (either a real or an integer value) and stores the product in the ST(0) register. The two-operand version, multiplies the contents of the ST(0) register by the contents of the ST(i) register, or vice versa, with the result being stored in the register specified with the first operand (the destination operand).
\par The FMULP instructions perform the additional operation of popping the FPU register stack after storing the product. To pop the register stack, the processor marks the ST(0) register as empty and increments the stack pointer (TOP) by 1. The no-operand version of the floating-point multiply instructions always results in the register stack being popped. In some assemblers, the mnemonic for this instruction is FMUL rather than FMULP. The FIMUL instructions convert an integer source operand to extended-real format before performing the multiplication. The sign of the result is always the exclusive-OR of the source signs, even if one or more of the values being multiplied is 0 or (infinity). When the source operand is an integer 0, it is treated as a +0.
{\page}

${\footnote FMUL,Operation}
K{\footnote FMUL,FMUL;FMULP,FMULP;FIMUL,FIMUL;FMUL,Operation;FMULP,Operation;FIMUL,Operation}
#{\footnote FMUL::2}
#{\footnote FMULP::2}
#{\footnote FIMUL::2}

{\fs20\b FMUL/FMULP/FIMUL}\tab{\b Operation}\par\par
IF instruction is FIMUL
\par THEN
\par DEST <- DEST * ConvertExtendedReal(SRC);
\par ELSE (* source operand is real number *)
\par DEST <- DEST * SRC;
\par FI;
\par IF instruction = FMULP
\par THEN
\par PopRegisterStack
\par FI;
{\page}

${\footnote FMUL,Flags affected}
K{\footnote FMUL,FMUL;FMULP,FMULP;FIMUL,FIMUL;FMUL,Flags affected;FMULP,Flags affected;FIMUL,Flags affected}
#{\footnote FMUL::3}
#{\footnote FMULP::3}
#{\footnote FIMUL::3}

{\fs20\b FMUL/FMULP/FIMUL}\tab{\b Flags affected}\par\par
FPU Flags Affected
\par 
\par C1 Set to 0 if stack underflow occurred. Indicates rounding direction if the inexact-result exception (#P) fault is generated: 0 = not roundup; 1 = roundup. C0, C2, C3 Undefined.
{\page}

${\footnote FMUL,Exceptions}
K{\footnote FMUL,FMUL;FMULP,FMULP;FIMUL,FIMUL;FMUL,Exceptions;FMULP,Exceptions;FIMUL,Exceptions}
#{\footnote FMUL::4}
#{\footnote FMULP::4}
#{\footnote FIMUL::4}

{\fs20\b FMUL/FMULP/FIMUL}\tab{\b Exceptions}\par\par
Floating-Point Exceptions
\par 
\par #IS Stack underflow occurred.
\par #IA Operand is an SNaN value or unsupported format. One operand is 0 and the other is (infinity).
\par #D Source operand is a denormal value.
\par #U Result is too small for destination format.
\par #O Result is too large for destination format.
\par #P Value cannot be represented exactly in destination format.
\par 
\par Protected Mode Exceptions
\par 
\par #GP(0) If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit. If the DS, ES, FS, or GS register is used to access memory and it contains a null segment selector.
\par #SS(0) If a memory operand effective address is outside the SS segment limit.
\par #NM EM or TS in CR0 is set.
\par #PF(fault-code) If a page fault occurs.
\par #AC(0) If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.
\par 
\par Real-Address Mode Exceptions
\par 
\par #GP If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.
\par #SS If a memory operand effective address is outside the SS segment limit.
\par #NM EM or TS in CR0 is set.
\par 
\par Virtual-8086 Mode Exceptions
\par 
\par #GP(0) If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.
\par #SS(0) If a memory operand effective address is outside the SS segment limit.
\par #NM EM or TS in CR0 is set.
\par #PF(fault-code) If a page fault occurs.
\par #AC(0) If alignment checking is enabled and an unaligned memory reference is made.
{\page}

${\footnote FMUL,Opcode}
K{\footnote FMUL,FMUL;FMULP,FMULP;FIMUL,FIMUL;FMUL,Opcode;FMULP,Opcode;FIMUL,Opcode}
#{\footnote FMUL::5}
#{\footnote FMULP::5}
#{\footnote FIMUL::5}

{\fs20\b FMUL/FMULP/FIMUL}\tab{\b Opcode}\par\par
D8 /1 FMUL m32real Multiply ST(0) by m32real and store result in ST(0)
\par DC /1 FMUL m64real Multiply ST(0) by m64real and store result in ST(0)
\par D8 C8+i FMUL ST(0), ST(i) Multiply ST(0) by ST(i) and store result in ST(0)
\par DC C8+i FMUL ST(i), ST(0) Multiply ST(i) by ST(0) and store result in ST(i)
\par DE C8+i FMULP ST(i), ST(0) Multiply ST(i) by ST(0), store result in ST(i), and pop the register stack
\par DE C9 FMULP Multiply ST(1) by ST(0), store result in ST(1), and pop the register stack
\par DA /1 FIMUL m32int Multiply ST(0) by m32int and store result in ST(0)
\par DE /1 FIMUL m16int Multiply ST(0) by m16int and store result in ST(0)
{\page}

${\footnote FNOP,Description}
K{\footnote FNOP,FNOP;FNOP,Description}
#{\footnote FNOP::1}

{\fs20\b FNOP}\tab{\b Description}\par\par
FNOP: No Operation
\par 
\par Performs no FPU operation. This instruction takes up space in the instruction stream but does not affect the FPU or machine context, except the EIP register.
{\page}

${\footnote FNOP,Operation}
K{\footnote FNOP,FNOP;FNOP,Operation}
#{\footnote FNOP::2}

{\fs20\b FNOP}\tab{\b Operation}\par\par
No Operation
{\page}

${\footnote FNOP,Flags affected}
K{\footnote FNOP,FNOP;FNOP,Flags affected}
#{\footnote FNOP::3}

{\fs20\b FNOP}\tab{\b Flags affected}\par\par
FPU Flags Affected
\par 
\par C0, C1, C2, C3 undefined.
{\page}

${\footnote FNOP,Exceptions}
K{\footnote FNOP,FNOP;FNOP,Exceptions}
#{\footnote FNOP::4}

{\fs20\b FNOP}\tab{\b Exceptions}\par\par
Floating-Point Exceptions
\par 
\par None.
\par 
\par Protected Mode Exceptions
\par 
\par #NM EM or TS in CR0 is set.
\par 
\par Real-Address Mode Exceptions
\par 
\par #NM EM or TS in CR0 is set.
\par 
\par Virtual-8086 Mode Exceptions
\par 
\par #NM EM or TS in CR0 is set.
{\page}

${\footnote FNOP,Opcode}
K{\footnote FNOP,FNOP;FNOP,Opcode}
#{\footnote FNOP::5}

{\fs20\b FNOP}\tab{\b Opcode}\par\par
D9 D0 FNOP No operation is performed.
{\page}

${\footnote FPATAN,Description}
K{\footnote FPATAN,FPATAN;FPATAN,Description}
#{\footnote FPATAN::1}

{\fs20\b FPATAN}\tab{\b Description}\par\par
FPATAN: Partial Arctangent
\par 
\par Computes the arctangent of the source operand in register ST(1) divided by the source operand in register ST(0), stores the result in ST(1), and pops the FPU register stack. The result in register ST(0) has the same sign as the source operand ST(1) and a magnitude less than +p. The FPATAN instruction returns the angle between the X axis and the line from the origin to the point (X,Y), where Y (the ordinate) is ST(1) and X (the abscissa) is ST(0). The angle depends on the sign of X and Y independently, not just on the sign of the ratio Y/X. This is because a point (-X,Y) is in the second quadrant, resulting in an angle between p/2 and p, while a point (X,-Y) is in the fourth quadrant, resulting in an angle between 0 and -p/2. A point (-X,-Y) is in the third quadrant, giving an angle between -p/2 and -p. There is no restriction on the range of source operands that FPATAN can accept.
\par 
\par Intel Architecture Compatibility
\par 
\par The source operands for this instruction are restricted for the 80287 math coprocessor to the following range: 0  |ST(1)| < |ST(0)| < +(infinity)
{\page}

${\footnote FPATAN,Operation}
K{\footnote FPATAN,FPATAN;FPATAN,Operation}
#{\footnote FPATAN::2}

{\fs20\b FPATAN}\tab{\b Operation}\par\par
ST(1) <- arctan(ST(1) / ST(0));
\par PopRegisterStack;
{\page}

${\footnote FPATAN,Flags affected}
K{\footnote FPATAN,FPATAN;FPATAN,Flags affected}
#{\footnote FPATAN::3}

{\fs20\b FPATAN}\tab{\b Flags affected}\par\par
FPU Flags Affected
\par 
\par C1 Set to 0 if stack underflow occurred. Indicates rounding direction if the inexact-result exception (#P) is generated: 0 = not roundup; 1 = roundup. C0, C2, C3 Undefined.
{\page}

${\footnote FPATAN,Exceptions}
K{\footnote FPATAN,FPATAN;FPATAN,Exceptions}
#{\footnote FPATAN::4}

{\fs20\b FPATAN}\tab{\b Exceptions}\par\par
Floating-Point Exceptions
\par 
\par #IS Stack underflow occurred.
\par #IA Source operand is an SNaN value or unsupported format.
\par #D Source operand is a denormal value.
\par #U Result is too small for destination format.
\par #P Value cannot be represented exactly in destination format.
\par 
\par Protected Mode Exceptions
\par 
\par #NM EM or TS in CR0 is set.
\par 
\par Real-Address Mode Exceptions
\par 
\par #NM EM or TS in CR0 is set.
\par 
\par Virtual-8086 Mode Exceptions
\par 
\par #NM EM or TS in CR0 is set.
{\page}

${\footnote FPATAN,Opcode}
K{\footnote FPATAN,FPATAN;FPATAN,Opcode}
#{\footnote FPATAN::5}

{\fs20\b FPATAN}\tab{\b Opcode}\par\par
D9 F3 FPATAN Replace ST(1) with arctan(ST(1)/ST(0)) and pop the register stack
{\page}

${\footnote FPREM,Description}
K{\footnote FPREM,FPREM;FPREM,Description}
#{\footnote FPREM::1}

{\fs20\b FPREM}\tab{\b Description}\par\par
FPREM - Partial Remainder
\par 
\par Computes the remainder obtained from dividing the value in the ST(0) register (the dividend) by the value in the ST(1) register (the divisor or modulus), and stores the result in ST(0). The remainder represents the following value: Remainder = ST(0) - (Q * ST(1))
\par Here, Q is an integer value that is obtained by truncating the real-number quotient of [ST(0) / ST(1)] toward zero. The sign of the remainder is the same as the sign of the dividend. The magnitude of the remainder is less than that of the modulus, unless a partial remainder was computed (as described below). This instruction produces an exact result; the precision (inexact) exception does not occur and the rounding control has no effect. The FPREM instruction does not compute the remainder specified in IEEE Std 754. The IEEE specified remainder can be computed with the FPREM1 instruction. The FPREM instruction is provided for compatibility with the Intel 8087 and Intel287 math coprocessors.
\par The FPREM instruction gets its name "partial remainder" because of the way it computes the remainder. This instructions arrives at a remainder through iterative subtraction. It can, however, reduce the exponent of ST(0) by no more than 63 in one execution of the instruction. If the instruction succeeds in producing a remainder that is less than the modulus, the operation is complete and the C2 flag in the FPU status word is cleared. Otherwise, C2 is set, and the result in ST(0) is called the partial remainder. The exponent of the partial remainder will be less than the exponent of the original dividend by at least 32. Software can re-execute the instruction (using the partial remainder in ST(0) as the dividend) until C2 is cleared. (Note that while executing such a remainder-computation loop, a higher-priority interrupting routine that needs the FPU can force a context switch in-between the instructions in the loop.)
\par An important use of the FPREM instruction is to reduce the arguments of periodic functions. When reduction is complete, the instruction stores the three least-significant bits of the quotient in the C3, C1, and C0 flags of the FPU status word. This information is important in argument reduction for the tangent function (using a modulus of p/4), because it locates the original angle in the correct one of eight sectors of the unit circle.
{\page}

${\footnote FPREM,Operation}
K{\footnote FPREM,FPREM;FPREM,Operation}
#{\footnote FPREM::2}

{\fs20\b FPREM}\tab{\b Operation}\par\par
D <- exponent(ST(0)) - exponent(ST(1));
\par IF D < 64
\par THEN
\par Q <- Integer(TruncateTowardZero(ST(0) / ST(1)));
\par ST(0) <- ST(0) - (ST(1) * Q);
\par C2 <- 0;
\par C0, C3, C1 <- LeastSignificantBits(Q); (* Q2, Q1, Q0 *)
\par ELSE
\par C2 <- 1;
\par N <- an implementation-dependent number between 32 and 63;
\par QQ <- Integer(TruncateTowardZero((ST(0) / ST(1)) / 2 (D - N) ));
\par ST(0) <- ST(0) - (ST(1) * QQ * 2 (D - N) );
\par FI;
{\page}

${\footnote FPREM,Flags affected}
K{\footnote FPREM,FPREM;FPREM,Flags affected}
#{\footnote FPREM::3}

{\fs20\b FPREM}\tab{\b Flags affected}\par\par
FPU Flags Affected
\par 
\par C0 Set to bit 2 (Q2) of the quotient.
\par C1 Set to 0 if stack underflow occurred; otherwise, set to least significant bit of quotient (Q0).
\par C2 Set to 0 if reduction complete; set to 1 if incomplete.
\par C3 Set to bit 1 (Q1) of the quotient.
{\page}

${\footnote FPREM,Exceptions}
K{\footnote FPREM,FPREM;FPREM,Exceptions}
#{\footnote FPREM::4}

{\fs20\b FPREM}\tab{\b Exceptions}\par\par
Floating-Point Exceptions
\par 
\par #IS Stack underflow occurred.
\par #IA Source operand is an SNaN value, modulus is 0, dividend is (infinity), or unsupported format.
\par #D Source operand is a denormal value.
\par #U Result is too small for destination format.
\par 
\par Protected Mode Exceptions
\par 
\par #NM EM or TS in CR0 is set.
\par 
\par Real-Address Mode Exceptions
\par 
\par #NM EM or TS in CR0 is set.
\par 
\par Virtual-8086 Mode Exceptions
\par 
\par #NM EM or TS in CR0 is set.
{\page}

${\footnote FPREM,Opcode}
K{\footnote FPREM,FPREM;FPREM,Opcode}
#{\footnote FPREM::5}

{\fs20\b FPREM}\tab{\b Opcode}\par\par
D9 F8 FPREM Replace ST(0) with the remainder obtained from
{\page}

${\footnote FPREM1,Description}
K{\footnote FPREM1,FPREM1;FPREM1,Description}
#{\footnote FPREM1::1}

{\fs20\b FPREM1}\tab{\b Description}\par\par
FPREM1: Partial Remainder
\par 
\par Computes the IEEE remainder obtained from dividing the value in the ST(0) register (the dividend) by the value in the ST(1) register (the divisor or modulus), and stores the result in ST(0). The remainder represents the following value: Remainder = ST(0) - (Q * ST(1))
\par Here, Q is an integer value that is obtained by rounding the real-number quotient of [ST(0) / ST(1)] toward the nearest integer value. The magnitude of the remainder is less than half the magnitude of the modulus, unless a partial remainder was computed (as described below). This instruction produces an exact result; the precision (inexact) exception does not occur and the rounding control has no effect. The following table shows the results obtained when computing the remainder of various classes of numbers, assuming that underflow does not occur. The FPREM1 instruction computes the remainder specified in IEEE Std 754. This instruction operates differently from the FPREM instruction in the way that it rounds the quotient of ST(0) divided by ST(1) to an integer (see the "Operation" section).
\par Like the FPREM instruction, the FPREM1 computes the remainder through iterative subtraction, but can reduce the exponent of ST(0) by no more than 63 in one execution of the instruction. If the instruction succeeds in producing a remainder that is less than one half the modulus, the operation is complete and the C2 flag in the FPU status word is cleared. Otherwise, C2 is set, and the result in ST(0) is called the partial remainder. The exponent of the partial remainder will be less than the exponent of the original dividend by at least 32. Software can re-execute the instruction (using the partial remainder in ST(0) as the dividend) until C2 is cleared. (Note that while executing such a remainder-computation loop, a higher-priority interrupting routine that needs the FPU can force a context switch in-between the instructions in the loop.) An important use of the FPREM1 instruction is to reduce the arguments of periodic functions. When reduction is complete, the instruction stores the three least-significant bits of the quotient in the C3, C1, and C0 flags of the FPU status word. This information is important in argument reduction for the tangent function (using a modulus of p/4), because it locates the original angle in the correct one of eight sectors of the unit circle.
{\page}

${\footnote FPREM1,Operation}
K{\footnote FPREM1,FPREM1;FPREM1,Operation}
#{\footnote FPREM1::2}

{\fs20\b FPREM1}\tab{\b Operation}\par\par
D <- exponent(ST(0)) - exponent(ST(1));
\par IF D < 64
\par THEN
\par Q <- Integer(RoundTowardNearestInteger(ST(0) / ST(1)));
\par ST(0) <- ST(0) - (ST(1) * Q);
\par C2 <- 0;
\par C0, C3, C1 <- LeastSignificantBits(Q); (* Q2, Q1, Q0 *)
\par ELSE
\par C2 <- 1;
\par N <- an implementation-dependent number between 32 and 63;
\par QQ <- Integer(TruncateTowardZero((ST(0) / ST(1)) / 2 (D - N) ));
\par ST(0) <- ST(0) - (ST(1) * QQ * 2 (D - N) );
\par FI;
{\page}

${\footnote FPREM1,Flags affected}
K{\footnote FPREM1,FPREM1;FPREM1,Flags affected}
#{\footnote FPREM1::3}

{\fs20\b FPREM1}\tab{\b Flags affected}\par\par
FPU Flags Affected
\par 
\par C0 Set to bit 2 (Q2) of the quotient.
\par C1 Set to 0 if stack underflow occurred; otherwise, set to least significant bit of quotient (Q0).
\par C2 Set to 0 if reduction complete; set to 1 if incomplete.
\par C3 Set to bit 1 (Q1) of the quotient.
{\page}

${\footnote FPREM1,Exceptions}
K{\footnote FPREM1,FPREM1;FPREM1,Exceptions}
#{\footnote FPREM1::4}

{\fs20\b FPREM1}\tab{\b Exceptions}\par\par
Floating-Point Exceptions
\par 
\par #IS Stack underflow occurred.
\par #IA Source operand is an SNaN value, modulus (divisor) is 0, dividend is (infinity), or unsupported format.
\par #D Source operand is a denormal value.
\par #U Result is too small for destination format.
\par 
\par Protected Mode Exceptions
\par 
\par #NM EM or TS in CR0 is set.
\par 
\par Real-Address Mode Exceptions
\par 
\par #NM EM or TS in CR0 is set.
\par 
\par Virtual-8086 Mode Exceptions
\par 
\par #NM EM or TS in CR0 is set.
{\page}

${\footnote FPREM1,Opcode}
K{\footnote FPREM1,FPREM1;FPREM1,Opcode}
#{\footnote FPREM1::5}

{\fs20\b FPREM1}\tab{\b Opcode}\par\par
D9 F5 FPREM1 Replace ST(0) with the IEEE remainder obtained from dividing ST(0) by ST(1)
{\page}

${\footnote FPTAN,Description}
K{\footnote FPTAN,FPTAN;FPTAN,Description}
#{\footnote FPTAN::1}

{\fs20\b FPTAN}\tab{\b Description}\par\par
FPTAN: Partial Tangent
\par 
\par Computes the tangent of the source operand in register ST(0), stores the result in ST(0), and pushes a 1.0 onto the FPU register stack. The source operand must be given in radians and must be less than 2^63 . If the source operand is outside the acceptable range, the C2 flag in the FPU status word is set, and the value in register ST(0) remains unchanged. The instruction does not raise an exception when the source operand is out of range. It is up to the program to check the C2 flag for out-of-range conditions. Source values outside the range -2^63 to +2^63 can be reduced to the range of the instruction by subtracting an appropriate integer multiple of 2p or by using the FPREM instruction with a divisor of 2p. The value 1.0 is pushed onto the register stack after the tangent has been computed to maintain compatibility with the Intel 8087 and Intel287 math coprocessors. This operation also simplifies the calculation of other trigonometric functions. For instance, the cotangent (which is the reciprocal of the tangent) can be computed by executing a FDIVR instruction after the FPTAN instruction.
{\page}

${\footnote FPTAN,Operation}
K{\footnote FPTAN,FPTAN;FPTAN,Operation}
#{\footnote FPTAN::2}

{\fs20\b FPTAN}\tab{\b Operation}\par\par
IF ST(0) < 2 63
\par THEN
\par C2 <- 0;
\par ST(0) <- tan(ST(0));
\par TOP <- TOP - 1;
\par ST(0) <- 1.0;
\par ELSE (*source operand is out-of-range *)
\par C2 <- 1;
\par FI;
{\page}

${\footnote FPTAN,Flags affected}
K{\footnote FPTAN,FPTAN;FPTAN,Flags affected}
#{\footnote FPTAN::3}

{\fs20\b FPTAN}\tab{\b Flags affected}\par\par
FPU Flags Affected
\par 
\par C1 Set to 0 if stack underflow occurred; set to 1 if stack overflow occurred. Indicates rounding direction if the inexact-result exception (#P) is generated: 0 = not roundup; 1 = roundup. C2 Set to 1 if source operand is outside the range -2^63 to +2^63 ; otherwise, cleared to 0. C0, C3 Undefined.
{\page}

${\footnote FPTAN,Exceptions}
K{\footnote FPTAN,FPTAN;FPTAN,Exceptions}
#{\footnote FPTAN::4}

{\fs20\b FPTAN}\tab{\b Exceptions}\par\par
Floating-Point Exceptions
\par 
\par #IS Stack underflow occurred.
\par #IA Source operand is an SNaN value, (infinity), or unsupported format.
\par #D Source operand is a denormal value.
\par #U Result is too small for destination format.
\par #P Value cannot be represented exactly in destination format.
\par 
\par Protected Mode Exceptions
\par 
\par #NM EM or TS in CR0 is set.
\par 
\par Real-Address Mode Exceptions
\par 
\par #NM EM or TS in CR0 is set.
\par 
\par Virtual-8086 Mode Exceptions
\par 
\par #NM EM or TS in CR0 is set.
{\page}

${\footnote FPTAN,Opcode}
K{\footnote FPTAN,FPTAN;FPTAN,Opcode}
#{\footnote FPTAN::5}

{\fs20\b FPTAN}\tab{\b Opcode}\par\par
D9 F2 FPTAN 17-173 Replace ST(0) with its tangent and push 1 onto the FPU stack.
{\page}

${\footnote FRNDINT,Description}
K{\footnote FRNDINT,FRNDINT;FRNDINT,Description}
#{\footnote FRNDINT::1}

{\fs20\b FRNDINT}\tab{\b Description}\par\par
FRNDINT: Round to Integer
\par 
\par Rounds the source value in the ST(0) register to the nearest integral value, depending on the current rounding mode (setting of the RC field of the FPU control word), and stores the result in ST(0). If the source value is (infinity), the value is not changed. If the source value is not an integral value, the floating-point inexact-result exception (#P) is generated.
{\page}

${\footnote FRNDINT,Operation}
K{\footnote FRNDINT,FRNDINT;FRNDINT,Operation}
#{\footnote FRNDINT::2}

{\fs20\b FRNDINT}\tab{\b Operation}\par\par
ST(0) <- RoundToIntegralValue(ST(0));
{\page}

${\footnote FRNDINT,Flags affected}
K{\footnote FRNDINT,FRNDINT;FRNDINT,Flags affected}
#{\footnote FRNDINT::3}

{\fs20\b FRNDINT}\tab{\b Flags affected}\par\par
FPU Flags Affected
\par 
\par C1 Set to 0 if stack underflow occurred. Indicates rounding direction if the inexact-result exception (#P) is generated: 0 = not roundup; 1 = roundup. C0, C2, C3 Undefined.
{\page}

${\footnote FRNDINT,Exceptions}
K{\footnote FRNDINT,FRNDINT;FRNDINT,Exceptions}
#{\footnote FRNDINT::4}

{\fs20\b FRNDINT}\tab{\b Exceptions}\par\par
Floating-Point Exceptions
\par 
\par #IS Stack underflow occurred.
\par #IA Source operand is an SNaN value or unsupported format.
\par #D Source operand is a denormal value.
\par #P Source operand is not an integral value.
\par 
\par Protected Mode Exceptions
\par 
\par #NM EM or TS in CR0 is set.
\par 
\par Real-Address Mode Exceptions
\par 
\par #NM EM or TS in CR0 is set.
\par 
\par Virtual-8086 Mode Exceptions
\par 
\par #NM EM or TS in CR0 is set.
{\page}

${\footnote FRNDINT,Opcode}
K{\footnote FRNDINT,FRNDINT;FRNDINT,Opcode}
#{\footnote FRNDINT::5}

{\fs20\b FRNDINT}\tab{\b Opcode}\par\par
D9 FC FRNDINT Round ST(0) to an integer.
{\page}

${\footnote FRSTOR,Description}
K{\footnote FRSTOR,FRSTOR;FRSTOR,Description}
#{\footnote FRSTOR::1}

{\fs20\b FRSTOR}\tab{\b Description}\par\par
FRSTOR: Restore FPU State
\par 
\par Loads the FPU state (operating environment and register stack) from the memory area specified with the source operand. This state data is typically written to the specified memory location by a previous FSAVE/FNSAVE instruction. The FPU operating environment consists of the FPU control word, status word, tag word, instruction pointer, data pointer, and last opcode. In virtual-8086 mode, the real mode layouts are used. The contents of the FPU register stack are stored in the 80 bytes immediately follow the operating environment image.
\par The FRSTOR instruction should be executed in the same operating mode as the corresponding FSAVE/FNSAVE instruction. If one or more unmasked exception bits are set in the new FPU status word, a floating-point exception will be generated. To avoid raising exceptions when loading a new operating environment, clear all the exception flags in the FPU status word that is being loaded.
{\page}

${\footnote FRSTOR,Operation}
K{\footnote FRSTOR,FRSTOR;FRSTOR,Operation}
#{\footnote FRSTOR::2}

{\fs20\b FRSTOR}\tab{\b Operation}\par\par
FPUControlWord <- SRC(FPUControlWord);
\par FPUStatusWord <- SRC(FPUStatusWord);
\par FPUTagWord <- SRC(FPUTagWord);
\par FPUDataPointer <- SRC(FPUDataPointer);
\par FPUInstructionPointer <- SRC(FPUInstructionPointer);
\par FPULastInstructionOpcode <- SRC(FPULastInstructionOpcode);
\par ST(0) <- SRC(ST(0));
\par ST(1) <- SRC(ST(1));
\par ST(2) <- SRC(ST(2));
\par ST(3) <- SRC(ST(3));
\par ST(4) <- SRC(ST(4));
\par ST(5) <- SRC(ST(5));
\par ST(6) <- SRC(ST(6));
\par ST(7) <- SRC(ST(7));
{\page}

${\footnote FRSTOR,Flags affected}
K{\footnote FRSTOR,FRSTOR;FRSTOR,Flags affected}
#{\footnote FRSTOR::3}

{\fs20\b FRSTOR}\tab{\b Flags affected}\par\par
FPU Flags Affected
\par 
\par The C0, C1, C2, C3 flags are loaded.
{\page}

${\footnote FRSTOR,Exceptions}
K{\footnote FRSTOR,FRSTOR;FRSTOR,Exceptions}
#{\footnote FRSTOR::4}

{\fs20\b FRSTOR}\tab{\b Exceptions}\par\par
Floating-Point Exceptions
\par 
\par None; however, this operation might unmask an existing exception that has been detected but not generated, because it was masked. Here, the exception is generated at the completion of the instruction.
\par 
\par Protected Mode Exceptions
\par 
\par #GP(0) If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit. If the DS, ES, FS, or GS register is used to access memory and it contains a null segment selector.
\par #SS(0) If a memory operand effective address is outside the SS segment limit.
\par #NM EM or TS in CR0 is set.
\par #PF(fault-code) If a page fault occurs.
\par #AC(0) If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.
\par 
\par Real-Address Mode Exceptions
\par 
\par #GP If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.
\par #SS If a memory operand effective address is outside the SS segment limit.
\par #NM EM or TS in CR0 is set.
\par 
\par Virtual-8086 Mode Exceptions
\par 
\par #GP(0) If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.
\par #SS(0) If a memory operand effective address is outside the SS segment limit.
\par #NM EM or TS in CR0 is set.
\par #PF(fault-code) If a page fault occurs.
\par #AC(0) If alignment checking is enabled and an unaligned memory reference is made.
{\page}

${\footnote FRSTOR,Opcode}
K{\footnote FRSTOR,FRSTOR;FRSTOR,Opcode}
#{\footnote FRSTOR::5}

{\fs20\b FRSTOR}\tab{\b Opcode}\par\par
DD /4 FRSTOR m94/108byte Load FPU state from m94byte or m108byte.
{\page}

${\footnote FSAVE,Description}
K{\footnote FSAVE,FSAVE;FNSAVE,FNSAVE;FSAVE,Description;FNSAVE,Description}
#{\footnote FSAVE::1}
#{\footnote FNSAVE::1}

{\fs20\b FSAVE/FNSAVE}\tab{\b Description}\par\par
FSAVE/FNSAVE: Store FPU State
\par 
\par Stores the current FPU state (operating environment and register stack) at the specified destination in memory, and then re-initializes the FPU. The FSAVE instruction checks for and handles pending unmasked floating-point exceptions before storing the FPU state; the FNSAVE instruction does not.
\par The FPU operating environment consists of the FPU control word, status word, tag word, instruction pointer, data pointer, and last opcode. In virtual-8086 mode, the real mode layouts are used. The contents of the FPU register stack are stored in the 80 bytes immediately follow the operating environment image. The saved image reflects the state of the FPU after all floating-point instructions preceding the FSAVE/FNSAVE instruction in the instruction stream have been executed. After the FPU state has been saved, the FPU is reset to the same default values it is set to with the FINIT/FNINIT instructions. The FSAVE/FNSAVE instructions are typically used when the operating system needs to perform a context switch, an exception handler needs to use the FPU, or an application program needs to pass a "clean" FPU to a procedure.
\par 
\par Intel Architecture Compatibility
\par 
\par For Intel math coprocessors and FPUs prior to the Intel Pentium processor, an FWAIT instruction should be executed before attempting to read from the memory image stored with a prior FSAVE/FNSAVE instruction. This FWAIT instruction helps insure that the storage operation has been completed.
\par When operating a Pentium or Intel486 processor in MS-DOS compatibility mode, it is possible (under unusual circumstances) for an FNSAVE instruction to be interrupted prior to being executed to handle a pending FPU exception. An FNSAVE instruction cannot be interrupted in this way on a Pentium Pro processor.
{\page}

${\footnote FSAVE,Operation}
K{\footnote FSAVE,FSAVE;FNSAVE,FNSAVE;FSAVE,Operation;FNSAVE,Operation}
#{\footnote FSAVE::2}
#{\footnote FNSAVE::2}

{\fs20\b FSAVE/FNSAVE}\tab{\b Operation}\par\par
(* Save FPU State and Registers *)
\par DEST(FPUControlWord) <- FPUControlWord;
\par DEST(FPUStatusWord) <- FPUStatusWord;
\par DEST(FPUTagWord) <- FPUTagWord;
\par DEST(FPUDataPointer) <- FPUDataPointer;
\par DEST(FPUInstructionPointer) <- FPUInstructionPointer;
\par DEST(FPULastInstructionOpcode) <- FPULastInstructionOpcode;
\par DEST(ST(0)) <- ST(0);
\par DEST(ST(1)) <- ST(1);
\par DEST(ST(2)) <- ST(2);
\par DEST(ST(3)) <- ST(3);
\par DEST(ST(4)) <- ST(4);
\par DEST(ST(5)) <- ST(5);
\par DEST(ST(6)) <- ST(6);
\par DEST(ST(7)) <- ST(7);
\par (* Initialize FPU *)
\par FPUControlWord <- 037FH;
\par FPUStatusWord <- 0;
\par FPUTagWord <- FFFFH;
\par FPUDataPointer <- 0;
\par FPUInstructionPointer <- 0;
\par FPULastInstructionOpcode <- 0;
{\page}

${\footnote FSAVE,Flags affected}
K{\footnote FSAVE,FSAVE;FNSAVE,FNSAVE;FSAVE,Flags affected;FNSAVE,Flags affected}
#{\footnote FSAVE::3}
#{\footnote FNSAVE::3}

{\fs20\b FSAVE/FNSAVE}\tab{\b Flags affected}\par\par
FPU Flags Affected
\par 
\par The C0, C1, C2, and C3 flags are saved and then cleared.
{\page}

${\footnote FSAVE,Exceptions}
K{\footnote FSAVE,FSAVE;FNSAVE,FNSAVE;FSAVE,Exceptions;FNSAVE,Exceptions}
#{\footnote FSAVE::4}
#{\footnote FNSAVE::4}

{\fs20\b FSAVE/FNSAVE}\tab{\b Exceptions}\par\par
Floating-Point Exceptions
\par 
\par None.
\par 
\par Protected Mode Exceptions
\par 
\par #GP(0) If destination is located in a nonwritable segment. If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit. If the DS, ES, FS, or GS register is used to access memory and it contains a null segment selector.
\par #SS(0) If a memory operand effective address is outside the SS segment limit.
\par #NM EM or TS in CR0 is set.
\par #PF(fault-code) If a page fault occurs.
\par #AC(0) If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.
\par 
\par Real-Address Mode Exceptions
\par 
\par #GP If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.
\par #SS If a memory operand effective address is outside the SS segment limit.
\par #NM EM or TS in CR0 is set.
\par 
\par Virtual-8086 Mode Exceptions
\par 
\par #GP(0) If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.
\par #SS(0) If a memory operand effective address is outside the SS segment limit.
\par #NM EM or TS in CR0 is set.
\par #PF(fault-code) If a page fault occurs.
\par #AC(0) If alignment checking is enabled and an unaligned memory reference is made.
{\page}

${\footnote FSAVE,Opcode}
K{\footnote FSAVE,FSAVE;FNSAVE,FNSAVE;FSAVE,Opcode;FNSAVE,Opcode}
#{\footnote FSAVE::5}
#{\footnote FNSAVE::5}

{\fs20\b FSAVE/FNSAVE}\tab{\b Opcode}\par\par
9B DD /6 FSAVE m94/108byte Store FPU state to m94byte or m108byte after checking for pending unmasked floating-point exceptions. Then re-initialize the FPU.
\par DD /6 FNSAVE* m94/108byte Store FPU environment to m94byte or m108byte without checking for pending unmasked floating-point exceptions. Then re-initialize the FPU.
{\page}

${\footnote FSCALE,Description}
K{\footnote FSCALE,FSCALE;FSCALE,Description}
#{\footnote FSCALE::1}

{\fs20\b FSCALE}\tab{\b Description}\par\par
FSCALE: Scale
\par 
\par Multiplies the destination operand by 2 to the power of the source operand and stores the result in the destination operand. The destination operand is a real value that is located in register ST(0). The source operand is the nearest integer value that is smaller than the value in the ST(1) register (that is, the value in register ST(1) is truncated toward 0 to its nearest integer value to form the source operand). This instruction provides rapid multiplication or division by integral powers of 2 because it is implemented by simply adding an integer value (the source operand) to the exponent of the value in register ST(0).
\par In most cases, only the exponent is changed and the mantissa (significand) remains unchanged. However, when the value being scaled in ST(0) is a denormal value, the mantissa is also changed and the result may turn out to be a normalized number. Similarly, if overflow or underflow results from a scale operation, the resulting mantissa will differ from the source's mantissa. The FSCALE instruction can also be used to reverse the action of the FXTRACT instruction, as shown in the following example:
\par FXTRACT;
\par FSCALE;
\par FSTP ST(1);
\par In this example, the FXTRACT instruction extracts the significand and exponent from the value in ST(0) and stores them in ST(0) and ST(1) respectively. The FSCALE then scales the significand in ST(0) by the exponent in ST(1), recreating the original value before the FXTRACT operation was performed. The FSTP ST(1) instruction overwrites the exponent (extracted by the FXTRACT instruction) with the recreated value, which returns the stack to its original state with only one register [ST(0)] occupied.
{\page}

${\footnote FSCALE,Operation}
K{\footnote FSCALE,FSCALE;FSCALE,Operation}
#{\footnote FSCALE::2}

{\fs20\b FSCALE}\tab{\b Operation}\par\par
ST(0) <- ST(0) * 2 ST(1) ;
{\page}

${\footnote FSCALE,Flags affected}
K{\footnote FSCALE,FSCALE;FSCALE,Flags affected}
#{\footnote FSCALE::3}

{\fs20\b FSCALE}\tab{\b Flags affected}\par\par
FPU Flags Affected
\par 
\par C1 Set to 0 if stack underflow occurred. Indicates rounding direction if the inexact-result exception (#P) is generated: 0 = not roundup; 1 = roundup. C0, C2, C3 Undefined.
{\page}

${\footnote FSCALE,Exceptions}
K{\footnote FSCALE,FSCALE;FSCALE,Exceptions}
#{\footnote FSCALE::4}

{\fs20\b FSCALE}\tab{\b Exceptions}\par\par
Floating-Point Exceptions
\par 
\par #IS Stack underflow occurred.
\par #IA Source operand is an SNaN value or unsupported format.
\par #D Source operand is a denormal value.
\par #U Result is too small for destination format.
\par #O Result is too large for destination format.
\par #P Value cannot be represented exactly in destination format.
\par 
\par Protected Mode Exceptions
\par 
\par #NM EM or TS in CR0 is set.
\par 
\par Real-Address Mode Exceptions
\par 
\par #NM EM or TS in CR0 is set.
\par 
\par Virtual-8086 Mode Exceptions
\par 
\par #NM EM or TS in CR0 is set.
{\page}

${\footnote FSCALE,Opcode}
K{\footnote FSCALE,FSCALE;FSCALE,Opcode}
#{\footnote FSCALE::5}

{\fs20\b FSCALE}\tab{\b Opcode}\par\par
D9 FD FSCALE Scale ST(0) by ST(1).
{\page}

${\footnote FSIN,Description}
K{\footnote FSIN,FSIN;FSIN,Description}
#{\footnote FSIN::1}

{\fs20\b FSIN}\tab{\b Description}\par\par
FSIN: Sine
\par 
\par Calculates the sine of the source operand in register ST(0) and stores the result in ST(0). The source operand must be given in radians and must be within the range -2^63 to +2^63. If the source operand is outside the acceptable range, the C2 flag in the FPU status word is set, and the value in register ST(0) remains unchanged. The instruction does not raise an exception when the source operand is out of range. It is up to the program to check the C2 flag for out-of-range conditions. Source values outside the range -2^63 to +2^63 can be reduced to the range of the instruction by subtracting an appropriate integer multiple of 2p or by using the FPREM instruction with a divisor of 2p.
{\page}

${\footnote FSIN,Operation}
K{\footnote FSIN,FSIN;FSIN,Operation}
#{\footnote FSIN::2}

{\fs20\b FSIN}\tab{\b Operation}\par\par
IF ST(0) < 2 63
\par THEN
\par C2 <- 0;
\par ST(0) <- sin(ST(0));
\par ELSE (* source operand out of range *)
\par C2 <- 1;
\par FI:
{\page}

${\footnote FSIN,Flags affected}
K{\footnote FSIN,FSIN;FSIN,Flags affected}
#{\footnote FSIN::3}

{\fs20\b FSIN}\tab{\b Flags affected}\par\par
FPU Flags Affected
\par 
\par C1 Set to 0 if stack underflow occurred. Indicates rounding direction if the inexact-result exception (#P) is generated: 0 = not roundup; 1 = roundup. C2 Set to 1 if source operand is outside the range -2^63 to +2^63; otherwise, cleared to 0. C0, C3 Undefined.
{\page}

${\footnote FSIN,Exceptions}
K{\footnote FSIN,FSIN;FSIN,Exceptions}
#{\footnote FSIN::4}

{\fs20\b FSIN}\tab{\b Exceptions}\par\par
Floating-Point Exceptions
\par 
\par #IS Stack underflow occurred.
\par #IA Source operand is an SNaN value, (infinity), or unsupported format.
\par #D Source operand is a denormal value.
\par #P Value cannot be represented exactly in destination format.
\par 
\par Protected Mode Exceptions
\par 
\par #NM EM or TS in CR0 is set.
\par 
\par Real-Address Mode Exceptions
\par 
\par #NM EM or TS in CR0 is set.
\par 
\par Virtual-8086 Mode Exceptions
\par 
\par #NM EM or TS in CR0 is set.
{\page}

${\footnote FSIN,Opcode}
K{\footnote FSIN,FSIN;FSIN,Opcode}
#{\footnote FSIN::5}

{\fs20\b FSIN}\tab{\b Opcode}\par\par
D9 FE FSIN Replace ST(0) with its sine.
{\page}

${\footnote FSINCOS,Description}
K{\footnote FSINCOS,FSINCOS;FSINCOS,Description}
#{\footnote FSINCOS::1}

{\fs20\b FSINCOS}\tab{\b Description}\par\par
FSINCOS: Sine and Cosine
\par 
\par Computes both the sine and the cosine of the source operand in register ST(0), stores the sine in ST(0), and pushes the cosine onto the top of the FPU register stack. (This instruction is faster than executing the FSIN and FCOS instructions in succession.) The source operand must be given in radians and must be within the range -2^63 to +2^63.
\par If the source operand is outside the acceptable range, the C2 flag in the FPU status word is set, and the value in register ST(0) remains unchanged. The instruction does not raise an exception when the source operand is out of range. It is up to the program to check the C2 flag for out-of-range conditions. Source values outside the range -2^63 to +2^63 can be reduced to the range of the instruction by subtracting an appropriate integer multiple of 2p or by using the FPREM instruction with a divisor of 2p.
{\page}

${\footnote FSINCOS,Operation}
K{\footnote FSINCOS,FSINCOS;FSINCOS,Operation}
#{\footnote FSINCOS::2}

{\fs20\b FSINCOS}\tab{\b Operation}\par\par
IF ST(0) < 2 63
\par THEN
\par C2 <- 0;
\par TEMP <- cosine(ST(0));
\par ST(0) <- sine(ST(0));
\par TOP <- TOP - 1;
\par ST(0) <- TEMP;
\par ELSE (* source operand out of range *)
\par C2 <- 1;
\par FI:
{\page}

${\footnote FSINCOS,Flags affected}
K{\footnote FSINCOS,FSINCOS;FSINCOS,Flags affected}
#{\footnote FSINCOS::3}

{\fs20\b FSINCOS}\tab{\b Flags affected}\par\par
FPU Flags Affected
\par 
\par C1 Set to 0 if stack underflow occurred; set to 1 of stack overflow occurs. Indicates rounding direction if the inexact-result exception (#P) is generated: 0 = not roundup; 1 = roundup. C2 Set to 1 if source operand is outside the range -2^63 to +2^63; otherwise, cleared to 0. C0, C3 Undefined.
{\page}

${\footnote FSINCOS,Exceptions}
K{\footnote FSINCOS,FSINCOS;FSINCOS,Exceptions}
#{\footnote FSINCOS::4}

{\fs20\b FSINCOS}\tab{\b Exceptions}\par\par
Floating-Point Exceptions
\par 
\par #IS Stack underflow occurred.
\par #IA Source operand is an SNaN value, (infinity), or unsupported format.
\par #D Source operand is a denormal value.
\par #U Result is too small for destination format.
\par #P Value cannot be represented exactly in destination format.
\par 
\par Protected Mode Exceptions
\par 
\par #NM EM or TS in CR0 is set.
\par 
\par Real-Address Mode Exceptions
\par 
\par #NM EM or TS in CR0 is set.
\par 
\par Virtual-8086 Mode Exceptions
\par 
\par #NM EM or TS in CR0 is set.
{\page}

${\footnote FSINCOS,Opcode}
K{\footnote FSINCOS,FSINCOS;FSINCOS,Opcode}
#{\footnote FSINCOS::5}

{\fs20\b FSINCOS}\tab{\b Opcode}\par\par
D9 FB FSINCOS Compute the sine and cosine of ST(0); replace ST(0) with the sine, and push the cosine onto the register stack.
{\page}

${\footnote FSQRT,Description}
K{\footnote FSQRT,FSQRT;FSQRT,Description}
#{\footnote FSQRT::1}

{\fs20\b FSQRT}\tab{\b Description}\par\par
FSQRT: Square Root
\par 
\par Calculates the square root of the source value in the ST(0) register and stores the result in ST(0).
{\page}

${\footnote FSQRT,Operation}
K{\footnote FSQRT,FSQRT;FSQRT,Operation}
#{\footnote FSQRT::2}

{\fs20\b FSQRT}\tab{\b Operation}\par\par
ST(0) <- SquareRoot(ST(0));
{\page}

${\footnote FSQRT,Flags affected}
K{\footnote FSQRT,FSQRT;FSQRT,Flags affected}
#{\footnote FSQRT::3}

{\fs20\b FSQRT}\tab{\b Flags affected}\par\par
FPU Flags Affected
\par 
\par C1 Set to 0 if stack underflow occurred. Indicates rounding direction if inexact-result exception (#P) is generated: 0 = not roundup; 1 = roundup. C0, C2, C3 Undefined.
{\page}

${\footnote FSQRT,Exceptions}
K{\footnote FSQRT,FSQRT;FSQRT,Exceptions}
#{\footnote FSQRT::4}

{\fs20\b FSQRT}\tab{\b Exceptions}\par\par
Floating-Point Exceptions
\par 
\par #IS Stack underflow occurred.
\par #IA Source operand is an SNaN value or unsupported format. Source operand is a negative value (except for -0).
\par #D Source operand is a denormal value.
\par #P Value cannot be represented exactly in destination format.
\par 
\par Protected Mode Exceptions
\par 
\par #NM EM or TS in CR0 is set.
\par 
\par Real-Address Mode Exceptions
\par 
\par #NM EM or TS in CR0 is set.
\par 
\par Virtual-8086 Mode Exceptions
\par 
\par #NM EM or TS in CR0 is set.
{\page}

${\footnote FSQRT,Opcode}
K{\footnote FSQRT,FSQRT;FSQRT,Opcode}
#{\footnote FSQRT::5}

{\fs20\b FSQRT}\tab{\b Opcode}\par\par
D9 FA FSQRT Calculates square root of ST(0) and stores the result in ST(0)
{\page}

${\footnote FST,Description}
K{\footnote FST,FST;FSTP,FSTP;FST,Description;FSTP,Description}
#{\footnote FST::1}
#{\footnote FSTP::1}

{\fs20\b FST/FSTP}\tab{\b Description}\par\par
FST/FSTP: Store Real
\par 
\par The FST instruction copies the value in the ST(0) register to the destination operand, which can be a memory location or another register in the FPU register stack. When storing the value in memory, the value is converted to single- or double-real format. The FSTP instruction performs the same operation as the FST instruction and then pops the register stack. To pop the register stack, the processor marks the ST(0) register as empty and increments the stack pointer (TOP) by 1. The FSTP instruction can also store values in memory in extended-real format.
\par If the destination operand is a memory location, the operand specifies the address where the first byte of the destination value is to be stored. If the destination operand is a register, the operand specifies a register in the register stack relative to the top of the stack. If the destination size is single- or double-real, the significand of the value being stored is rounded to the width of the destination (according to rounding mode specified by the RC field of the FPU control word), and the exponent is converted to the width and bias of the destination format. If the value being stored is too large for the destination format, a numeric overflow exception (#O) is generated and, if the exception is unmasked, no value is stored  in the destination operand. If the value being stored is a denormal value, the denormal exception (#D) is not generated. This condition is simply signaled as a numeric underflow exception (#U) condition. If the value being stored is 0, (infinity), or a NaN, the least-significant bits of the significand and the exponent are truncated to fit the destination format. This operation preserves the value's identity as a 0, (infinity), or NaN. If the destination operand is a non-empty register, the invalid-operation exception is not generated.
{\page}

${\footnote FST,Operation}
K{\footnote FST,FST;FSTP,FSTP;FST,Operation;FSTP,Operation}
#{\footnote FST::2}
#{\footnote FSTP::2}

{\fs20\b FST/FSTP}\tab{\b Operation}\par\par
DEST <- ST(0);
\par IF instruction = FSTP
\par THEN
\par PopRegisterStack;
\par FI;
{\page}

${\footnote FST,Flags affected}
K{\footnote FST,FST;FSTP,FSTP;FST,Flags affected;FSTP,Flags affected}
#{\footnote FST::3}
#{\footnote FSTP::3}

{\fs20\b FST/FSTP}\tab{\b Flags affected}\par\par
FPU Flags Affected
\par 
\par C1 Set to 0 if stack underflow occurred. Indicates rounding direction of if the floating-point inexact exception (#P) is generated: 0 = not roundup; 1 = roundup. C0, C2, C3 Undefined.
{\page}

${\footnote FST,Exceptions}
K{\footnote FST,FST;FSTP,FSTP;FST,Exceptions;FSTP,Exceptions}
#{\footnote FST::4}
#{\footnote FSTP::4}

{\fs20\b FST/FSTP}\tab{\b Exceptions}\par\par
Floating-Point Exceptions
\par 
\par #IS Stack underflow occurred.
\par #IA Source operand is an SNaN value or unsupported format.
\par #U Result is too small for the destination format.
\par #O Result is too large for the destination format.
\par #P Value cannot be represented exactly in destination format.
\par 
\par Protected Mode Exceptions
\par 
\par #GP(0) If the destination is located in a nonwritable segment. If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit. If the DS, ES, FS, or GS register is used to access memory and it contains a null segment selector.
\par #SS(0) If a memory operand effective address is outside the SS segment limit.
\par #NM EM or TS in CR0 is set.
\par #PF(fault-code) If a page fault occurs.
\par #AC(0) If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.
\par 
\par Real-Address Mode Exceptions
\par 
\par #GP If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.
\par #SS If a memory operand effective address is outside the SS segment limit.
\par #NM EM or TS in CR0 is set.
\par 
\par Virtual-8086 Mode Exceptions
\par 
\par #GP(0) If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.
\par #SS(0) If a memory operand effective address is outside the SS segment limit.
\par #NM EM or TS in CR0 is set.
\par #PF(fault-code) If a page fault occurs.
\par #AC(0) If alignment checking is enabled and an unaligned memory reference is made.
{\page}

${\footnote FST,Opcode}
K{\footnote FST,FST;FSTP,FSTP;FST,Opcode;FSTP,Opcode}
#{\footnote FST::5}
#{\footnote FSTP::5}

{\fs20\b FST/FSTP}\tab{\b Opcode}\par\par
D9 /2 FST m32real Copy ST(0) to m32real
\par DD /2 FST m64real Copy ST(0) to m64real
\par DD D0+i FST ST(i) Copy ST(0) to ST(i)
\par D9 /3 FSTP m32real Copy ST(0) to m32real and pop register stack
\par DD /3 FSTP m64real Copy ST(0) to m64real and pop register stack
\par DB /7 FSTP m80real Copy ST(0) to m80real and pop register stack
\par DD D8+i FSTP ST(i) Copy ST(0) to ST(i) and pop register stack
{\page}

${\footnote FSTCW,Description}
K{\footnote FSTCW,FSTCW;FNSTCW,FNSTCW;FSTCW,Description;FNSTCW,Description}
#{\footnote FSTCW::1}
#{\footnote FNSTCW::1}

{\fs20\b FSTCW/FNSTCW}\tab{\b Description}\par\par
FSTCW/FNSTCW: Store Control Word
\par 
\par Stores the current value of the FPU control word at the specified destination in memory. The FSTCW instruction checks for and handles pending unmasked floating-point exceptions before storing the control word; the FNSTCW instruction does not.
\par 
\par Intel Architecture Compatibility
\par 
\par When operating a Pentium or Intel486 processor in MS-DOS compatibility mode, it is possible (under unusual circumstances) for an FNSTCW instruction to be interrupted prior to being executed to handle a pending FPU exception. An FNSTCW instruction cannot be interrupted in this way on a Pentium Pro processor.
{\page}

${\footnote FSTCW,Operation}
K{\footnote FSTCW,FSTCW;FNSTCW,FNSTCW;FSTCW,Operation;FNSTCW,Operation}
#{\footnote FSTCW::2}
#{\footnote FNSTCW::2}

{\fs20\b FSTCW/FNSTCW}\tab{\b Operation}\par\par
DEST <- FPUControlWord;
{\page}

${\footnote FSTCW,Flags affected}
K{\footnote FSTCW,FSTCW;FNSTCW,FNSTCW;FSTCW,Flags affected;FNSTCW,Flags affected}
#{\footnote FSTCW::3}
#{\footnote FNSTCW::3}

{\fs20\b FSTCW/FNSTCW}\tab{\b Flags affected}\par\par
FPU Flags Affected
\par 
\par The C0, C1, C2, and C3 flags are undefined.
{\page}

${\footnote FSTCW,Exceptions}
K{\footnote FSTCW,FSTCW;FNSTCW,FNSTCW;FSTCW,Exceptions;FNSTCW,Exceptions}
#{\footnote FSTCW::4}
#{\footnote FNSTCW::4}

{\fs20\b FSTCW/FNSTCW}\tab{\b Exceptions}\par\par
Floating-Point Exceptions
\par 
\par None.
\par 
\par Protected Mode Exceptions
\par 
\par #GP(0) If the destination is located in a nonwritable segment. If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit. If the DS, ES, FS, or GS register is used to access memory and it contains a null segment selector.
\par #SS(0) If a memory operand effective address is outside the SS segment limit.
\par #NM EM or TS in CR0 is set.
\par #PF(fault-code) If a page fault occurs.
\par #AC(0) If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.
\par 
\par Real-Address Mode Exceptions
\par 
\par #GP If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.
\par #SS If a memory operand effective address is outside the SS segment limit.
\par #NM EM or TS in CR0 is set.
\par 
\par Virtual-8086 Mode Exceptions
\par 
\par #GP(0) If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.
\par #SS(0) If a memory operand effective address is outside the SS segment limit.
\par #NM EM or TS in CR0 is set.
\par #PF(fault-code) If a page fault occurs.
\par #AC(0) If alignment checking is enabled and an unaligned memory reference is made.
{\page}

${\footnote FSTCW,Opcode}
K{\footnote FSTCW,FSTCW;FNSTCW,FNSTCW;FSTCW,Opcode;FNSTCW,Opcode}
#{\footnote FSTCW::5}
#{\footnote FNSTCW::5}

{\fs20\b FSTCW/FNSTCW}\tab{\b Opcode}\par\par
9B D9 /7 FSTCW m2byte Store FPU control word to m2byte after checking for pending unmasked floating-point exceptions.
\par D9 /7 FNSTCW m2byte Store FPU control word to m2byte without checking for pending unmasked floating-point exceptions.
{\page}

${\footnote FSTENV,Description}
K{\footnote FSTENV,FSTENV;FNSTENV,FNSTENV;FSTENV,Description;FNSTENV,Description}
#{\footnote FSTENV::1}
#{\footnote FNSTENV::1}

{\fs20\b FSTENV/FNSTENV}\tab{\b Description}\par\par
FSTENV/FNSTENV: Store FPU Environment
\par 
\par Saves the current FPU operating environment at the memory location specified with the destination operand, and then masks all floating-point exceptions. The FPU operating environment consists of the FPU control word, status word, tag word, instruction pointer, data pointer, and last opcode. In virtual-8086 mode, the real mode layouts are used. The FSTENV instruction checks for and handles any pending unmasked floating-point exceptions before storing the FPU environment; the FNSTENV instruction does not.The saved image reflects the state of the FPU after all floating-point instructions preceding the FSTENV/FNSTENV instruction in the instruction stream have been executed.
\par These instructions are often used by exception handlers because they provide access to the FPU instruction and data pointers. The environment is typically saved in the stack. Masking all exceptions after saving the environment prevents floating-point exceptions from interrupting the exception handler.
\par 
\par Intel Architecture Compatibility
\par 
\par When operating a Pentium or Intel486 processor in MS-DOS compatibility mode, it is possible (under unusual circumstances) for an FNSTENV instruction to be interrupted prior to being executed to handle a pending FPU exception. An FNSTENV instruction cannot be interrupted in this way on a Pentium Pro processor.
{\page}

${\footnote FSTENV,Operation}
K{\footnote FSTENV,FSTENV;FNSTENV,FNSTENV;FSTENV,Operation;FNSTENV,Operation}
#{\footnote FSTENV::2}
#{\footnote FNSTENV::2}

{\fs20\b FSTENV/FNSTENV}\tab{\b Operation}\par\par
DEST(FPUControlWord) <- FPUControlWord;
\par DEST(FPUStatusWord) <- FPUStatusWord;
\par DEST(FPUTagWord) <- FPUTagWord;
\par DEST(FPUDataPointer) <- FPUDataPointer;
\par DEST(FPUInstructionPointer) <- FPUInstructionPointer;
\par DEST(FPULastInstructionOpcode) <- FPULastInstructionOpcode;
{\page}

${\footnote FSTENV,Flags affected}
K{\footnote FSTENV,FSTENV;FNSTENV,FNSTENV;FSTENV,Flags affected;FNSTENV,Flags affected}
#{\footnote FSTENV::3}
#{\footnote FNSTENV::3}

{\fs20\b FSTENV/FNSTENV}\tab{\b Flags affected}\par\par
FPU Flags Affected
\par 
\par The C0, C1, C2, and C3 are undefined.
{\page}

${\footnote FSTENV,Exceptions}
K{\footnote FSTENV,FSTENV;FNSTENV,FNSTENV;FSTENV,Exceptions;FNSTENV,Exceptions}
#{\footnote FSTENV::4}
#{\footnote FNSTENV::4}

{\fs20\b FSTENV/FNSTENV}\tab{\b Exceptions}\par\par
Floating-Point Exceptions
\par 
\par None.
\par 
\par Protected Mode Exceptions
\par 
\par #GP(0) If the destination is located in a nonwritable segment. If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit. If the DS, ES, FS, or GS register is used to access memory and it contains a null segment selector.
\par #SS(0) If a memory operand effective address is outside the SS segment limit.
\par #NM EM or TS in CR0 is set.
\par #PF(fault-code) If a page fault occurs.
\par #AC(0) If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.
\par 
\par Real-Address Mode Exceptions
\par 
\par #GP If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.
\par #SS If a memory operand effective address is outside the SS segment limit.
\par #NM EM or TS in CR0 is set.
\par 
\par Virtual-8086 Mode Exceptions
\par 
\par #GP(0) If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.
\par #SS(0) If a memory operand effective address is outside the SS segment limit.
\par #NM EM or TS in CR0 is set.
\par #PF(fault-code) If a page fault occurs.
\par #AC(0) If alignment checking is enabled and an unaligned memory reference is made.
{\page}

${\footnote FSTENV,Opcode}
K{\footnote FSTENV,FSTENV;FNSTENV,FNSTENV;FSTENV,Opcode;FNSTENV,Opcode}
#{\footnote FSTENV::5}
#{\footnote FNSTENV::5}

{\fs20\b FSTENV/FNSTENV}\tab{\b Opcode}\par\par
9B D9 /6 FSTENV m14/28byte Store FPU environment to m14byte or m28byte after checking for pending unmasked floating-point exceptions. Then mask all floating-point exceptions.
\par D9 /6 FNSTENV m14/28byte Store FPU environment to m14byte or m28byte without checking for pending unmasked floating-point exceptions. Then mask all floating-point exceptions.
{\page}

${\footnote FSTSW,Description}
K{\footnote FSTSW,FSTSW;FNSTSW,FNSTSW;FSTSW,Description;FNSTSW,Description}
#{\footnote FSTSW::1}
#{\footnote FNSTSW::1}

{\fs20\b FSTSW/FNSTSW}\tab{\b Description}\par\par
FSTSW/FNSTSW: Store Status Word
\par 
\par Stores the current value of the FPU status word in the destination location. The destination operand can be either a two-byte memory location or the AX register. The FSTSW instruction checks for and handles pending unmasked floating-point exceptions before storing the status word; the FNSTSW instruction does not. The FNSTSW AX form of the instruction is used primarily in conditional branching (for instance, after an FPU comparison instruction or an FPREM, FPREM1, or FXAM instruction), where the direction of the branch depends on the state of the FPU condition code flags. This instruction can also be used to invoke exception handlers (by examining the exception flags) in environments that do not use interrupts. When the FNSTSW AX instruction is executed, the AX register is updated before the  processor executes any further instructions. The status stored in the AX register is thus guaranteed to be from the completion of the prior FPU instruction.
\par 
\par Intel Architecture Compatibility
\par 
\par When operating a Pentium or Intel486 processor in MS-DOS compatibility mode, it is possible (under unusual circumstances) for an FNSTSW instruction to be interrupted prior to being executed to handle a pending FPU exception. An FNSTSW instruction cannot be interrupted in this way on a Pentium Pro processor.
{\page}

${\footnote FSTSW,Operation}
K{\footnote FSTSW,FSTSW;FNSTSW,FNSTSW;FSTSW,Operation;FNSTSW,Operation}
#{\footnote FSTSW::2}
#{\footnote FNSTSW::2}

{\fs20\b FSTSW/FNSTSW}\tab{\b Operation}\par\par
DEST <- FPUStatusWord;
{\page}

${\footnote FSTSW,Flags affected}
K{\footnote FSTSW,FSTSW;FNSTSW,FNSTSW;FSTSW,Flags affected;FNSTSW,Flags affected}
#{\footnote FSTSW::3}
#{\footnote FNSTSW::3}

{\fs20\b FSTSW/FNSTSW}\tab{\b Flags affected}\par\par
FPU Flags Affected
\par 
\par The C0, C1, C2, and C3 are undefined.
{\page}

${\footnote FSTSW,Exceptions}
K{\footnote FSTSW,FSTSW;FNSTSW,FNSTSW;FSTSW,Exceptions;FNSTSW,Exceptions}
#{\footnote FSTSW::4}
#{\footnote FNSTSW::4}

{\fs20\b FSTSW/FNSTSW}\tab{\b Exceptions}\par\par
Floating-Point Exceptions
\par 
\par None.
\par 
\par Protected Mode Exceptions
\par 
\par #GP(0) If the destination is located in a nonwritable segment. If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit. If the DS, ES, FS, or GS register is used to access memory and it contains a null segment selector.
\par #SS(0) If a memory operand effective address is outside the SS segment limit.
\par #NM EM or TS in CR0 is set.
\par #PF(fault-code) If a page fault occurs.
\par #AC(0) If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.
\par 
\par Real-Address Mode Exceptions
\par 
\par #GP If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.
\par #SS If a memory operand effective address is outside the SS segment limit.
\par #NM EM or TS in CR0 is set.
\par 
\par Virtual-8086 Mode Exceptions
\par 
\par #GP(0) If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.
\par #SS(0) If a memory operand effective address is outside the SS segment limit.
\par #NM EM or TS in CR0 is set.
\par #PF(fault-code) If a page fault occurs.
\par #AC(0) If alignment checking is enabled and an unaligned memory reference is made.
{\page}

${\footnote FSTSW,Opcode}
K{\footnote FSTSW,FSTSW;FNSTSW,FNSTSW;FSTSW,Opcode;FNSTSW,Opcode}
#{\footnote FSTSW::5}
#{\footnote FNSTSW::5}

{\fs20\b FSTSW/FNSTSW}\tab{\b Opcode}\par\par
9B DD /7 FSTSW m2byte Store FPU status word at m2byte after checking for pending unmasked floating-point exceptions.
\par 9B DF E0 FSTSW AX Store FPU status word in AX register after checking for pending unmasked floating-point exceptions.
\par DD /7 FNSTSW m2byte Store FPU status word at m2byte without checking for pending unmasked floating-point exceptions.
\par DF E0 FNSTSW AX Store FPU status word in AX register without checking for pending unmasked floating-point exceptions.
{\page}

${\footnote FSUB,Description}
K{\footnote FSUB,FSUB;FSUBP,FSUBP;FISUB,FISUB;FSUB,Description;FSUBP,Description;FISUB,Description}
#{\footnote FSUB::1}
#{\footnote FSUBP::1}
#{\footnote FISUB::1}

{\fs20\b FSUB/FSUBP/FISUB}\tab{\b Description}\par\par
FSUB/FSUBP/FISUB: Subtract
\par 
\par Subtracts the source operand from the destination operand and stores the difference in the destination location. The destination operand is always an FPU data register; the source operand can be a register or a memory location. Source operands in memory can be in single-real, double-real, word-integer, or short-integer formats. The no-operand version of the instruction subtracts the contents of the ST(0) register from the ST(1) register and stores the result in ST(1). The one-operand version subtracts the contents of a memory location (either a real or an integer value) from the contents of the ST(0) register and stores the result in ST(0). The two-operand version, subtracts the contents of the ST(0) register from the ST(i) register or vice versa.
\par The FSUBP instructions perform the additional operation of popping the FPU register stack following the subtraction. To pop the register stack, the processor marks the ST(0) register as empty and increments the stack pointer (TOP) by 1. The no-operand version of the floating-point subtract instructions always results in the register stack being popped. In some assemblers, the mnemonic for this instruction is FSUB rather than FSUBP. The FISUB instructions convert an integer source operand to extended-real format before performing the subtraction.
\par When the difference between two operands of like sign is 0, the result is +0, except for the round toward -(infinity) mode, in which case the result is -0. This instruction also guarantees that +0 - (-0) = +0, and that -0 - (+0) = -0. When the source operand is an integer 0, it is treated as a +0. When one operand is (infinity), the result is (infinity) of the expected sign. If both operands are (infinity) of the same sign, an invalid-operation exception is generated.
{\page}

${\footnote FSUB,Operation}
K{\footnote FSUB,FSUB;FSUBP,FSUBP;FISUB,FISUB;FSUB,Operation;FSUBP,Operation;FISUB,Operation}
#{\footnote FSUB::2}
#{\footnote FSUBP::2}
#{\footnote FISUB::2}

{\fs20\b FSUB/FSUBP/FISUB}\tab{\b Operation}\par\par
IF instruction is FISUB
\par THEN
\par DEST <- DEST - ConvertExtendedReal(SRC);
\par ELSE (* source operand is real number *)
\par DEST <- DEST - SRC;
\par FI;
\par IF instruction is FSUBP
\par THEN
\par PopRegisterStack
\par FI;
{\page}

${\footnote FSUB,Flags affected}
K{\footnote FSUB,FSUB;FSUBP,FSUBP;FISUB,FISUB;FSUB,Flags affected;FSUBP,Flags affected;FISUB,Flags affected}
#{\footnote FSUB::3}
#{\footnote FSUBP::3}
#{\footnote FISUB::3}

{\fs20\b FSUB/FSUBP/FISUB}\tab{\b Flags affected}\par\par
FPU Flags Affected
\par C1 Set to 0 if stack underflow occurred. Indicates rounding direction if the inexact-result exception (#P) fault is generated: 0 = not roundup; 1 = roundup. C0, C2, C3 Undefined.
{\page}

${\footnote FSUB,Exceptions}
K{\footnote FSUB,FSUB;FSUBP,FSUBP;FISUB,FISUB;FSUB,Exceptions;FSUBP,Exceptions;FISUB,Exceptions}
#{\footnote FSUB::4}
#{\footnote FSUBP::4}
#{\footnote FISUB::4}

{\fs20\b FSUB/FSUBP/FISUB}\tab{\b Exceptions}\par\par
Floating-Point Exceptions
\par 
\par #IS Stack underflow occurred.
\par #IA Operand is an SNaN value or unsupported format. Operands are infinities of like sign.
\par #D Source operand is a denormal value.
\par #U Result is too small for destination format.
\par #O Result is too large for destination format.
\par #P Value cannot be represented exactly in destination format.
\par 
\par Protected Mode Exceptions
\par 
\par #GP(0) If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit. If the DS, ES, FS, or GS register is used to access memory and it contains a null segment selector.
\par #SS(0) If a memory operand effective address is outside the SS segment limit.
\par #NM EM or TS in CR0 is set.
\par #PF(fault-code) If a page fault occurs.
\par #AC(0) If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.
\par 
\par Real-Address Mode Exceptions
\par 
\par #GP If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.
\par #SS If a memory operand effective address is outside the SS segment limit.
\par #NM EM or TS in CR0 is set.
\par 
\par Virtual-8086 Mode Exceptions
\par 
\par #GP(0) If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.
\par #SS(0) If a memory operand effective address is outside the SS segment limit.
\par #NM EM or TS in CR0 is set.
\par #PF(fault-code) If a page fault occurs.
\par #AC(0) If alignment checking is enabled and an unaligned memory reference is made.
{\page}

${\footnote FSUB,Opcode}
K{\footnote FSUB,FSUB;FSUBP,FSUBP;FISUB,FISUB;FSUB,Opcode;FSUBP,Opcode;FISUB,Opcode}
#{\footnote FSUB::5}
#{\footnote FSUBP::5}
#{\footnote FISUB::5}

{\fs20\b FSUB/FSUBP/FISUB}\tab{\b Opcode}\par\par
D8 /4 FSUB m32real Subtract m32real from ST(0) and store result in ST(0)
\par DC /4 FSUB m64real Subtract m64real from ST(0) and store result in ST(0)
\par D8 E0+i FSUB ST(0), ST(i) Subtract ST(i) from ST(0) and store result in ST(0)
\par DC E8+i FSUB ST(i), ST(0) Subtract ST(0) from ST(i) and store result in ST(i)
\par DE E8+i FSUBP ST(i), ST(0) Subtract ST(0) from ST(i), store result in ST(i), and pop register stack
\par DE E9 FSUBP Subtract ST(0) from ST(1), store result in ST(1), and pop register stack
\par DA /4 FISUB m32int Subtract m32int from ST(0) and store result in ST(0)
\par DE /4 FISUB m16int Subtract m16int from ST(0) and store result in ST(0)
{\page}

${\footnote FSUBR,Description}
K{\footnote FSUBR,FSUBR;FSUBRP,FSUBRP;FISUBR,FISUBR;FSUBR,Description;FSUBRP,Description;FISUBR,Description}
#{\footnote FSUBR::1}
#{\footnote FSUBRP::1}
#{\footnote FISUBR::1}

{\fs20\b FSUBR/FSUBRP/FISUBR}\tab{\b Description}\par\par
FSUBR/FSUBRP/FISUBR: Reverse Subtract
\par 
\par Subtracts the destination operand from the source operand and stores the difference in the destination location. The destination operand is always an FPU register; the source operand can be a register or a memory location. Source operands in memory can be in single-real, double-real, word-integer, or short-integer formats. These instructions perform the reverse operations of the FSUB, FSUBP, and FISUB instructions. They are provided to support more efficient coding. The no-operand version of the instruction subtracts the contents of the ST(1) register from the ST(0) register and stores the result in ST(1). The one-operand version subtracts the contents of the ST(0) register from the contents of a memory location (either a real or an integer value) and stores the result in ST(0). The two-operand version, subtracts the contents of the ST(i) register from the ST(0) register or vice versa.
\par The FSUBRP instructions perform the additional operation of popping the FPU register stack following the subtraction. To pop the register stack, the processor marks the ST(0) register as empty and increments the stack pointer (TOP) by 1. The no-operand version of the floating-point reverse subtract instructions always results in the register stack being popped. In some assemblers, the mnemonic for this instruction is FSUBR rather than FSUBRP. The FISUBR instructions convert an integer source operand to extended-real format before performing the subtraction.
\par When the difference between two operands of like sign is 0, the result is +0, except for the round toward -(infinity) mode, in which case the result is -0. This instruction also guarantees that +0 - (-0) = +0, and that -0 - (+0) = -0. When the source operand is an integer 0, it is treated as a +0. When one operand is (infinity), the result is (infinity) of the expected sign. If both operands are (infinity) of the same sign, an invalid-operation exception is generated.
{\page}

${\footnote FSUBR,Operation}
K{\footnote FSUBR,FSUBR;FSUBRP,FSUBRP;FISUBR,FISUBR;FSUBR,Operation;FSUBRP,Operation;FISUBR,Operation}
#{\footnote FSUBR::2}
#{\footnote FSUBRP::2}
#{\footnote FISUBR::2}

{\fs20\b FSUBR/FSUBRP/FISUBR}\tab{\b Operation}\par\par
IF instruction is FISUBR
\par THEN
\par DEST <- ConvertExtendedReal(SRC) - DEST;
\par ELSE (* source operand is real number *)
\par DEST <- SRC - DEST;
\par FI;
\par IF instruction = FSUBRP
\par THEN
\par PopRegisterStack
\par FI;
{\page}

${\footnote FSUBR,Flags affected}
K{\footnote FSUBR,FSUBR;FSUBRP,FSUBRP;FISUBR,FISUBR;FSUBR,Flags affected;FSUBRP,Flags affected;FISUBR,Flags affected}
#{\footnote FSUBR::3}
#{\footnote FSUBRP::3}
#{\footnote FISUBR::3}

{\fs20\b FSUBR/FSUBRP/FISUBR}\tab{\b Flags affected}\par\par
FPU Flags Affected
\par 
\par C1 Set to 0 if stack underflow occurred. Indicates rounding direction if the inexact-result exception (#P) fault is generated: 0 = not roundup; 1 = roundup. C0, C2, C3 Undefined.
{\page}

${\footnote FSUBR,Exceptions}
K{\footnote FSUBR,FSUBR;FSUBRP,FSUBRP;FISUBR,FISUBR;FSUBR,Exceptions;FSUBRP,Exceptions;FISUBR,Exceptions}
#{\footnote FSUBR::4}
#{\footnote FSUBRP::4}
#{\footnote FISUBR::4}

{\fs20\b FSUBR/FSUBRP/FISUBR}\tab{\b Exceptions}\par\par
Floating-Point Exceptions
\par 
\par #IS Stack underflow occurred.
\par #IA Operand is an SNaN value or unsupported format. Operands are infinities of like sign.
\par #D Source operand is a denormal value.
\par #U Result is too small for destination format.
\par #O Result is too large for destination format.
\par #P Value cannot be represented exactly in destination format.
\par 
\par Protected Mode Exceptions
\par 
\par #GP(0) If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit. If the DS, ES, FS, or GS register is used to access memory and it contains a null segment selector.
\par #SS(0) If a memory operand effective address is outside the SS segment limit.
\par #NM EM or TS in CR0 is set.
\par #PF(fault-code) If a page fault occurs.
\par #AC(0) If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.
\par 
\par Real-Address Mode Exceptions
\par 
\par #GP If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.
\par #SS If a memory operand effective address is outside the SS segment limit.
\par #NM EM or TS in CR0 is set.
\par 
\par Virtual-8086 Mode Exceptions
\par 
\par #GP(0) If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.
\par #SS(0) If a memory operand effective address is outside the SS segment limit.
\par #NM EM or TS in CR0 is set.
\par #PF(fault-code) If a page fault occurs.
\par #AC(0) If alignment checking is enabled and an unaligned memory reference is made.
{\page}

${\footnote FSUBR,Opcode}
K{\footnote FSUBR,FSUBR;FSUBRP,FSUBRP;FISUBR,FISUBR;FSUBR,Opcode;FSUBRP,Opcode;FISUBR,Opcode}
#{\footnote FSUBR::5}
#{\footnote FSUBRP::5}
#{\footnote FISUBR::5}

{\fs20\b FSUBR/FSUBRP/FISUBR}\tab{\b Opcode}\par\par
D8 /5 FSUBR m32real Subtract ST(0) from m32real and store result in ST(0)
\par DC /5 FSUBR m64real Subtract ST(0) from m64real and store result in ST(0)
\par D8 E8+i FSUBR ST(0), ST(i) Subtract ST(0) from ST(i) and store result in ST(0)
\par DC E0+i FSUBR ST(i), ST(0) Subtract ST(i) from ST(0) and store result in ST(i)
\par DE E0+i FSUBRP ST(i), ST(0) Subtract ST(i) from ST(0), store result in ST(i), and pop register stack
\par DE E1 FSUBRP Subtract ST(1) from ST(0), store result in ST(1), and pop register stack
\par DA /5 FISUBR m32int Subtract ST(0) from m32int and store result in ST(0)
\par DE /5 FISUBR m16int Subtract ST(0) from m16int and store result in ST(0)
{\page}

${\footnote FTST,Description}
K{\footnote FTST,FTST;FTST,Description}
#{\footnote FTST::1}

{\fs20\b FTST}\tab{\b Description}\par\par
FTST: TEST
\par 
\par Compares the value in the ST(0) register with 0.0 and sets the condition code flags C0, C2, and C3 in the FPU status word according to the results. This instruction performs an "unordered comparison." An unordered comparison also checks the class of the numbers being compared. If the value in register ST(0) is a NaN or is in an undefined format, the condition flags are set to "unordered" and the invalid operation exception is generated. The sign of zero is ignored, so that -0.0 = +0.0.
{\page}

${\footnote FTST,Operation}
K{\footnote FTST,FTST;FTST,Operation}
#{\footnote FTST::2}

{\fs20\b FTST}\tab{\b Operation}\par\par
CASE (relation of operands) OF
\par Not comparable: C3, C2, C0 <- 111;
\par ST(0) > 0.0: C3, C2, C0 <- 000;
\par ST(0) < 0.0: C3, C2, C0 <- 001;
\par ST(0) = 0.0: C3, C2, C0 <- 100;
\par ESAC;
{\page}

${\footnote FTST,Flags affected}
K{\footnote FTST,FTST;FTST,Flags affected}
#{\footnote FTST::3}

{\fs20\b FTST}\tab{\b Flags affected}\par\par
FPU Flags Affected
\par 
\par C1 Set to 0 if stack underflow occurred; otherwise, cleared to 0. C0, C2, C3 according to tables.
{\page}

${\footnote FTST,Exceptions}
K{\footnote FTST,FTST;FTST,Exceptions}
#{\footnote FTST::4}

{\fs20\b FTST}\tab{\b Exceptions}\par\par
Floating-Point Exceptions
\par 
\par #IS Stack underflow occurred.
\par #IA The source operand is a NaN value or is in an unsupported format.
\par #D The source operand is a denormal value.
\par 
\par Protected Mode Exceptions
\par 
\par #NM EM or TS in CR0 is set.
\par 
\par Real-Address Mode Exceptions
\par 
\par #NM EM or TS in CR0 is set.
\par 
\par Virtual-8086 Mode Exceptions
\par 
\par #NM EM or TS in CR0 is set.
{\page}

${\footnote FTST,Opcode}
K{\footnote FTST,FTST;FTST,Opcode}
#{\footnote FTST::5}

{\fs20\b FTST}\tab{\b Opcode}\par\par
D9 E4 FTST Compare ST(0) with 0.0.
{\page}

${\footnote FUCOM,Description}
K{\footnote FUCOM,FUCOM;FUCOMP,FUCOMP;FUCOMPP,FUCOMPP;FUCOM,Description;FUCOMP,Description;FUCOMPP,Description}
#{\footnote FUCOM::1}
#{\footnote FUCOMP::1}
#{\footnote FUCOMPP::1}

{\fs20\b FUCOM/FUCOMP/FUCOMPP}\tab{\b Description}\par\par
FUCOM/FUCOMP/FUCOMPP: Unordered Compare Real
\par 
\par Performs an unordered comparison of the contents of register ST(0) and ST(i) and sets condition code flags C0, C2, and C3 in the FPU status word according to the results. If no operand is specified, the contents of registers ST(0) and ST(1) are compared. The sign of zero is ignored, so that -0.0 = +0.0.
\par An unordered comparison checks the class of the numbers being compared. The FUCOM instructions perform the same operations as the FCOM instructions. The only difference is that the FUCOM instructions raise the invalid-arithmetic-operand exception (#IA) only when either or both operands are an SNaN or are in an unsupported format; QNaNs cause the condition code flags to be set to unordered, but do not cause an exception to be generated. The FCOM instructions raise an invalid-operation exception when either or both of the operands are a NaN value of any kind or are in an unsupported format. As with the FCOM instructions, if the operation results in an invalid-arithmetic-operand exception being raised, the condition code flags are set only if the exception is masked. The FUCOMP instruction pops the register stack following the comparison operation and the FUCOMPP instruction pops the register stack twice following the comparison operation. To pop the register stack, the processor marks the ST(0) register as empty and increments the stack pointer (TOP) by 1.
{\page}

${\footnote FUCOM,Operation}
K{\footnote FUCOM,FUCOM;FUCOMP,FUCOMP;FUCOMPP,FUCOMPP;FUCOM,Operation;FUCOMP,Operation;FUCOMPP,Operation}
#{\footnote FUCOM::2}
#{\footnote FUCOMP::2}
#{\footnote FUCOMPP::2}

{\fs20\b FUCOM/FUCOMP/FUCOMPP}\tab{\b Operation}\par\par
CASE (relation of operands) OF
\par ST > SRC: C3, C2, C0 <- 000;
\par ST < SRC: C3, C2, C0 <- 001;
\par ST = SRC: C3, C2, C0 <- 100;
\par ESAC;
\par IF ST(0) or SRC = QNaN, but not SNaN or unsupported format
\par THEN
\par C3, C2, C0 <- 111;
\par ELSE (* ST(0) or SRC is SNaN or unsupported format *)
\par #IA;
\par IF FPUControlWord.IM = 1
\par THEN
\par C3, C2, C0 <- 111;
\par FI;
\par FI;
\par IF instruction = FUCOMP
\par THEN
\par PopRegisterStack;
\par FI;
\par IF instruction = FUCOMPP
\par THEN
\par PopRegisterStack;
\par PopRegisterStack;
\par FI;
{\page}

${\footnote FUCOM,Flags affected}
K{\footnote FUCOM,FUCOM;FUCOMP,FUCOMP;FUCOMPP,FUCOMPP;FUCOM,Flags affected;FUCOMP,Flags affected;FUCOMPP,Flags affected}
#{\footnote FUCOM::3}
#{\footnote FUCOMP::3}
#{\footnote FUCOMPP::3}

{\fs20\b FUCOM/FUCOMP/FUCOMPP}\tab{\b Flags affected}\par\par
FPU Flags Affected
\par 
\par C1 Set to 0 if stack underflow occurred. C0, C2, C3 according to table.
{\page}

${\footnote FUCOM,Exceptions}
K{\footnote FUCOM,FUCOM;FUCOMP,FUCOMP;FUCOMPP,FUCOMPP;FUCOM,Exceptions;FUCOMP,Exceptions;FUCOMPP,Exceptions}
#{\footnote FUCOM::4}
#{\footnote FUCOMP::4}
#{\footnote FUCOMPP::4}

{\fs20\b FUCOM/FUCOMP/FUCOMPP}\tab{\b Exceptions}\par\par
Floating-Point Exceptions
\par 
\par #IS Stack underflow occurred.
\par #IA One or both operands are SNaN values or have unsupported formats. Detection of a QNaN value in and of itself does not raise an invalid-operand exception.
\par #D One or both operands are denormal values.
\par 
\par Protected Mode Exceptions
\par 
\par #NM EM or TS in CR0 is set.
\par 
\par Real-Address Mode Exceptions
\par 
\par #NM EM or TS in CR0 is set.
\par 
\par Virtual-8086 Mode Exceptions
\par 
\par #NM EM or TS in CR0 is set.
{\page}

${\footnote FUCOM,Opcode}
K{\footnote FUCOM,FUCOM;FUCOMP,FUCOMP;FUCOMPP,FUCOMPP;FUCOM,Opcode;FUCOMP,Opcode;FUCOMPP,Opcode}
#{\footnote FUCOM::5}
#{\footnote FUCOMP::5}
#{\footnote FUCOMPP::5}

{\fs20\b FUCOM/FUCOMP/FUCOMPP}\tab{\b Opcode}\par\par
DD E0+i FUCOM ST(i) Compare ST(0) with ST(i)
\par DD E1 FUCOM Compare ST(0) with ST(1)
\par DD E8+i FUCOMP ST(i) Compare ST(0) with ST(i) and pop register stack
\par DD E9 FUCOMP Compare ST(0) with ST(1) and pop register stack
\par DA E9 FUCOMPP Compare ST(0) with ST(1) and pop register stack twice
{\page}

${\footnote FWAIT,Description}
K{\footnote FWAIT,FWAIT;FWAIT,Description}
#{\footnote FWAIT::1}

{\fs20\b FWAIT}\tab{\b Description}\par\par
FWAIT: Wait
\par 
\par Causes the processor to check for and handle pending, unmasked, floating-point exceptions before proceeding. (FWAIT is an alternate mnemonic for the WAIT). This instruction is useful for synchronizing exceptions in critical sections of code. Coding a WAIT instruction after a floating-point instruction insures that any unmasked floating-point exceptions the instruction may raise are handled before the processor can modify the instruction's results.
{\page}

${\footnote FWAIT,Operation}
K{\footnote FWAIT,FWAIT;FWAIT,Operation}
#{\footnote FWAIT::2}

{\fs20\b FWAIT}\tab{\b Operation}\par\par
CheckForPendingUnmaskedFloatingPointExceptions;
{\page}

${\footnote FWAIT,Flags affected}
K{\footnote FWAIT,FWAIT;FWAIT,Flags affected}
#{\footnote FWAIT::3}

{\fs20\b FWAIT}\tab{\b Flags affected}\par\par
The C0, C1, C2, and C3 flags are undefined.
{\page}

${\footnote FWAIT,Exceptions}
K{\footnote FWAIT,FWAIT;FWAIT,Exceptions}
#{\footnote FWAIT::4}

{\fs20\b FWAIT}\tab{\b Exceptions}\par\par
Floating-Point Exceptions
\par 
\par None.
\par 
\par Protected Mode Exceptions
\par 
\par #NM MP and TS in CR0 is set.
\par 
\par Real-Address Mode Exceptions
\par 
\par #NM MP and TS in CR0 is set.
\par 
\par Virtual-8086 Mode Exceptions
\par 
\par #NM MP and TS in CR0 is set.
{\page}

${\footnote FWAIT,Opcode}
K{\footnote FWAIT,FWAIT;FWAIT,Opcode}
#{\footnote FWAIT::5}

{\fs20\b FWAIT}\tab{\b Opcode}\par\par
9B FWAIT Check pending unmasked floating-point exceptions.
{\page}

${\footnote FXAM,Description}
K{\footnote FXAM,FXAM;FXAM,Description}
#{\footnote FXAM::1}

{\fs20\b FXAM}\tab{\b Description}\par\par
FXAM: Examine
\par 
\par Examines the contents of the ST(0) register and sets the condition code flags C0, C2, and C3 in the FPU status word to indicate the class of value or number in the register. The C1 flag is set to the sign of the value in ST(0), regardless of whether the register is empty or full.
{\page}

${\footnote FXAM,Operation}
K{\footnote FXAM,FXAM;FXAM,Operation}
#{\footnote FXAM::2}

{\fs20\b FXAM}\tab{\b Operation}\par\par
C1 <- sign bit of ST; (* 0 for positive, 1 for negative *)
\par CASE (class of value or number in ST(0)) OF
\par Unsupported:C3, C2, C0 <- 000;
\par NaN: C3, C2, C0 <- 001;
\par Normal: C3, C2, C0 <- 010;
\par Infinity: C3, C2, C0 <- 011;
\par Zero: C3, C2, C0 <- 100;
\par Empty: C3, C2, C0 <- 101;
\par Denormal: C3, C2, C0 <- 110;
\par ESAC;
{\page}

${\footnote FXAM,Flags affected}
K{\footnote FXAM,FXAM;FXAM,Flags affected}
#{\footnote FXAM::3}

{\fs20\b FXAM}\tab{\b Flags affected}\par\par
FPU Flags Affected
\par 
\par C1 Sign of value in ST(0). C0, C2, C3 according to table.
{\page}

${\footnote FXAM,Exceptions}
K{\footnote FXAM,FXAM;FXAM,Exceptions}
#{\footnote FXAM::4}

{\fs20\b FXAM}\tab{\b Exceptions}\par\par
Floating-Point Exceptions
\par 
\par None.
\par 
\par Protected Mode Exceptions
\par 
\par #NM EM or TS in CR0 is set.
\par 
\par Real-Address Mode Exceptions
\par 
\par #NM EM or TS in CR0 is set.
\par 
\par Virtual-8086 Mode Exceptions
\par 
\par #NM EM or TS in CR0 is set.
{\page}

${\footnote FXAM,Opcode}
K{\footnote FXAM,FXAM;FXAM,Opcode}
#{\footnote FXAM::5}

{\fs20\b FXAM}\tab{\b Opcode}\par\par
D9 E5 FXAM Classify value or number in ST(0)
{\page}

${\footnote FXCH,Description}
K{\footnote FXCH,FXCH;FXCH,Description}
#{\footnote FXCH::1}

{\fs20\b FXCH}\tab{\b Description}\par\par
FXCH: Exchange Register Contents
\par 
\par Exchanges the contents of registers ST(0) and ST(i). If no source operand is specified, the contents of ST(0) and ST(1) are exchanged. This instruction provides a simple means of moving values in the FPU register stack to the top of the stack [ST(0)], so that they can be operated on by those floating-point instructions that can only operate on values in ST(0). For example, the following instruction sequence takes the square root of the third register from the top of the register stack:
\par FXCH ST(3);
\par FSQRT;
\par FXCH ST(3);
{\page}

${\footnote FXCH,Operation}
K{\footnote FXCH,FXCH;FXCH,Operation}
#{\footnote FXCH::2}

{\fs20\b FXCH}\tab{\b Operation}\par\par
IF number-of-operands is 1
\par THEN
\par temp <- ST(0);
\par ST(0) <- SRC;
\par SRC <- temp;
\par ELSE
\par temp <- ST(0);
\par ST(0) <- ST(1);
\par ST(1) <- temp;
{\page}

${\footnote FXCH,Flags affected}
K{\footnote FXCH,FXCH;FXCH,Flags affected}
#{\footnote FXCH::3}

{\fs20\b FXCH}\tab{\b Flags affected}\par\par
FPU Flags Affected
\par 
\par C1 Set to 0 if stack underflow occurred; otherwise, cleared to 0. C0, C2, C3 Undefined.
{\page}

${\footnote FXCH,Exceptions}
K{\footnote FXCH,FXCH;FXCH,Exceptions}
#{\footnote FXCH::4}

{\fs20\b FXCH}\tab{\b Exceptions}\par\par
Floating-Point Exceptions
\par 
\par #IS Stack underflow occurred.
\par 
\par Protected Mode Exceptions
\par 
\par #NM EM or TS in CR0 is set.
\par 
\par Real-Address Mode Exceptions
\par 
\par #NM EM or TS in CR0 is set.
\par 
\par Virtual-8086 Mode Exceptions
\par 
\par #NM EM or TS in CR0 is set.
{\page}

${\footnote FXCH,Opcode}
K{\footnote FXCH,FXCH;FXCH,Opcode}
#{\footnote FXCH::5}

{\fs20\b FXCH}\tab{\b Opcode}\par\par
D9 C8+i FXCH ST(i) Exchange the contents of ST(0) and ST(i)
\par D9 C9 FXCH Exchange the contents of ST(0) and ST(1)
{\page}

${\footnote FXTRACT,Description}
K{\footnote FXTRACT,FXTRACT;FXTRACT,Description}
#{\footnote FXTRACT::1}

{\fs20\b FXTRACT}\tab{\b Description}\par\par
FXTRACT: Extract Exponent and Significand
\par 
\par Separates the source value in the ST(0) register into its exponent and significand, stores the exponent in ST(0), and pushes the significand onto the register stack. Following this operation, the new top-of-stack register ST(0) contains the value of the original significand expressed as a real number. The sign and significand of this value are the same as those found in the source operand, and the exponent is 3FFFH (biased value for a true exponent of zero). The ST(1) register contains the value of the original operand's true (unbiased) exponent expressed as a real number. (The operation performed by this instruction is a superset of the IEEE-recommended logb(x) function.)
\par This instruction and the F2XM1 instruction are useful for performing power and range scaling operations. The FXTRACT instruction is also useful for converting numbers in extended-real format to decimal representations (e.g., for printing or displaying). If the floating-point zero-divide exception (#Z) is masked and the source operand is zero, an exponent value of -(infinity) is stored in register ST(1) and 0 with the sign of the source operand is stored in register ST(0).
{\page}

${\footnote FXTRACT,Operation}
K{\footnote FXTRACT,FXTRACT;FXTRACT,Operation}
#{\footnote FXTRACT::2}

{\fs20\b FXTRACT}\tab{\b Operation}\par\par
TEMP <- Significand(ST(0));
\par ST(0) <- Exponent(ST(0));
\par TOP<- TOP - 1;
\par ST(0) <- TEMP;
{\page}

${\footnote FXTRACT,Flags affected}
K{\footnote FXTRACT,FXTRACT;FXTRACT,Flags affected}
#{\footnote FXTRACT::3}

{\fs20\b FXTRACT}\tab{\b Flags affected}\par\par
FPU Flags Affected
\par 
\par C1 Set to 0 if stack underflow occurred; set to 1 if stack overflow occurred. C0, C2, C3 Undefined.
{\page}

${\footnote FXTRACT,Exceptions}
K{\footnote FXTRACT,FXTRACT;FXTRACT,Exceptions}
#{\footnote FXTRACT::4}

{\fs20\b FXTRACT}\tab{\b Exceptions}\par\par
Floating-Point Exceptions
\par 
\par #IS Stack underflow occurred. Stack overflow occurred.
\par #IA Source operand is an SNaN value or unsupported format.
\par #Z ST(0) operand is 0.
\par #D Source operand is a denormal value.
\par 
\par Protected Mode Exceptions
\par 
\par #NM EM or TS in CR0 is set.
\par 
\par Real-Address Mode Exceptions
\par 
\par #NM EM or TS in CR0 is set.
\par 
\par Virtual-8086 Mode Exceptions
\par 
\par #NM EM or TS in CR0 is set.
{\page}

${\footnote FXTRACT,Opcode}
K{\footnote FXTRACT,FXTRACT;FXTRACT,Opcode}
#{\footnote FXTRACT::5}

{\fs20\b FXTRACT}\tab{\b Opcode}\par\par
D9 F4 FXTRACT Separate value in ST(0) into exponent and significand, store exponent in ST(0), and push the significand onto the register stack.
{\page}

${\footnote FYL2X,Description}
K{\footnote FYL2X,FYL2X;FYL2X,Description}
#{\footnote FYL2X::1}

{\fs20\b FYL2X}\tab{\b Description}\par\par
FYL2X: Compute y * log\{2\}x (Base of logarithm = 2)
\par 
\par Calculates (ST(1) * log\{2\}(ST(0))), stores the result in resister ST(1), and pops the FPU register stack. The source operand in ST(0) must be a non-zero positive number. The FYL2X instruction is designed with a built-in multiplication to optimize the calculation of logarithms with an arbitrary positive base (b):
\par log\{b\}x = (log\{2\}b) -1 * log\{2\}x
{\page}

${\footnote FYL2X,Operation}
K{\footnote FYL2X,FYL2X;FYL2X,Operation}
#{\footnote FYL2X::2}

{\fs20\b FYL2X}\tab{\b Operation}\par\par
ST(1) <- ST(1) * log\{2\}ST(0);
\par PopRegisterStack;
{\page}

${\footnote FYL2X,Flags affected}
K{\footnote FYL2X,FYL2X;FYL2X,Flags affected}
#{\footnote FYL2X::3}

{\fs20\b FYL2X}\tab{\b Flags affected}\par\par
FPU Flags Affected
\par 
\par C1 Set to 0 if stack underflow occurred. Indicates rounding direction if the inexact-result exception (#P) is generated: 0 = not roundup; 1 = roundup. C0, C2, C3 Undefined.
{\page}

${\footnote FYL2X,Exceptions}
K{\footnote FYL2X,FYL2X;FYL2X,Exceptions}
#{\footnote FYL2X::4}

{\fs20\b FYL2X}\tab{\b Exceptions}\par\par
Floating-Point Exceptions
\par 
\par #IS Stack underflow occurred.
\par #IA Either operand is an SNaN or unsupported format. Source operand in register ST(0) is a negative finite value (not -0).
\par #Z Source operand in register ST(0) is 0.
\par #D Source operand is a denormal value.
\par #U Result is too small for destination format.
\par #O Result is too large for destination format.
\par #P Value cannot be represented exactly in destination format.
\par 
\par Protected Mode Exceptions
\par 
\par #NM EM or TS in CR0 is set.
\par 
\par Real-Address Mode Exceptions
\par 
\par #NM EM or TS in CR0 is set.
\par 
\par Virtual-8086 Mode Exceptions
\par 
\par #NM EM or TS in CR0 is set.
{\page}

${\footnote FYL2X,Opcode}
K{\footnote FYL2X,FYL2X;FYL2X,Opcode}
#{\footnote FYL2X::5}

{\fs20\b FYL2X}\tab{\b Opcode}\par\par
D9 F1 FYL2X Replace ST(1) with (ST(1) * log\{2\}ST(0)) and pop the register stack
{\page}

${\footnote FYL2XP1,Description}
K{\footnote FYL2XP1,FYL2XP1;FYL2XP1,Description}
#{\footnote FYL2XP1::1}

{\fs20\b FYL2XP1}\tab{\b Description}\par\par
FYL2XP1: Compute y * log\{2\}(x +1)
\par 
\par Calculates the log epsilon (ST(1) * log\{2\}(ST(0) + 1.0)), stores the result in register ST(1), and pops the FPU register stack. The source operand in ST(0) must be in the range: The source operand in ST(1) can range from -(infinity) to +(infinity). If the ST(0) operand is outside of its acceptable range, the result is undefined and software should not rely on an exception being generated. Under some circumstances exceptions may be generated when ST(0) is out of range, but this behavior is implementation specific and not guaranteed.
\par This instruction provides optimal accuracy for values of epsilon [the value in register ST(0)] that are close to 0. When the epsilon value (e) is small, more significant digits can be retained by using the FYL2XP1 instruction than by using (e+1) as an argument to the FYL2X instruction. The (e+1) expression is commonly found in compound interest and annuity calculations. The result can be simply converted into a value in another logarithm base by including a scale factor in the ST(1) source operand. The following equation is used to calculate the scale factor for a particular logarithm base, where n is the logarithm base desired for the result of the FYL2XP1 instruction:
\par scale factor = log\{n\}2
{\page}

${\footnote FYL2XP1,Operation}
K{\footnote FYL2XP1,FYL2XP1;FYL2XP1,Operation}
#{\footnote FYL2XP1::2}

{\fs20\b FYL2XP1}\tab{\b Operation}\par\par
ST(1) <- ST(1) * log\{2\}(ST(0) + 1.0);
\par PopRegisterStack;
{\page}

${\footnote FYL2XP1,Flags affected}
K{\footnote FYL2XP1,FYL2XP1;FYL2XP1,Flags affected}
#{\footnote FYL2XP1::3}

{\fs20\b FYL2XP1}\tab{\b Flags affected}\par\par
FPU Flags Affected
\par 
\par C1 Set to 0 if stack underflow occurred. Indicates rounding direction if the inexact-result exception (#P) is generated: 0 = not roundup; 1 = roundup. C0, C2, C3 Undefined.
{\page}

${\footnote FYL2XP1,Exceptions}
K{\footnote FYL2XP1,FYL2XP1;FYL2XP1,Exceptions}
#{\footnote FYL2XP1::4}

{\fs20\b FYL2XP1}\tab{\b Exceptions}\par\par
Floating-Point Exceptions
\par 
\par #IS Stack underflow occurred.
\par #IA Either operand is an SNaN value or unsupported format.
\par #D Source operand is a denormal value.
\par #U Result is too small for destination format.
\par #O Result is too large for destination format.
\par #P Value cannot be represented exactly in destination format.
\par 
\par Protected Mode Exceptions
\par 
\par #NM EM or TS in CR0 is set.
\par 
\par Real-Address Mode Exceptions
\par 
\par #NM EM or TS in CR0 is set.
\par 
\par Virtual-8086 Mode Exceptions
\par 
\par #NM EM or TS in CR0 is set.
{\page}

${\footnote FYL2XP1,Opcode}
K{\footnote FYL2XP1,FYL2XP1;FYL2XP1,Opcode}
#{\footnote FYL2XP1::5}

{\fs20\b FYL2XP1}\tab{\b Opcode}\par\par
D9 F9 FYL2XP1 Replace ST(1) with ST(1) * log\{2\}(ST(0) + 1.0) and pop the register stack
{\page}

${\footnote FS:,Description}
K{\footnote FS:,FS:;FS:,Description}
#{\footnote FS:::1}

{\fs20\b FS:}\tab{\b Description}\par\par
Internal disassembler's symbol which indicates that the next command is used with the FS: segment.
{\page}

${\footnote FS:,Operation}
K{\footnote FS:,FS:;FS:,Operation}
#{\footnote FS:::2}

{\fs20\b FS:}\tab{\b Operation}\par\par
N/A
{\page}

${\footnote FS:,Flags affected}
K{\footnote FS:,FS:;FS:,Flags affected}
#{\footnote FS:::3}

{\fs20\b FS:}\tab{\b Flags affected}\par\par
N/A
{\page}

${\footnote FS:,Exceptions}
K{\footnote FS:,FS:;FS:,Exceptions}
#{\footnote FS:::4}

{\fs20\b FS:}\tab{\b Exceptions}\par\par
N/A
{\page}

${\footnote FS:,Opcode}
K{\footnote FS:,FS:;FS:,Opcode}
#{\footnote FS:::5}

{\fs20\b FS:}\tab{\b Opcode}\par\par
N/A
{\page}

${\footnote GS:,Description}
K{\footnote GS:,GS:;GS:,Description}
#{\footnote GS:::1}

{\fs20\b GS:}\tab{\b Description}\par\par
Internal disassembler's symbol which indicates that the next command is used with the GS: segment.
{\page}

${\footnote GS:,Operation}
K{\footnote GS:,GS:;GS:,Operation}
#{\footnote GS:::2}

{\fs20\b GS:}\tab{\b Operation}\par\par
N/A
{\page}

${\footnote GS:,Flags affected}
K{\footnote GS:,GS:;GS:,Flags affected}
#{\footnote GS:::3}

{\fs20\b GS:}\tab{\b Flags affected}\par\par
N/A
{\page}

${\footnote GS:,Exceptions}
K{\footnote GS:,GS:;GS:,Exceptions}
#{\footnote GS:::4}

{\fs20\b GS:}\tab{\b Exceptions}\par\par
N/A
{\page}

${\footnote GS:,Opcode}
K{\footnote GS:,GS:;GS:,Opcode}
#{\footnote GS:::5}

{\fs20\b GS:}\tab{\b Opcode}\par\par
N/A
{\page}

${\footnote HLT,Description}
K{\footnote HLT,HLT;HLT,Description}
#{\footnote HLT::1}

{\fs20\b HLT}\tab{\b Description}\par\par
HLT: Halt
\par 
\par Stops instruction execution and places the processor in a HALT state. An enabled interrupt, NMI, or a reset will resume execution. If an interrupt (including NMI) is used to resume execution after a HLT instruction, the saved instruction pointer (CS:EIP) points to the instruction following the HLT instruction.
\par The HLT instruction is a privileged instruction. When the processor is running in protected or virtual-8086 mode, the privilege level of a program or procedure must be 0 to execute the HLT instruction.
{\page}

${\footnote HLT,Operation}
K{\footnote HLT,HLT;HLT,Operation}
#{\footnote HLT::2}

{\fs20\b HLT}\tab{\b Operation}\par\par
Enter Halt state;
{\page}

${\footnote HLT,Flags affected}
K{\footnote HLT,HLT;HLT,Flags affected}
#{\footnote HLT::3}

{\fs20\b HLT}\tab{\b Flags affected}\par\par
None.
{\page}

${\footnote HLT,Exceptions}
K{\footnote HLT,HLT;HLT,Exceptions}
#{\footnote HLT::4}

{\fs20\b HLT}\tab{\b Exceptions}\par\par
Protected Mode Exceptions
\par 
\par #GP(0) If the current privilege level is not 0.
\par 
\par Real-Address Mode Exceptions
\par 
\par None.
\par 
\par Virtual-8086 Mode Exceptions
\par 
\par #GP(0) If the current privilege level is not 0.
{\page}

${\footnote HLT,Opcode}
K{\footnote HLT,HLT;HLT,Opcode}
#{\footnote HLT::5}

{\fs20\b HLT}\tab{\b Opcode}\par\par
F4 HLT Halt
{\page}

${\footnote IDIV,Description}
K{\footnote IDIV,IDIV;IDIV,Description}
#{\footnote IDIV::1}

{\fs20\b IDIV}\tab{\b Description}\par\par
IDIV: Signed Divide
\par 
\par Divides (signed) the value in the AL, AX, or EAX register by the source operand and stores the result in the AX, DX:AX, or EDX:EAX registers. The source operand can be a general-purpose register or a memory location. The action of this instruction depends on the operand size, as shown in the following table:
\par 
\par Operand Size     Dividend    Divisor   Quotient  Remainder   Quotient Range
\par Word/byte           AX        r/m8        AL       AH         -128 to +127
\par Doubleword/word     DX:AX     r/m16       AX       DX      -32,768 to +32,767
\par Quadword/doubleword EDX:EAX   r/m32       EAX      EDX     -2^31 to 2^32 - 1
\par 
\par Non-integral results are truncated (chopped) towards 0. The sign of the remainder is always the same as the sign of the dividend. The absolute value of the remainder is always less than the absolute value of the divisor. Overflow is indicated with the #DE (divide error) exception rather than with the OF (overflow) flag.
{\page}

${\footnote IDIV,Operation}
K{\footnote IDIV,IDIV;IDIV,Operation}
#{\footnote IDIV::2}

{\fs20\b IDIV}\tab{\b Operation}\par\par
IF SRC = 0
\par THEN #DE; (* divide error *)
\par FI;
\par IF OpernadSize = 8 (* word/byte operation *)
\par THEN
\par temp <- AX / SRC; (* signed division *)
\par IF (temp > 7FH) OR (temp < 80H)
\par (* if a positive result is greater than 7FH or a negative result is less than 80H *)
\par THEN #DE; (* divide error *) ;
\par ELSE
\par AL <- temp;
\par AH <- AX SignedModulus SRC;
\par FI;
\par ELSE
\par IF OperandSize = 16 (* doubleword/word operation *)
\par THEN
\par temp <- DX:AX / SRC; (* signed division *)
\par IF (temp > 7FFFH) OR (temp < 8000H)
\par (* if a positive result is greater than 7FFFH *)
\par (* or a negative result is less than 8000H *)
\par THEN #DE; (* divide error *) ;
\par ELSE
\par AX <- temp;
\par DX <- DX:AX SignedModulus SRC;
\par FI;
\par ELSE (* quadword/doubleword operation *)
\par temp <- EDX:EAX / SRC; (* signed division *)
\par IF (temp > 7FFFFFFFH) OR (temp < 80000000H)
\par (* if a positive result is greater than 7FFFFFFFH *)
\par (* or a negative result is less than 80000000H *)
\par THEN #DE; (* divide error *) ;
\par ELSE
\par EAX <- temp;
\par EDX <- EDXE:AX SignedModulus SRC;
\par FI;
\par FI;
\par FI;
{\page}

${\footnote IDIV,Flags affected}
K{\footnote IDIV,IDIV;IDIV,Flags affected}
#{\footnote IDIV::3}

{\fs20\b IDIV}\tab{\b Flags affected}\par\par
The CF, OF, SF, ZF, AF, and PF flags are undefined.
{\page}

${\footnote IDIV,Exceptions}
K{\footnote IDIV,IDIV;IDIV,Exceptions}
#{\footnote IDIV::4}

{\fs20\b IDIV}\tab{\b Exceptions}\par\par
Protected Mode Exceptions
\par 
\par #DE If the source operand (divisor) is 0. The signed result (quotient) is too large for the destination.
\par #GP(0) If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit. If the DS, ES, FS, or GS register is used to access memory and it contains a null segment selector.
\par #SS(0) If a memory operand effective address is outside the SS segment limit.
\par #PF(fault-code) If a page fault occurs.
\par #AC(0) If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.
\par 
\par Real-Address Mode Exceptions
\par 
\par #DE If the source operand (divisor) is 0. The signed result (quotient) is too large for the destination.
\par #GP If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.
\par #SS If a memory operand effective address is outside the SS segment limit.
\par 
\par Virtual-8086 Mode Exceptions
\par 
\par #DE If the source operand (divisor) is 0. The signed result (quotient) is too large for the destination.
\par #GP(0) If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.
\par #SS(0) If a memory operand effective address is outside the SS segment limit.
\par #PF(fault-code) If a page fault occurs.
\par #AC(0) If alignment checking is enabled and an unaligned memory reference is made.
{\page}

${\footnote IDIV,Opcode}
K{\footnote IDIV,IDIV;IDIV,Opcode}
#{\footnote IDIV::5}

{\fs20\b IDIV}\tab{\b Opcode}\par\par
F6 /7 IDIV r/m8 Signed divide AX (where AH must contain sign-extension of AL) by r/m byte. (Results: AL=Quotient, AH=Remainder)
\par F7 /7 IDIV r/m16 Signed divide DX:AX (where DX must contain sign-extension of AX) by r/m word. (Results: AX=Quotient, DX=Remainder)
\par F7 /7 IDIV r/m32 Signed divide EDX:EAX (where EDX must contain sign-extension of EAX) by r/m doubleword. (Results: EAX=Quotient, EDX=Remainder)
{\page}

${\footnote IMUL,Description}
K{\footnote IMUL,IMUL;IMUL,Description}
#{\footnote IMUL::1}

{\fs20\b IMUL}\tab{\b Description}\par\par
IMUL: Signed Multiply
\par 
\par Performs a signed multiplication of two operands. This instruction has three forms, depending on the number of operands.
\par 
\par - One-operand form. This form is identical to that used by the MUL instruction. Here, the source operand (in a general-purpose register or memory location) is multiplied by the value in the AL, AX, or EAX register (depending on the operand size) and the product is stored in the AX, DX:AX, or EDX:EAX registers, respectively.
\par - Two-operand form. With this form the destination operand (the first operand) is multiplied by the source operand (second operand). The destination operand is a general-purpose register and the source operand is an immediate value, a general-purpose register, or a memory location. The product is then stored in the destination operand location.
\par - Three-operand form. This form requires a destination operand (the first operand) and two source operands (the second and the third operands). Here, the first source operand (which can be a general-purpose register or a memory location) is multiplied by the second source operand (an immediate value). The product is then stored in the destination operand (a general-purpose register).
\par 
\par When an immediate value is used as an operand, it is sign-extended to the length of the destination operand format. The CF and OF flags are set when significant bits are carried into the upper half of the result. The CF and OF flags are cleared when the result fits exactly in the lower half of the result.
\par The three forms of the IMUL instruction are similar in that the length of the product is calculated to twice the length of the operands. With the one-operand form, the product is stored exactly in the destination. With the two- and three- operand forms, however, result is truncated to the length of the destination before it is stored in the destination register. Because of this truncation, the CF or OF flag should be tested to ensure that no significant bits are lost.
\par The two- and three-operand forms may also be used with unsigned operands because the lower half of the product is the same regardless if the operands are signed or unsigned. The CF and OF flags, however, cannot be used to determine if the upper half of the result is non-zero.
{\page}

${\footnote IMUL,Operation}
K{\footnote IMUL,IMUL;IMUL,Operation}
#{\footnote IMUL::2}

{\fs20\b IMUL}\tab{\b Operation}\par\par
IF (NumberOfOperands = 1)
\par THEN IF (OperandSize = 8)
\par THEN
\par AX <- AL * SRC (* signed multiplication *)
\par IF ((AH = 00H) OR (AH = FFH))
\par THEN CF = 0; OF = 0;
\par ELSE CF = 1; OF = 1;
\par FI;
\par ELSE IF OperandSize = 16
\par THEN
\par DX:AX <- AX * SRC (* signed multiplication *)
\par IF ((DX = 0000H) OR (DX = FFFFH))
\par THEN CF = 0; OF = 0;
\par ELSE CF = 1; OF = 1;
\par FI;
\par ELSE (* OperandSize = 32 *)
\par EDX:EAX <- EAX * SRC (* signed multiplication *)
\par IF ((EDX = 00000000H) OR (EDX = FFFFFFFFH))
\par THEN CF = 0; OF = 0;
\par ELSE CF = 1; OF = 1;
\par FI;
\par FI;
\par ELSE IF (NumberOfOperands = 2)
\par THEN
\par temp <- DEST * SRC (* signed multiplication; temp is double DEST size*)
\par DEST <- DEST * SRC (* signed multiplication *)
\par IF temp != DEST
\par THEN CF = 1; OF = 1;
\par ELSE CF = 0; OF = 0;
\par FI;
\par ELSE (* NumberOfOperands = 3 *)
\par DEST <- SRC1 * SRC2 (* signed multiplication *)
\par temp <- SRC1 * SRC2 (* signed multiplication; temp is double SRC1 size *)
\par IF temp != DEST
\par THEN CF = 1; OF = 1;
\par ELSE CF = 0; OF = 0;
\par FI;
\par FI;
\par FI;
{\page}

${\footnote IMUL,Flags affected}
K{\footnote IMUL,IMUL;IMUL,Flags affected}
#{\footnote IMUL::3}

{\fs20\b IMUL}\tab{\b Flags affected}\par\par
For the one operand form of the instruction, the CF and OF flags are set when significant bits are carried into the upper half of the result and cleared when the result fits exactly in the lower half of the result. For the two- and three-operand forms of the instruction, the CF and OF flags are set when the result must be truncated to fit in the destination operand size and cleared when the result fits exactly in the destination operand size. The SF, ZF, AF, and PF flags are undefined.
{\page}

${\footnote IMUL,Exceptions}
K{\footnote IMUL,IMUL;IMUL,Exceptions}
#{\footnote IMUL::4}

{\fs20\b IMUL}\tab{\b Exceptions}\par\par
Protected Mode Exceptions
\par 
\par #GP(0) If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit. If the DS, ES, FS, or GS register is used to access memory and it contains a null segment selector.
\par #SS(0) If a memory operand effective address is outside the SS segment limit.
\par #PF(fault-code) If a page fault occurs.
\par #AC(0) If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.
\par 
\par Real-Address Mode Exceptions
\par 
\par #GP If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.
\par #SS If a memory operand effective address is outside the SS segment limit.
\par 
\par Virtual-8086 Mode Exceptions
\par 
\par #GP(0) If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.
\par #SS(0) If a memory operand effective address is outside the SS segment limit.
\par #PF(fault-code) If a page fault occurs.
\par #AC(0) If alignment checking is enabled and an unaligned memory reference is made.
{\page}

${\footnote IMUL,Opcode}
K{\footnote IMUL,IMUL;IMUL,Opcode}
#{\footnote IMUL::5}

{\fs20\b IMUL}\tab{\b Opcode}\par\par
F6 /5 IMUL r/m8 AX<- AL * r/m byte
\par F7 /5 IMUL r/m16 DX:AX <- AX * r/m word
\par F7 /5 IMUL r/m32 EDX:EAX <- EAX * r/m doubleword
\par 0F AF / r IMUL r16,r/m16 word register <- word register * r/m word
\par 0F AF / r IMUL r32,r/m32 doubleword register <- doubleword register * r/m doubleword
\par 6B / r ib IMUL r16,r/m16,imm8 word register <- r/m16 * sign-extended immediate byte
\par 6B / r ib IMUL r32,r/m32,imm8 doubleword register <- r/m32 * sign-extended immediate byte
\par 6B / r ib IMUL r16,imm8 word register <- word register * sign-extended immediate byte
\par 6B / r ib IMUL r32,imm8 doubleword register <- doubleword register * sign-extended immediate byte
\par 69 / r iw IMUL r16,r/m16,imm16 word register <- r/m16 * immediate word
\par 69 / r id IMUL r32,r/m32,imm32 doubleword register <- r/m32 * immediate doubleword
\par 69 / r iw IMUL r16,imm16 word register <- r/m16 * immediate word
\par 69 / r id IMUL r32,imm32 doubleword register <- r/m32 * immediate doubleword
{\page}

${\footnote IN,Description}
K{\footnote IN,IN;IN,Description}
#{\footnote IN::1}

{\fs20\b IN}\tab{\b Description}\par\par
IN: Input from Port
\par 
\par Copies the value from the I/O port specified with the second operand (source operand) to the destination operand (first operand). The source operand can be a byte-immediate or the DX register; the destination operand can be register AL, AX, or EAX, depending on the size of the port being accessed (8, 16, or 32 bits, respectively). Using the DX register as a source operand allows I/O port addresses from 0 to 65,535 to be accessed; using a byte immediate allows I/O port addresses 0 to 255 to be accessed.
\par When accessing an 8-bit I/O port, the opcode determines the port size; when accessing a 16- and 32-bit I/O port, the operand-size attribute determines the port size. At the machine code level, I/O instructions are shorter when accessing 8-bit I/O ports. Here, the upper eight bits of the port address will be 0. This instruction is only useful for accessing I/O ports located in the processor's I/O address space.
{\page}

${\footnote IN,Operation}
K{\footnote IN,IN;IN,Operation}
#{\footnote IN::2}

{\fs20\b IN}\tab{\b Operation}\par\par
IF ((PE = 1) AND ((CPL > IOPL) OR (VM = 1)))
\par THEN (* Protected mode with CPL > IOPL or virtual-8086 mode *)
\par IF (Any I/O Permission Bit for I/O port being accessed = 1)
\par THEN (* I/O operation is not allowed *)
\par #GP(0);
\par ELSE ( * I/O operation is allowed *)
\par DEST <- SRC; (* Reads from selected I/O port *)
\par FI;
\par ELSE (Real Mode or Protected Mode with CPL  IOPL *)
\par DEST <- SRC; (* Reads from selected I/O port *)
\par FI;
{\page}

${\footnote IN,Flags affected}
K{\footnote IN,IN;IN,Flags affected}
#{\footnote IN::3}

{\fs20\b IN}\tab{\b Flags affected}\par\par
None.
{\page}

${\footnote IN,Exceptions}
K{\footnote IN,IN;IN,Exceptions}
#{\footnote IN::4}

{\fs20\b IN}\tab{\b Exceptions}\par\par
Protected Mode Exceptions
\par 
\par #GP(0) If the CPL is greater than (has less privilege) the I/O privilege level (IOPL) and any of the corresponding I/O permission bits in TSS for the I/O port being accessed is 1.
\par 
\par Real-Address Mode Exceptions
\par 
\par None.
\par 
\par Virtual-8086 Mode Exceptions
\par 
\par #GP(0) If any of the I/O permission bits in the TSS for the I/O port being accessed is 1.
{\page}

${\footnote IN,Opcode}
K{\footnote IN,IN;IN,Opcode}
#{\footnote IN::5}

{\fs20\b IN}\tab{\b Opcode}\par\par
E4 ib IN AL, imm8 Input byte from imm8 I/O port address into AL
\par E5 ib IN AX, imm8 Input byte from imm8 I/O port address into AX
\par E5 ib IN EAX, imm8 Input byte from imm8 I/O port address into EAX
\par EC IN AL,DX Input byte from I/O port in DX into AL
\par ED IN AX,DX Input word from I/O port in DX into AX
\par ED IN EAX,DX Input doubleword from I/O port in DX into EAX
{\page}

${\footnote INC,Description}
K{\footnote INC,INC;INC,Description}
#{\footnote INC::1}

{\fs20\b INC}\tab{\b Description}\par\par
INC: Increment by 1
\par 
\par Adds 1 to the destination operand, while preserving the state of the CF flag. The destination operand can be a register or a memory location. This instruction allows a loop counter to be updated without disturbing the CF flag. (Use a ADD instruction with an immediate operand of 1 to perform an increment operation that does updates the CF flag.)
{\page}

${\footnote INC,Operation}
K{\footnote INC,INC;INC,Operation}
#{\footnote INC::2}

{\fs20\b INC}\tab{\b Operation}\par\par
DEST <- DEST +1;
{\page}

${\footnote INC,Flags affected}
K{\footnote INC,INC;INC,Flags affected}
#{\footnote INC::3}

{\fs20\b INC}\tab{\b Flags affected}\par\par
The CF flag is not affected. The OF, SF, ZF, AF, and PF flags are set according to the result.
{\page}

${\footnote INC,Exceptions}
K{\footnote INC,INC;INC,Exceptions}
#{\footnote INC::4}

{\fs20\b INC}\tab{\b Exceptions}\par\par
Protected Mode Exceptions
\par 
\par #GP(0) If the destination operand is located in a nonwritable segment. If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit. If the DS, ES, FS, or GS register is used to access memory and it contains a null segment selector.
\par #SS(0) If a memory operand effective address is outside the SS segment limit.
\par #PF(fault-code) If a page fault occurs.
\par #AC(0) If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.
\par 
\par Real-Address Mode Exceptions
\par 
\par #GP If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.
\par #SS If a memory operand effective address is outside the SS segment limit.
\par 
\par Virtual-8086 Mode Exceptions
\par 
\par #GP(0) If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.
\par #SS(0) If a memory operand effective address is outside the SS segment limit.
\par #PF(fault-code) If a page fault occurs.
\par #AC(0) If alignment checking is enabled and an unaligned memory reference is made.
{\page}

${\footnote INC,Opcode}
K{\footnote INC,INC;INC,Opcode}
#{\footnote INC::5}

{\fs20\b INC}\tab{\b Opcode}\par\par
FE /0 INC r/m8 Increment r/m byte by 1
\par FF /0 INC r/m16 Increment r/m word by 1
\par FF /0 INC r/m32 Increment r/m doubleword by 1
\par 40+ rw INC r16 Increment word register by 1
\par 40+ rd INC r32 Increment doubleword register by 1
{\page}

${\footnote INS,Description}
K{\footnote INS,INS;INSB,INSB;INSD,INSD;INSW,INSW;INS,Description;INSB,Description;INSD,Description;INSW,Description}
#{\footnote INS::1}
#{\footnote INSB::1}
#{\footnote INSD::1}
#{\footnote INSW::1}

{\fs20\b INS/INSB/INSD/INSW}\tab{\b Description}\par\par
INS/INSB/INSW/INSD: Input from Port to String
\par 
\par Copies the data from the I/O port specified with the source operand (second operand) to the destination operand (first operand). The source operand is an I/O port address (from 0 to 65,535) that is read from the DX register. The destination operand is a memory location, the address of which is read from either the ES:EDI or the ES:DI registers (depending on the address-size attribute of the instruction, 32 or 16, respectively). (The ES segment cannot be overridden with a segment override prefix.) The size of the I/O port being accessed (that is, the size of the source and destination operands) is determined by the opcode for an 8-bit I/O port or by the operand-size attribute of the instruction for a 16- or 32-bit I/O port.
\par At the assembly-code level, two forms of this instruction are allowed: the "explicit-operands" form and the "no-operands" form. The explicit-operands form (specified with the INS mnemonic) allows the source and destination operands to be specified explicitly. Here, the source operand must be "DX," and the destination operand should be a symbol that indicates the size of the I/O port and the destination address. This explicit-operands form is provided to allow documentation; however, note that the documentation provided by this form can be misleading. That is, the destination operand symbol must specify the correct type (size) of the operand (byte, word, or doubleword), but it does not have to specify the correct location. The location is always specified by the ES:(E)DI registers, which must be loaded correctly before the INS instruction is executed.
\par The no-operands form provides "short forms" of the byte, word, and doubleword versions of the INS instructions. Here also DX is assumed by the processor to be the source operand and ES:(E)DI is assumed to be the destination operand. The size of the I/O port is specified with the choice of mnemonic: INSB (byte), INSW (word), or INSD (doubleword).
\par After the byte, word, or doubleword is transfer from the I/O port to the memory location, the (E)DI register is incremented or decremented automatically according to the setting of the DF flag in the EFLAGS register. (If the DF flag is 0, the (E)DI register is incremented; if the DF flag is 1, the (E)DI register is decremented.) The (E)DI register is incremented or decremented by 1 for byte operations, by 2 for word operations, or by 4 for doubleword operations.
\par The INS, INSB, INSW, and INSD instructions can be preceded by the REP prefix for block input of ECX bytes, words, or doublewords. See "REP/REPE/REPZ/REPNE /REPNZ--Repeat String Operation Prefix" in this chapter for a description of the REP prefix. These instructions are only useful for accessing I/O ports located in the processor's I/O address space.
{\page}

${\footnote INS,Operation}
K{\footnote INS,INS;INSB,INSB;INSD,INSD;INSW,INSW;INS,Operation;INSB,Operation;INSD,Operation;INSW,Operation}
#{\footnote INS::2}
#{\footnote INSB::2}
#{\footnote INSD::2}
#{\footnote INSW::2}

{\fs20\b INS/INSB/INSD/INSW}\tab{\b Operation}\par\par
IF ((PE = 1) AND ((CPL > IOPL) OR (VM = 1)))
\par THEN (* Protected mode with CPL > IOPL or virtual-8086 mode *)
\par IF (Any I/O Permission Bit for I/O port being accessed = 1)
\par THEN (* I/O operation is not allowed *)
\par #GP(0);
\par ELSE ( * I/O operation is allowed *)
\par DEST <- SRC; (* Reads from I/O port *)
\par FI;
\par ELSE (Real Mode or Protected Mode with CPL  IOPL *)
\par DEST <- SRC; (* Reads from I/O port *)
\par FI;
\par IF (byte transfer)
\par THEN IF DF = 0
\par THEN (E)DI <- (E)DI + 1;
\par ELSE (E)DI <- (E)DI - 1;
\par FI;
\par ELSE IF (word transfer)
\par THEN IF DF = 0
\par THEN (E)DI <- (E)DI + 2;
\par ELSE (E)DI <- (E)DI - 2;
\par FI;
\par ELSE (* doubleword transfer *)
\par THEN IF DF = 0
\par THEN (E)DI <- (E)DI + 4;
\par ELSE (E)DI <- (E)DI - 4;
\par FI;
\par FI;
\par FI;
{\page}

${\footnote INS,Flags affected}
K{\footnote INS,INS;INSB,INSB;INSD,INSD;INSW,INSW;INS,Flags affected;INSB,Flags affected;INSD,Flags affected;INSW,Flags affected}
#{\footnote INS::3}
#{\footnote INSB::3}
#{\footnote INSD::3}
#{\footnote INSW::3}

{\fs20\b INS/INSB/INSD/INSW}\tab{\b Flags affected}\par\par
None.
{\page}

${\footnote INS,Exceptions}
K{\footnote INS,INS;INSB,INSB;INSD,INSD;INSW,INSW;INS,Exceptions;INSB,Exceptions;INSD,Exceptions;INSW,Exceptions}
#{\footnote INS::4}
#{\footnote INSB::4}
#{\footnote INSD::4}
#{\footnote INSW::4}

{\fs20\b INS/INSB/INSD/INSW}\tab{\b Exceptions}\par\par
Protected Mode Exceptions
\par 
\par #GP(0) If the CPL is greater than (has less privilege) the I/O privilege level (IOPL) and any of the corresponding I/O permission bits in TSS for the I/O port being accessed is 1. If the destination is located in a nonwritable segment. If an illegal memory operand effective address in the ES segments is given.
\par #PF(fault-code) If a page fault occurs.
\par #AC(0) If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.
\par 
\par Real-Address Mode Exceptions
\par 
\par #GP If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.
\par #SS If a memory operand effective address is outside the SS segment limit.
\par 
\par Virtual-8086 Mode Exceptions
\par 
\par #GP(0) If any of the I/O permission bits in the TSS for the I/O port being accessed is 1.
\par #PF(fault-code) If a page fault occurs.
\par #AC(0) If alignment checking is enabled and an unaligned memory reference is made.
{\page}

${\footnote INS,Opcode}
K{\footnote INS,INS;INSB,INSB;INSD,INSD;INSW,INSW;INS,Opcode;INSB,Opcode;INSD,Opcode;INSW,Opcode}
#{\footnote INS::5}
#{\footnote INSB::5}
#{\footnote INSD::5}
#{\footnote INSW::5}

{\fs20\b INS/INSB/INSD/INSW}\tab{\b Opcode}\par\par
6C INS m8, DX Input byte from I/O port specified in DX into memory location specified in ES:(E)DI
\par 6D INS m16, DX Input word from I/O port specified in DX into memory location specified in ES:(E)DI
\par 6D INS m32, DX Input doubleword from I/O port specified in DX into memory location specified in ES:(E)DI
\par 6C INSB Input byte from I/O port specified in DX into memory location specified with ES:(E)DI
\par 6D INSW Input word from I/O port specified in DX into memory location specified in ES:(E)DI
\par 6D INSD Input doubleword from I/O port specified in DX into memory location specified in ES:(E)DI
{\page}

${\footnote INT,Description}
K{\footnote INT,INT;INTO,INTO;INT,Description;INTO,Description}
#{\footnote INT::1}
#{\footnote INTO::1}

{\fs20\b INT/INTO}\tab{\b Description}\par\par
INT n/INTO/INT 3: Call to Interrupt Procedure
\par 
\par The INT n instruction generates a call to the interrupt or exception handler specified with the destination operand. The destination operand specifies an interrupt vector number from 0 to 255, encoded as an 8-bit unsigned intermediate value. Each interrupt vector number provides an index to a gate descriptor in the IDT. The first 32 interrupt vector numbers are reserved by Intel for system use. Some of these interrupts are used for internally generated exceptions.
\par The INT n instruction is the general mnemonic for executing a software-generated call to an interrupt handler. The INTO instruction is a special mnemonic for calling overflow exception (#OF), interrupt vector number 4. The overflow interrupt checks the OF flag in the EFLAGS register and calls the overflow interrupt handler if the OF flag is set to 1.
\par The INT 3 instruction generates a special one byte opcode (CC) that is intended for calling the debug exception handler. (This one byte form is valuable because it can be used to replace the first byte of any instruction with a breakpoint, including other one byte instructions, without over-writing other code). To further support its function as a debug breakpoint, the interrupt generated with the CC opcode also differs from the regular software interrupts as follows:
\par 
\par - Interrupt redirection does not happen when in VME mode; the interrupt is handled by a protected-mode handler.
\par - The virtual-8086 mode IOPL checks do not occur. The interrupt is taken without faulting at any IOPL level.
\par 
\par Note that the "normal" 2-byte opcode for INT 3 (CD03) does not have these special features. Intel and Microsoft assemblers will not generate the CD03 opcode from any mnemonic, but this opcode can be created by direct numeric code definition or by self-modifying code.
\par The action of the INT n instruction (including the INTO and INT 3 instructions) is similar to that of a far call made with the CALL instruction. The primary difference is that with the INT n instruction, the EFLAGS register is pushed onto the stack before the return address. (The return address is a far address consisting of the current values of the CS and EIP registers.) Returns from interrupt procedures are handled with the IRET instruction, which pops the EFLAGS information and return address from the stack.
\par The interrupt vector number specifies an interrupt descriptor in the interrupt descriptor table (IDT); that is, it provides index into the IDT. The selected interrupt descriptor in turn contains a pointer to an interrupt or exception handler procedure. In protected mode, the IDT contains an array of 8-byte descriptors, each of which is an interrupt gate, trap gate, or task gate. In real-address mode, the IDT is an array of 4-byte far pointers (2-byte code segment selector and a 2-byte instruction pointer), each of which point directly to a procedure in the selected segment. (Note that in real-address mode, the IDT is called the interrupt vector table, and it's pointers are called interrupt vectors.)
\par When the processor is executing in virtual-8086 mode, the IOPL determines the action of the INT n instruction. If the IOPL is less than 3, the processor generates a general protection exception (#GP); if the IOPL is 3, the processor executes a protected mode interrupt to privilege level 0. The interrupt gate's DPL must be set to three and the target CPL of the interrupt handler procedure must be 0 to execute the protected mode interrupt to privilege level 0. The interrupt descriptor table register (IDTR) specifies the base linear address and limit of the IDT. The initial base address value of the IDTR after the processor is powered up or reset is 0.
{\page}

${\footnote INT,Operation}
K{\footnote INT,INT;INTO,INTO;INT,Operation;INTO,Operation}
#{\footnote INT::2}
#{\footnote INTO::2}

{\fs20\b INT/INTO}\tab{\b Operation}\par\par
The following operational description applies not only to the INT n and INTO instructions, but also to external interrupts and exceptions.
\par 
\par IF PE=0
\par THEN
\par GOTO REAL-ADDRESS-MODE;
\par ELSE (* PE=1 *)
\par IF (VM=1 AND IOPL < 3 AND INT n)
\par THEN
\par #GP(0);
\par ELSE (* protected mode or virtual-8086 mode interrupt *)
\par GOTO PROTECTED-MODE;
\par FI;
\par FI;
\par 
\par REAL-ADDRESS-MODE:
\par IF ((DEST * 4) + 3) is not within IDT limit THEN #GP; FI;
\par IF stack not large enough for a 6-byte return information THEN #SS; FI;
\par Push (EFLAGS[15:0]);
\par IF <- 0; (* Clear interrupt flag *)
\par TF <- 0; (* Clear trap flag *)
\par AC <- 0; (*Clear AC flag*)
\par Push(CS);
\par Push(IP);
\par (* No error codes are pushed *)
\par CS <- IDT(Descriptor (vector_number * 4), selector));
\par EIP <- IDT(Descriptor (vector_number * 4), offset)); (* 16 bit offset AND 0000FFFFH *)
\par END;
\par 
\par PROTECTED-MODE:
\par IF ((DEST * 8) + 7) is not within IDT limits
\par OR selected IDT descriptor is not an interrupt-, trap-, or task-gate type
\par THEN #GP((DEST * 8) + 2 + EXT);
\par (* EXT is bit 0 in error code *)
\par FI;
\par IF software interrupt (* generated by INT n, INT 3, or INTO *)
\par THEN
\par IF gate descriptor DPL < CPL
\par THEN #GP((vector_number * 8) + 2 );
\par (* PE=1, DPL<CPL, software interrupt *)
\par FI;
\par FI;
\par IF gate not present THEN #NP((vector_number * 8) + 2 + EXT); FI;
\par IF task gate (* specified in the selected interrupt table descriptor *)
\par THEN GOTO TASK-GATE;
\par ELSE GOTO TRAP-OR-INTERRUPT-GATE; (* PE=1, trap/interrupt gate *)
\par FI;
\par END;
\par 
\par TASK-GATE: (* PE=1, task gate *)
\par Read segment selector in task gate (IDT descriptor);
\par IF local/global bit is set to local
\par OR index not within GDT limits
\par THEN #GP(TSS selector);
\par FI;
\par Access TSS descriptor in GDT;
\par IF TSS descriptor specifies that the TSS is busy (low-order 5 bits set to 00001)
\par THEN #GP(TSS selector);
\par FI;
\par IF TSS not present
\par THEN #NP(TSS selector);
\par FI;
\par SWITCH-TASKS (with nesting) to TSS;
\par IF interrupt caused by fault with error code
\par THEN
\par IF stack limit does not allow push of error code
\par THEN #SS(0);
\par FI;
\par Push(error code);
\par FI;
\par IF EIP not within code segment limit
\par THEN #GP(0);
\par FI;
\par END;
\par 
\par TRAP-OR-INTERRUPT-GATE
\par Read segment selector for trap or interrupt gate (IDT descriptor);
\par IF segment selector for code segment is null
\par THEN #GP(0H + EXT); (* null selector with EXT flag set *)
\par FI;
\par IF segment selector is not within its descriptor table limits
\par THEN #GP(selector + EXT);
\par FI;
\par Read trap or interrupt handler descriptor;
\par IF descriptor does not indicate a code segment
\par OR code segment descriptor DPL > CPL
\par THEN #GP(selector + EXT);
\par FI;
\par IF trap or interrupt gate segment is not present,
\par THEN #NP(selector + EXT);
\par FI;
\par IF code segment is non-conforming AND DPL < CPL
\par THEN IF VM=0
\par THEN
\par GOTO INTER-PRIVILEGE-LEVEL-INTERRUPT;
\par (* PE=1, interrupt or trap gate, nonconforming *)
\par (* code segment, DPL<CPL, VM=0 *)
\par ELSE (* VM=1 *)
\par IF code segment DPL != 0 THEN #GP(new code segment selector); FI;
\par GOTO INTERRUPT-FROM-VIRTUAL-8086-MODE;
\par (* PE=1, interrupt or trap gate, DPL<CPL, VM=1 *)
\par FI;
\par ELSE (* PE=1, interrupt or trap gate, DPL  CPL *)
\par IF VM=1 THEN #GP(new code segment selector); FI;
\par IF code segment is conforming OR code segment DPL = CPL
\par THEN
\par GOTO INTRA-PRIVILEGE-LEVEL-INTERRUPT;
\par ELSE
\par #GP(CodeSegmentSelector + EXT);
\par (* PE=1, interrupt or trap gate, nonconforming *)
\par (* code segment, DPL>CPL *)
\par FI;
\par FI;
\par END;
\par 
\par INTER-PREVILEGE-LEVEL-INTERRUPT
\par (* PE=1, interrupt or trap gate, non-conforming code segment, DPL<CPL *)
\par (* Check segment selector and descriptor for stack of new privilege level in current TSS *)
\par IF current TSS is 32-bit TSS
\par THEN
\par TSSstackAddress <- (new code segment DPL * 8) + 4
\par IF (TSSstackAddress + 7) > TSS limit
\par THEN #TS(current TSS selector); FI;
\par NewSS <- TSSstackAddress + 4;
\par NewESP <- stack address;
\par ELSE (* TSS is 16-bit *)
\par TSSstackAddress <- (new code segment DPL * 4) + 2
\par IF (TSSstackAddress + 4) > TSS limit
\par THEN #TS(current TSS selector); FI;
\par NewESP <- TSSstackAddress;
\par NewSS <- TSSstackAddress + 2;
\par FI;
\par IF segment selector is null THEN #TS(EXT); FI;
\par IF segment selector index is not within its descriptor table limits
\par OR segment selector's RPL != DPL of code segment,
\par THEN #TS(SS selector + EXT);
\par FI;
\par Read segment descriptor for stack segment in GDT or LDT;
\par IF stack segment DPL != DPL of code segment,
\par OR stack segment does not indicate writable data segment,
\par THEN #TS(SS selector + EXT);
\par FI;
\par IF stack segment not present THEN #SS(SS selector+EXT); FI;
\par IF 32-bit gate
\par THEN
\par IF new stack does not have room for 24 bytes (error code pushed)
\par OR 20 bytes (no error code pushed)
\par THEN #SS(segment selector + EXT);
\par FI;
\par ELSE (* 16-bit gate *)
\par IF new stack does not have room for 12 bytes (error code pushed)
\par OR 10 bytes (no error code pushed);
\par THEN #SS(segment selector + EXT);
\par FI;
\par FI;
\par IF instruction pointer is not within code segment limits THEN #GP(0); FI;
\par SS:ESP <- TSS(NewSS:NewESP) (* segment descriptor information also loaded *)
\par IF 32-bit gate
\par THEN
\par CS:EIP <- Gate(CS:EIP); (* segment descriptor information also loaded *)
\par ELSE (* 16-bit gate *)
\par CS:IP <- Gate(CS:IP); (* segment descriptor information also loaded *)
\par FI;
\par IF 32-bit gate
\par THEN
\par Push(far pointer to old stack); (* old SS and ESP, 3 words padded to 4 *);
\par Push(EFLAGS);
\par Push(far pointer to return instruction); (* old CS and EIP, 3 words padded to 4*);
\par Push(ErrorCode); (* if needed, 4 bytes *)
\par ELSE(* 16-bit gate *)
\par Push(far pointer to old stack); (* old SS and SP, 2 words *);
\par Push(EFLAGS(15..0));
\par Push(far pointer to return instruction); (* old CS and IP, 2 words *);
\par Push(ErrorCode); (* if needed, 2 bytes *)
\par FI;
\par CPL <- CodeSegmentDescriptor(DPL);
\par CS(RPL) <- CPL;
\par IF interrupt gate
\par THEN IF <- 0 (* interrupt flag to 0 (disabled) *); FI;
\par TF <- 0;
\par VM <- 0;
\par RF <- 0;
\par NT <- 0;
\par END;
\par 
\par INTERRUPT-FROM-VIRTUAL-8086-MODE:
\par (* Check segment selector and descriptor for privilege level 0 stack in current TSS *)
\par IF current TSS is 32-bit TSS
\par THEN
\par TSSstackAddress <- (new code segment DPL * 8) + 4
\par IF (TSSstackAddress + 7) > TSS limit
\par THEN #TS(current TSS selector); FI;
\par NewSS <- TSSstackAddress + 4;
\par NewESP <- stack address;
\par ELSE (* TSS is 16-bit *)
\par TSSstackAddress <- (new code segment DPL * 4) + 2
\par IF (TSSstackAddress + 4) > TSS limit
\par THEN #TS(current TSS selector); FI;
\par NewESP <- TSSstackAddress;
\par NewSS <- TSSstackAddress + 2;
\par FI;
\par IF segment selector is null THEN #TS(EXT); FI;
\par IF segment selector index is not within its descriptor table limits
\par OR segment selector's RPL != DPL of code segment,
\par THEN #TS(SS selector + EXT);
\par FI;
\par Access segment descriptor for stack segment in GDT or LDT;
\par IF stack segment DPL != DPL of code segment,
\par OR stack segment does not indicate writable data segment,
\par THEN #TS(SS selector + EXT);
\par FI;
\par IF stack segment not present THEN #SS(SS selector+EXT); FI;
\par IF 32-bit gate
\par THEN
\par IF new stack does not have room for 40 bytes (error code pushed)
\par OR 36 bytes (no error code pushed);
\par THEN #SS(segment selector + EXT);
\par FI;
\par ELSE (* 16-bit gate *)
\par IF new stack does not have room for 20 bytes (error code pushed)
\par OR 18 bytes (no error code pushed);
\par THEN #SS(segment selector + EXT);
\par FI;
\par FI;
\par IF instruction pointer is not within code segment limits THEN #GP(0); FI;
\par tempEFLAGS <- EFLAGS;
\par VM <- 0;
\par TF <- 0;
\par RF <- 0;
\par IF service through interrupt gate THEN IF <- 0; FI;
\par TempSS <- SS;
\par TempESP <- ESP;
\par SS:ESP <- TSS(SS0:ESP0); (* Change to level 0 stack segment *)
\par (* Following pushes are 16 bits for 16-bit gate and 32 bits for 32-bit gates *)
\par (* Segment selector pushes in 32-bit mode are padded to two words *)
\par Push(GS);
\par Push(FS);
\par Push(DS);
\par Push(ES);
\par Push(TempSS);
\par Push(TempESP);
\par Push(TempEFlags);
\par Push(CS);
\par Push(EIP);
\par GS <- 0; (*segment registers nullified, invalid in protected mode *)
\par FS <- 0;
\par DS <- 0;
\par ES <- 0;
\par CS <- Gate(CS);
\par IF OperandSize=32
\par THEN
\par EIP <- Gate(instruction pointer);
\par ELSE (* OperandSize is 16 *)
\par EIP <- Gate(instruction pointer) AND 0000FFFFH;
\par FI;
\par (* Starts execution of new routine in Protected Mode *)
\par END;
\par 
\par INTRA-PRIVILEGE-LEVEL-INTERRUPT:
\par (* PE=1, DPL = CPL or conforming segment *)
\par IF 32-bit gate
\par THEN
\par IF current stack does not have room for 16 bytes (error code pushed)
\par OR 12 bytes (no error code pushed); THEN #SS(0);
\par FI;
\par ELSE (* 16-bit gate *)
\par IF current stack does not have room for 8 bytes (error code pushed)
\par OR 6 bytes (no error code pushed); THEN #SS(0);
\par FI;
\par IF instruction pointer not within code segment limit THEN #GP(0); FI;
\par IF 32-bit gate
\par THEN
\par Push (EFLAGS);
\par Push (far pointer to return instruction); (* 3 words padded to 4 *)
\par CS:EIP <- Gate(CS:EIP); (* segment descriptor information also loaded *)
\par Push (ErrorCode); (* if any *)
\par ELSE (* 16-bit gate *)
\par Push (FLAGS);
\par Push (far pointer to return location); (* 2 words *)
\par CS:IP <- Gate(CS:IP); (* segment descriptor information also loaded *)
\par Push (ErrorCode); (* if any *)
\par FI;
\par CS(RPL) <- CPL;
\par IF interrupt gate
\par THEN
\par IF <- 0; FI;
\par TF <- 0;
\par NT <- 0;
\par VM <- 0;
\par RF <- 0;
\par FI;
\par END;
{\page}

${\footnote INT,Flags affected}
K{\footnote INT,INT;INTO,INTO;INT,Flags affected;INTO,Flags affected}
#{\footnote INT::3}
#{\footnote INTO::3}

{\fs20\b INT/INTO}\tab{\b Flags affected}\par\par
The EFLAGS register is pushed onto the stack. The IF, TF, NT, AC, RF, and VM flags may be cleared, depending on the mode of operation of the processor when the INT instruction is executed (see the "Operation" section). If the interrupt uses a task gate, any flags may be set or cleared, controlled by the EFLAGS image in the new task's TSS.
{\page}

${\footnote INT,Exceptions}
K{\footnote INT,INT;INTO,INTO;INT,Exceptions;INTO,Exceptions}
#{\footnote INT::4}
#{\footnote INTO::4}

{\fs20\b INT/INTO}\tab{\b Exceptions}\par\par
Protected Mode Exceptions
\par 
\par #GP(0) If the instruction pointer in the IDT or in the interrupt-, trap-, or task gate is beyond the code segment limits.
\par #GP(selector) If the segment selector in the interrupt-, trap-, or task gate is null. If a interrupt-, trap-, or task gate, code segment, or TSS segment selector index is outside its descriptor table limits. If the interrupt vector number is outside the IDT limits. If an IDT descriptor is not an interrupt-, trap-, or task-descriptor. If an interrupt is generated by the INT n, INT 3, or INTO instruction and the DPL of an interrupt-, trap-, or task-descriptor is less than the CPL. If the segment selector in an interrupt- or trap-gate does not point to a segment descriptor for a code segment. If the segment selector for a TSS has its local/global bit set for local. If a TSS segment descriptor specifies that the TSS is busy or not available.
\par #SS(0) If pushing the return address, flags, or error code onto the stack exceeds the bounds of the stack segment and no stack switch occurs.
\par #SS(selector) If the SS register is being loaded and the segment pointed to is marked not present. If pushing the return address, flags, error code, or stack segment pointer exceeds the bounds of the new stack segment when a stack switch occurs.
\par #NP(selector) If code segment, interrupt-, trap-, or task gate, or TSS is not present.
\par #TS(selector) If the RPL of the stack segment selector in the TSS is not equal to the DPL of the code segment being accessed by the interrupt or trap gate. If DPL of the stack segment descriptor pointed to by the stack segment selector in the TSS is not equal to the DPL of the code segment descriptor for the interrupt or trap gate. If the stack segment selector in the TSS is null. If the stack segment for the TSS is not a writable data segment. If segment-selector index for stack segment is outside descriptor table limits.
\par #PF(fault-code) If a page fault occurs.
\par 
\par Real-Address Mode Exceptions
\par 
\par #GP If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit. If the interrupt vector number is outside the IDT limits.
\par #SS If stack limit violation on push. If pushing the return address, flags, or error code onto the stack exceeds the bounds of the stack segment.
\par 
\par Virtual-8086 Mode Exceptions
\par 
\par #GP(0) (For INT n, INTO, or BOUND instruction) If the IOPL is less than 3 or the DPL of the interrupt-, trap-, or task-gate descriptor is not equal to 3. If the instruction pointer in the IDT or in the interrupt-, trap-, or task gate is beyond the code segment limits.
\par #GP(selector) If the segment selector in the interrupt-, trap-, or task gate is null. If a interrupt-, trap-, or task gate, code segment, or TSS segment selector index is outside its descriptor table limits. If the interrupt vector number is outside the IDT limits. If an IDT descriptor is not an interrupt-, trap-, or task-descriptor. If an interrupt is generated by the INT n instruction and the DPL of an interrupt-, trap-, or task-descriptor is less than the CPL. If the segment selector in an interrupt- or trap-gate does not point to a segment descriptor for a code segment. If the segment selector for a TSS has its local/global bit set for local.
\par #SS(selector) If the SS register is being loaded and the segment pointed to is marked not present. If pushing the return address, flags, error code, stack segment pointer, or data segments exceeds the bounds of the stack segment.
\par #NP(selector) If code segment, interrupt-, trap-, or task gate, or TSS is not present.
\par #TS(selector) If the RPL of the stack segment selector in the TSS is not equal to the DPL of the code segment being accessed by the interrupt or trap gate. If DPL of the stack segment descriptor for the TSS's stack segment is not equal to the DPL of the code segment descriptor for the interrupt or trap gate. If the stack segment selector in the TSS is null. If the stack segment for the TSS is not a writable data segment. If segment-selector index for stack segment is outside descriptor table limits.
\par #PF(fault-code) If a page fault occurs.
\par #BP If the INT 3 instruction is executed.
\par #OF If the INTO instruction is executed and the OF flag is set.
{\page}

${\footnote INT,Opcode}
K{\footnote INT,INT;INTO,INTO;INT,Opcode;INTO,Opcode}
#{\footnote INT::5}
#{\footnote INTO::5}

{\fs20\b INT/INTO}\tab{\b Opcode}\par\par
CC INT 3 Interrupt 3--trap to debugger
\par CD ib INT imm8 Interrupt vector number specified by immediate byte
\par CE INTO Interrupt 4--if overflow flag is 1
{\page}

${\footnote INVD,Description}
K{\footnote INVD,INVD;INVD,Description}
#{\footnote INVD::1}

{\fs20\b INVD}\tab{\b Description}\par\par
INVD: Invalidate Internal Caches
\par 
\par Invalidates (flushes) the processor's internal caches and issues a special-function bus cycle that directs external caches to also flush themselves. Data held in internal caches is not written back to main memory. After executing this instruction, the processor does not wait for the external caches to complete their flushing operation before proceeding with instruction execution. It is the responsibility of hardware to respond to the cache flush signal. The INVD instruction is a privileged instruction. When the processor is running in protected mode, the CPL of a program or procedure must be 0 to execute this instruction.
\par Use this instruction with care. Data cached internally and not written back to main memory will be lost. Unless there is a specific requirement or benefit to flushing caches without writing back modified cache lines (for example, testing or fault recovery where cache coherency with main memory is not a concern), software should use the WBINVD instruction.
\par 
\par Intel Architecture Compatibility
\par 
\par The INVD instruction is implementation dependent, and its function may be implemented differently on future Intel Architecture processors. This instruction is not supported on Intel Architecture processors earlier than the Intel486 processor.
{\page}

${\footnote INVD,Operation}
K{\footnote INVD,INVD;INVD,Operation}
#{\footnote INVD::2}

{\fs20\b INVD}\tab{\b Operation}\par\par
Flush(InternalCaches);
\par SignalFlush(ExternalCaches);
\par Continue (* Continue execution);
{\page}

${\footnote INVD,Flags affected}
K{\footnote INVD,INVD;INVD,Flags affected}
#{\footnote INVD::3}

{\fs20\b INVD}\tab{\b Flags affected}\par\par
None.
{\page}

${\footnote INVD,Exceptions}
K{\footnote INVD,INVD;INVD,Exceptions}
#{\footnote INVD::4}

{\fs20\b INVD}\tab{\b Exceptions}\par\par
Protected Mode Exceptions
\par 
\par #GP(0) If the current privilege level is not 0.
\par 
\par Real-Address Mode Exceptions
\par 
\par None.
\par 
\par Virtual-8086 Mode Exceptions
\par 
\par #GP(0) The INVD instruction cannot be executed in virtual-8086 mode.
{\page}

${\footnote INVD,Opcode}
K{\footnote INVD,INVD;INVD,Opcode}
#{\footnote INVD::5}

{\fs20\b INVD}\tab{\b Opcode}\par\par
0F 08 INVD Flush internal caches; initiate flushing of external caches.
{\page}

${\footnote INVLPG,Description}
K{\footnote INVLPG,INVLPG;INVLPG,Description}
#{\footnote INVLPG::1}

{\fs20\b INVLPG}\tab{\b Description}\par\par
INVLPG: Invalidate TLB Entry
\par 
\par Invalidates (flushes) the translation lookaside buffer (TLB) entry specified with the source operand. The source operand is a memory address. The processor determines the page that contains that address and flushes the TLB entry for that page. The INVLPG instruction is a privileged instruction. When the processor is running in protected mode, the CPL of a program or procedure must be 0 to execute this instruction. The INVLPG instruction normally flushes the TLB entry only for the specified page; however, in some cases, it flushes the entire TLB.
\par 
\par Intel Architecture Compatibility
\par 
\par The INVLPG instruction is implementation dependent, and its function may be implemented differently on future Intel Architecture processors. This instruction is not supported on Intel Architecture processors earlier than the Intel486 processor.
{\page}

${\footnote INVLPG,Operation}
K{\footnote INVLPG,INVLPG;INVLPG,Operation}
#{\footnote INVLPG::2}

{\fs20\b INVLPG}\tab{\b Operation}\par\par
Flush(RelevantTLBEntries);
\par Continue (* Continue execution);
{\page}

${\footnote INVLPG,Flags affected}
K{\footnote INVLPG,INVLPG;INVLPG,Flags affected}
#{\footnote INVLPG::3}

{\fs20\b INVLPG}\tab{\b Flags affected}\par\par
None.
{\page}

${\footnote INVLPG,Exceptions}
K{\footnote INVLPG,INVLPG;INVLPG,Exceptions}
#{\footnote INVLPG::4}

{\fs20\b INVLPG}\tab{\b Exceptions}\par\par
Protected Mode Exceptions
\par 
\par #GP(0) If the current privilege level is not 0.
\par #UD Operand is a register.
\par 
\par Real-Address Mode Exceptions
\par 
\par #UD Operand is a register.
\par 
\par Virtual-8086 Mode Exceptions
\par 
\par #GP(0) The INVLPG instruction cannot be executed at the virtual-8086 mode.
{\page}

${\footnote INVLPG,Opcode}
K{\footnote INVLPG,INVLPG;INVLPG,Opcode}
#{\footnote INVLPG::5}

{\fs20\b INVLPG}\tab{\b Opcode}\par\par
0F 01/7 INVLPG m Invalidate TLB Entry for page that contains m
{\page}

${\footnote IRET,Description}
K{\footnote IRET,IRET;IRETD,IRETD;IRET,Description;IRETD,Description}
#{\footnote IRET::1}
#{\footnote IRETD::1}

{\fs20\b IRET/IRETD}\tab{\b Description}\par\par
IRET/IRETD: Interrupt Return
\par 
\par Returns program control from an exception or interrupt handler to a program or procedure that was interrupted by an exception, an external interrupt, or a software-generated interrupt. These instructions are also used to perform a return from a nested task. (A nested task is created when a CALL instruction is used to initiate a task switch or when an interrupt or exception causes a task switch to an interrupt or exception handler.)
\par IRET and IRETD are mnemonics for the same opcode. The IRETD mnemonic (interrupt return double) is intended for use when returning from an interrupt when using the 32-bit operand size; however, most assemblers use the IRET mnemonic interchangeably for both operand sizes. In Real-Address Mode, the IRET instruction preforms a far return to the interrupted program or procedure. During this operation, the processor pops the return instruction pointer, return code segment selector, and EFLAGS image from the stack to the EIP, CS, and EFLAGS registers, respectively, and then resumes execution of the interrupted program or procedure.
\par In Protected Mode, the action of the IRET instruction depends on the settings of the NT (nested task) and VM flags in the EFLAGS register and the VM flag in the EFLAGS image stored on the current stack. Depending on the setting of these flags, the processor performs the following types of interrupt returns:
\par 
\par - Return from virtual-8086 mode.
\par - Return to virtual-8086 mode.
\par - Intra-privilege level return.
\par - Inter-privilege level return.
\par - Return from nested task (task switch).
\par 
\par If the NT flag (EFLAGS register) is cleared, the IRET instruction performs a far return from the interrupt procedure, without a task switch. The code segment being returned to must be equally or less privileged than the interrupt handler routine (as indicated by the RPL field of the code segment selector popped from the stack). As with a real-address mode interrupt return, the IRET instruction pops the return instruction pointer, return code segment selector, and EFLAGS image from the stack to the EIP, CS, and EFLAGS registers, respectively, and then resumes execution of the interrupted program or procedure. If the return is to another privilege level, the IRET instruction also pops the stack pointer and SS from the stack, before resuming program execution. If the return is to virtual-8086 mode, the processor also pops the data segment registers from the stack.
\par If the NT flag is set, the IRET instruction performs a task switch (return) from a nested task  (a task called with a CALL instruction, an interrupt, or an exception) back to the calling or interrupted task. The updated state of the task executing the IRET instruction is saved in its TSS. If the task is reentered later, the code that follows the IRET instruction is executed.
{\page}

${\footnote IRET,Operation}
K{\footnote IRET,IRET;IRETD,IRETD;IRET,Operation;IRETD,Operation}
#{\footnote IRET::2}
#{\footnote IRETD::2}

{\fs20\b IRET/IRETD}\tab{\b Operation}\par\par
IF PE = 0
\par THEN
\par GOTO REAL-ADDRESS-MODE:;
\par ELSE
\par GOTO PROTECTED-MODE;
\par FI;
\par 
\par REAL-ADDRESS-MODE;
\par IF OperandSize = 32
\par THEN
\par IF top 12 bytes of stack not within stack limits THEN #SS; FI;
\par IF instruction pointer not within code segment limits THEN #GP(0); FI;
\par EIP <- Pop();
\par CS <- Pop(); (* 32-bit pop, high-order 16-bits discarded *)
\par tempEFLAGS <- Pop();
\par EFLAGS <- (tempEFLAGS AND 257FD5H) OR (EFLAGS AND 1A0000H);
\par ELSE (* OperandSize = 16 *)
\par IF top 6 bytes of stack are not within stack limits THEN #SS; FI;
\par IF instruction pointer not within code segment limits THEN #GP(0); FI;
\par EIP <- Pop();
\par EIP <- EIP AND 0000FFFFH;
\par CS <- Pop(); (* 16-bit pop *)
\par EFLAGS[15:0] <- Pop();
\par FI;
\par END;
\par 
\par PROTECTED-MODE:
\par IF VM = 1 (* Virtual-8086 mode: PE=1, VM=1 *)
\par THEN
\par GOTO RETURN-FROM-VIRTUAL-8086-MODE; (* PE=1, VM=1 *)
\par FI;
\par IF NT = 1
\par THEN
\par GOTO TASK-RETURN;( *PE=1, VM=0, NT=1 *)
\par FI;
\par IF OperandSize=32
\par THEN
\par IF top 12 bytes of stack not within stack limits
\par THEN #SS(0)
\par FI;
\par tempEIP <- Pop();
\par tempCS <- Pop();
\par tempEFLAGS <- Pop();
\par ELSE (* OperandSize = 16 *)
\par IF top 6 bytes of stack are not within stack limits
\par THEN #SS(0);
\par FI;
\par tempEIP <- Pop();
\par tempCS <- Pop();
\par tempEFLAGS <- Pop();
\par tempEIP <- tempEIP AND FFFFH;
\par tempEFLAGS <- tempEFLAGS AND FFFFH;
\par FI;
\par IF tempEFLAGS(VM) = 1 AND CPL=0
\par THEN
\par GOTO RETURN-TO-VIRTUAL-8086-MODE;
\par (* PE=1, VM=1 in EFLAGS image *)
\par ELSE
\par GOTO PROTECTED-MODE-RETURN;
\par (* PE=1, VM=0 in EFLAGS image *)
\par FI;
\par RETURN-FROM-VIRTUAL-8086-MODE:
\par (* Processor is in virtual-8086 mode when IRET is executed and stays in virtual-8086 mode *)
\par IF IOPL=3 (* Virtual mode: PE=1, VM=1, IOPL=3 *)
\par THEN IF OperandSize = 32
\par THEN
\par IF top 12 bytes of stack not within stack limits THEN #SS(0); FI;
\par IF instruction pointer not within code segment limits THEN #GP(0); FI;
\par EIP <- Pop();
\par CS <- Pop(); (* 32-bit pop, high-order 16-bits discarded *)
\par EFLAGS <- Pop();
\par (*VM,IOPL,VIP,and VIF EFLAGS bits are not modified by pop *)
\par ELSE (* OperandSize = 16 *)
\par IF top 6 bytes of stack are not within stack limits THEN #SS(0); FI;
\par IF instruction pointer not within code segment limits THEN #GP(0); FI;
\par EIP <- Pop();
\par EIP <- EIP AND 0000FFFFH;
\par CS <- Pop(); (* 16-bit pop *)
\par EFLAGS[15:0] <- Pop(); (* IOPL in EFLAGS is not modified by pop *)
\par FI;
\par ELSE
\par #GP(0); (* trap to virtual-8086 monitor: PE=1, VM=1, IOPL<3 *)
\par FI;
\par END;
\par 
\par RETURN-TO-VIRTUAL-8086-MODE:
\par (* Interrupted procedure was in virtual-8086 mode: PE=1, VM=1 in flags image *)
\par IF top 24 bytes of stack are not within stack segment limits
\par THEN #SS(0);
\par FI;
\par IF instruction pointer not within code segment limits
\par THEN #GP(0);
\par FI;
\par CS <- tempCS;
\par EIP <- tempEIP;
\par EFLAGS <- tempEFLAGS
\par TempESP <- Pop();
\par TempSS <- Pop();
\par ES <- Pop(); (* pop 2 words; throw away high-order word *)
\par DS <- Pop(); (* pop 2 words; throw away high-order word *)
\par FS <- Pop(); (* pop 2 words; throw away high-order word *)
\par GS <- Pop(); (* pop 2 words; throw away high-order word *)
\par SS:ESP <- TempSS:TempESP;
\par (* Resume execution in Virtual-8086 mode *)
\par END;
\par 
\par TASK-RETURN: (* PE=1, VM=1, NT=1 *)
\par Read segment selector in link field of current TSS;
\par IF local/global bit is set to local
\par OR index not within GDT limits
\par THEN #GP(TSS selector);
\par FI;
\par Access TSS for task specified in link field of current TSS;
\par IF TSS descriptor type is not TSS or if the TSS is marked not busy
\par THEN #GP(TSS selector);
\par FI;
\par IF TSS not present
\par THEN #NP(TSS selector);
\par FI;
\par SWITCH-TASKS (without nesting) to TSS specified in link field of current TSS;
\par Mark the task just abandoned as NOT BUSY;
\par IF EIP is not within code segment limit
\par THEN #GP(0);
\par FI;
\par END;
\par 
\par PROTECTED-MODE-RETURN: (* PE=1, VM=0 in flags image *)
\par IF return code segment selector is null THEN GP(0); FI;
\par IF return code segment selector addrsses descriptor beyond descriptor table limit
\par THEN GP(selector; FI;
\par Read segment descriptor pointed to by the return code segment selector
\par IF return code segment descriptor is not a code segment THEN #GP(selector); FI;
\par IF return code segment selector RPL < CPL THEN #GP(selector); FI;
\par IF return code segment descriptor is conforming
\par AND return code segment DPL > return code segment selector RPL
\par THEN #GP(selector); FI;
\par IF return code segment descriptor is not present THEN #NP(selector); FI:
\par IF return code segment selector RPL > CPL
\par THEN GOTO RETURN-OUTER-PRIVILEGE-LEVEL;
\par ELSE GOTO RETURN-TO-SAME-PRIVILEGE-LEVEL
\par FI;
\par END;
\par 
\par RETURN-TO-SAME-PRIVILEGE-LEVEL: (* PE=1, VM=0 in flags image, RPL=CPL *)
\par IF EIP is not within code segment limits THEN #GP(0); FI;
\par EIP <- tempEIP;
\par CS <- tempCS; (* segment descriptor information also loaded *)
\par EFLAGS (CF, PF, AF, ZF, SF, TF, DF, OF, NT) <- tempEFLAGS;
\par IF OperandSize=32
\par THEN
\par EFLAGS(RF, AC, ID) <- tempEFLAGS;
\par FI;
\par IF CPL  IOPL
\par THEN
\par EFLAGS(IF) <- tempEFLAGS;
\par FI;
\par IF CPL = 0
\par THEN
\par EFLAGS(IOPL) <- tempEFLAGS;
\par IF OperandSize=32
\par THEN EFLAGS(VM, VIF, VIP) <- tempEFLAGS;
\par FI;
\par FI;
\par END;
\par 
\par RETURN-TO-OUTER-PRIVILGE-LEVEL:
\par IF OperandSize=32
\par THEN
\par IF top 8 bytes on stack are not within limits THEN #SS(0); FI;
\par ELSE (* OperandSize=16 *)
\par IF top 4 bytes on stack are not within limits THEN #SS(0); FI;
\par FI;
\par Read return segment selector;
\par IF stack segment selector is null THEN #GP(0); FI;
\par IF return stack segment selector index is not within its descriptor table limits
\par THEN #GP(SSselector); FI;
\par Read segment descriptor pointed to by return segment selector;
\par IF stack segment selector RPL != RPL of the return code segment selector
\par IF stack segment selector RPL != RPL of the return code segment selector
\par OR the stack segment descriptor does not indicate a a writable data segment;
\par OR stack segment DPL != RPL of the return code segment selector
\par THEN #GP(SS selector);
\par FI;
\par IF stack segment is not present THEN #SS(SS selector); FI;
\par IF tempEIP is not within code segment limit THEN #GP(0); FI;
\par EIP <- tempEIP;
\par CS <- tempCS;
\par EFLAGS (CF, PF, AF, ZF, SF, TF, DF, OF, NT) <- tempEFLAGS;
\par IF OperandSize=32
\par THEN
\par EFLAGS(RF, AC, ID) <- tempEFLAGS;
\par FI;
\par IF CPL  IOPL
\par THEN
\par EFLAGS(IF) <- tempEFLAGS;
\par FI;
\par IF CPL = 0
\par THEN
\par EFLAGS(IOPL) <- tempEFLAGS;
\par IF OperandSize=32
\par THEN EFLAGS(VM, VIF, VIP) <- tempEFLAGS;
\par FI;
\par FI;
\par CPL <- RPL of the return code segment selector;
\par FOR each of segment register (ES, FS, GS, and DS)
\par DO;
\par IF segment register points to data or non-conforming code segment
\par AND CPL > segment descriptor DPL (* stored in hidden part of segment register *)
\par THEN (* segment register invalid *)
\par SegmentSelector <- 0; (* null segment selector *)
\par FI;
\par OD;
\par END:
{\page}

${\footnote IRET,Flags affected}
K{\footnote IRET,IRET;IRETD,IRETD;IRET,Flags affected;IRETD,Flags affected}
#{\footnote IRET::3}
#{\footnote IRETD::3}

{\fs20\b IRET/IRETD}\tab{\b Flags affected}\par\par
All the flags and fields in the EFLAGS register are potentially modified, depending on the mode of operation of the processor. If performing a return from a nested task to a previous task, the EFLAGS register will be modified according to the EFLAGS image stored in the previous task's TSS.
{\page}

${\footnote IRET,Exceptions}
K{\footnote IRET,IRET;IRETD,IRETD;IRET,Exceptions;IRETD,Exceptions}
#{\footnote IRET::4}
#{\footnote IRETD::4}

{\fs20\b IRET/IRETD}\tab{\b Exceptions}\par\par
Protected Mode Exceptions
\par #GP(0) If the return code or stack segment selector is null. If the return instruction pointer is not within the return code segment limit.
\par #GP(selector) If a segment selector index is outside its descriptor table limits. If the return code segment selector RPL is greater than the CPL. If the DPL of a conforming-code segment is greater than the return code segment selector RPL. If the DPL for a nonconforming-code segment is not equal to the RPL of the code segment selector. If the stack segment descriptor DPL is not equal to the RPL of the return code segment selector. If the stack segment is not a writable data segment. If the stack segment selector RPL is not equal to the RPL of the return code segment selector. If the segment descriptor for a code segment does not indicate it is a code segment. If the segment selector for a TSS has its local/global bit set for local. If a TSS segment descriptor specifies that the TSS is busy or not available.
\par #SS(0) If the top bytes of stack are not within stack limits.
\par #NP(selector) If the return code or stack segment is not present.
\par #PF(fault-code) If a page fault occurs.
\par #AC(0) If an unaligned memory reference occurs when the CPL is 3 and alignment checking is enabled.
\par 
\par Real-Address Mode Exceptions
\par 
\par #GP If the return instruction pointer is not within the return code segment limit.
\par #SS If the top bytes of stack are not within stack limits.
\par 
\par Virtual-8086 Mode Exceptions
\par 
\par #GP(0) If the return instruction pointer is not within the return code segment limit. IF IOPL not equal to 3
\par #PF(fault-code) If a page fault occurs.
\par #SS(0) If the top bytes of stack are not within stack limits.
\par #AC(0) If an unaligned memory reference occurs and alignment checking is enabled.
{\page}

${\footnote IRET,Opcode}
K{\footnote IRET,IRET;IRETD,IRETD;IRET,Opcode;IRETD,Opcode}
#{\footnote IRET::5}
#{\footnote IRETD::5}

{\fs20\b IRET/IRETD}\tab{\b Opcode}\par\par
CF IRET Interrupt return (16-bit operand size)
\par CF IRETD Interrupt return (32-bit operand size)
{\page}

${\footnote JA,Description}
K{\footnote JA,JA;JAE,JAE;JB,JB;JBE,JBE;JC,JC;JCXZ,JCXZ;JECXZ,JECXZ;JE,JE;JG,JG;JGE,JGE;JL,JL;JLE,JLE;JNA,JNA;JNAE,JNAE;JNB,JNB;JNBE,JNBE;JNC,JNC;JNE,JNE;JNG,JNG;JNGE,JNGE;JNL,JNL;JNLE,JNLE;JNO,JNO;JNP,JNP;JNS,JNS;JNZ,JNZ;JO,JO;JP,JP;JPE,JPE;JPO,JPO;JS,JS;JZ,JZ;JA,Description;JAE,Description;JB,Description;JBE,Description;JC,Description;JCXZ,Description;JECXZ,Description;JE,Description;JG,Description;JGE,Description;JL,Description;JLE,Description;JNA,Description;JNAE,Description;JNB,Description;JNBE,Description;JNC,Description;JNE,Description;JNG,Description;JNGE,Description;JNL,Description;JNLE,Description;JNO,Description;JNP,Description;JNS,Description;JNZ,Description;JO,Description;JP,Description;JPE,Description;JPO,Description;JS,Description;JZ,Description}
#{\footnote JA::1}
#{\footnote JAE::1}
#{\footnote JB::1}
#{\footnote JBE::1}
#{\footnote JC::1}
#{\footnote JCXZ::1}
#{\footnote JECXZ::1}
#{\footnote JE::1}
#{\footnote JG::1}
#{\footnote JGE::1}
#{\footnote JL::1}
#{\footnote JLE::1}
#{\footnote JNA::1}
#{\footnote JNAE::1}
#{\footnote JNB::1}
#{\footnote JNBE::1}
#{\footnote JNC::1}
#{\footnote JNE::1}
#{\footnote JNG::1}
#{\footnote JNGE::1}
#{\footnote JNL::1}
#{\footnote JNLE::1}
#{\footnote JNO::1}
#{\footnote JNP::1}
#{\footnote JNS::1}
#{\footnote JNZ::1}
#{\footnote JO::1}
#{\footnote JP::1}
#{\footnote JPE::1}
#{\footnote JPO::1}
#{\footnote JS::1}
#{\footnote JZ::1}

{\fs20\b JA/JAE/JB/JBE/JC/JCXZ/JECXZ/JE/JG/JGE/JL/JLE/JNA/JNAE/JNB/JNBE/JNC/JNE/JNG/JNGE/JNL/JNLE/JNO/JNP/JNS/JNZ/JO/JP/JPE/JPO/JS/JZ}\tab{\b Description}\par\par
J cc: Jump if Condition Is Met
\par 
\par Checks the state of one or more of the status flags in the EFLAGS register (CF, OF, PF, SF, and ZF) and, if the flags are in the specified state (condition), performs a jump to the target instruction specified by the destination operand. A condition code (cc) is associated with each instruction to indicate the condition being tested for. If the condition is not satisfied, the jump is not performed and execution continues with the instruction following the Jcc instruction.
\par The target instruction is specified with a relative offset (a signed offset relative to the current value of the instruction pointer in the EIP register). A relative offset (rel8, rel16, or rel32) is generally specified as a label in assembly code, but at the machine code level, it is encoded as a signed, 8-bit or 32-bit immediate value, which is added to the instruction pointer. Instruction coding is most efficient for offsets of -128 to +127. If the operand-size attribute is 16, the upper two bytes of the EIP register are cleared to 0s, resulting in a maximum instruction pointer size of 16 bits.
\par The conditions for each Jcc mnemonic are given in the "Description" column of the table on the preceding page. The terms "less" and "greater" are used for comparisons of signed integers and the terms "above" and "below" are used for unsigned integers.
\par Because a particular state of the status flags can sometimes be interpreted in two ways, two mnemonics are defined for some opcodes. For example, the JA (jump if above) instruction and the JNBE (jump if not below or equal) instruction are alternate mnemonics for the opcode 77H. The Jcc instruction does not support far jumps (jumps to other code segments). When the target for the conditional jump is in a different segment, use the opposite condition from the condition being tested for the Jcc instruction, and then access the target with an unconditional far jump (JMP instruction) to the other segment. For example, the following conditional far jump is illegal:
\par 
\par JZ FARLABEL;
\par 
\par To accomplish this far jump, use the following two instructions:
\par 
\par JNZ BEYOND;
\par JMP FARLABEL;
\par BEYOND:
\par 
\par The JECXZ and JCXZ instructions differs from the other Jcc instructions because they do not check the status flags. Instead they check the contents of the ECX and CX registers, respectively, for 0. Either the CX or ECX register is chosen according to the address-size attribute. These instructions are useful at the beginning of a conditional loop that terminates with a conditional loop instruction (such as LOOPNE). They prevent entering the loop when the ECX or CX register is equal to 0, which would cause the loop to execute 2 32 or 64K times, respectively, instead of zero times. All conditional jumps are converted to code fetches of one or two cache lines, regardless of jump address or cacheability.
{\page}

${\footnote JA,Operation}
K{\footnote JA,JA;JAE,JAE;JB,JB;JBE,JBE;JC,JC;JCXZ,JCXZ;JECXZ,JECXZ;JE,JE;JG,JG;JGE,JGE;JL,JL;JLE,JLE;JNA,JNA;JNAE,JNAE;JNB,JNB;JNBE,JNBE;JNC,JNC;JNE,JNE;JNG,JNG;JNGE,JNGE;JNL,JNL;JNLE,JNLE;JNO,JNO;JNP,JNP;JNS,JNS;JNZ,JNZ;JO,JO;JP,JP;JPE,JPE;JPO,JPO;JS,JS;JZ,JZ;JA,Operation;JAE,Operation;JB,Operation;JBE,Operation;JC,Operation;JCXZ,Operation;JECXZ,Operation;JE,Operation;JG,Operation;JGE,Operation;JL,Operation;JLE,Operation;JNA,Operation;JNAE,Operation;JNB,Operation;JNBE,Operation;JNC,Operation;JNE,Operation;JNG,Operation;JNGE,Operation;JNL,Operation;JNLE,Operation;JNO,Operation;JNP,Operation;JNS,Operation;JNZ,Operation;JO,Operation;JP,Operation;JPE,Operation;JPO,Operation;JS,Operation;JZ,Operation}
#{\footnote JA::2}
#{\footnote JAE::2}
#{\footnote JB::2}
#{\footnote JBE::2}
#{\footnote JC::2}
#{\footnote JCXZ::2}
#{\footnote JECXZ::2}
#{\footnote JE::2}
#{\footnote JG::2}
#{\footnote JGE::2}
#{\footnote JL::2}
#{\footnote JLE::2}
#{\footnote JNA::2}
#{\footnote JNAE::2}
#{\footnote JNB::2}
#{\footnote JNBE::2}
#{\footnote JNC::2}
#{\footnote JNE::2}
#{\footnote JNG::2}
#{\footnote JNGE::2}
#{\footnote JNL::2}
#{\footnote JNLE::2}
#{\footnote JNO::2}
#{\footnote JNP::2}
#{\footnote JNS::2}
#{\footnote JNZ::2}
#{\footnote JO::2}
#{\footnote JP::2}
#{\footnote JPE::2}
#{\footnote JPO::2}
#{\footnote JS::2}
#{\footnote JZ::2}

{\fs20\b JA/JAE/JB/JBE/JC/JCXZ/JECXZ/JE/JG/JGE/JL/JLE/JNA/JNAE/JNB/JNBE/JNC/JNE/JNG/JNGE/JNL/JNLE/JNO/JNP/JNS/JNZ/JO/JP/JPE/JPO/JS/JZ}\tab{\b Operation}\par\par
IF condition
\par THEN
\par EIP <- EIP + SignExtend(DEST);
\par IF OperandSize = 16
\par THEN
\par EIP <- EIP AND 0000FFFFH;
\par FI;
\par FI;
{\page}

${\footnote JA,Flags affected}
K{\footnote JA,JA;JAE,JAE;JB,JB;JBE,JBE;JC,JC;JCXZ,JCXZ;JECXZ,JECXZ;JE,JE;JG,JG;JGE,JGE;JL,JL;JLE,JLE;JNA,JNA;JNAE,JNAE;JNB,JNB;JNBE,JNBE;JNC,JNC;JNE,JNE;JNG,JNG;JNGE,JNGE;JNL,JNL;JNLE,JNLE;JNO,JNO;JNP,JNP;JNS,JNS;JNZ,JNZ;JO,JO;JP,JP;JPE,JPE;JPO,JPO;JS,JS;JZ,JZ;JA,Flags affected;JAE,Flags affected;JB,Flags affected;JBE,Flags affected;JC,Flags affected;JCXZ,Flags affected;JECXZ,Flags affected;JE,Flags affected;JG,Flags affected;JGE,Flags affected;JL,Flags affected;JLE,Flags affected;JNA,Flags affected;JNAE,Flags affected;JNB,Flags affected;JNBE,Flags affected;JNC,Flags affected;JNE,Flags affected;JNG,Flags affected;JNGE,Flags affected;JNL,Flags affected;JNLE,Flags affected;JNO,Flags affected;JNP,Flags affected;JNS,Flags affected;JNZ,Flags affected;JO,Flags affected;JP,Flags affected;JPE,Flags affected;JPO,Flags affected;JS,Flags affected;JZ,Flags affected}
#{\footnote JA::3}
#{\footnote JAE::3}
#{\footnote JB::3}
#{\footnote JBE::3}
#{\footnote JC::3}
#{\footnote JCXZ::3}
#{\footnote JECXZ::3}
#{\footnote JE::3}
#{\footnote JG::3}
#{\footnote JGE::3}
#{\footnote JL::3}
#{\footnote JLE::3}
#{\footnote JNA::3}
#{\footnote JNAE::3}
#{\footnote JNB::3}
#{\footnote JNBE::3}
#{\footnote JNC::3}
#{\footnote JNE::3}
#{\footnote JNG::3}
#{\footnote JNGE::3}
#{\footnote JNL::3}
#{\footnote JNLE::3}
#{\footnote JNO::3}
#{\footnote JNP::3}
#{\footnote JNS::3}
#{\footnote JNZ::3}
#{\footnote JO::3}
#{\footnote JP::3}
#{\footnote JPE::3}
#{\footnote JPO::3}
#{\footnote JS::3}
#{\footnote JZ::3}

{\fs20\b JA/JAE/JB/JBE/JC/JCXZ/JECXZ/JE/JG/JGE/JL/JLE/JNA/JNAE/JNB/JNBE/JNC/JNE/JNG/JNGE/JNL/JNLE/JNO/JNP/JNS/JNZ/JO/JP/JPE/JPO/JS/JZ}\tab{\b Flags affected}\par\par
None.
{\page}

${\footnote JA,Exceptions}
K{\footnote JA,JA;JAE,JAE;JB,JB;JBE,JBE;JC,JC;JCXZ,JCXZ;JECXZ,JECXZ;JE,JE;JG,JG;JGE,JGE;JL,JL;JLE,JLE;JNA,JNA;JNAE,JNAE;JNB,JNB;JNBE,JNBE;JNC,JNC;JNE,JNE;JNG,JNG;JNGE,JNGE;JNL,JNL;JNLE,JNLE;JNO,JNO;JNP,JNP;JNS,JNS;JNZ,JNZ;JO,JO;JP,JP;JPE,JPE;JPO,JPO;JS,JS;JZ,JZ;JA,Exceptions;JAE,Exceptions;JB,Exceptions;JBE,Exceptions;JC,Exceptions;JCXZ,Exceptions;JECXZ,Exceptions;JE,Exceptions;JG,Exceptions;JGE,Exceptions;JL,Exceptions;JLE,Exceptions;JNA,Exceptions;JNAE,Exceptions;JNB,Exceptions;JNBE,Exceptions;JNC,Exceptions;JNE,Exceptions;JNG,Exceptions;JNGE,Exceptions;JNL,Exceptions;JNLE,Exceptions;JNO,Exceptions;JNP,Exceptions;JNS,Exceptions;JNZ,Exceptions;JO,Exceptions;JP,Exceptions;JPE,Exceptions;JPO,Exceptions;JS,Exceptions;JZ,Exceptions}
#{\footnote JA::4}
#{\footnote JAE::4}
#{\footnote JB::4}
#{\footnote JBE::4}
#{\footnote JC::4}
#{\footnote JCXZ::4}
#{\footnote JECXZ::4}
#{\footnote JE::4}
#{\footnote JG::4}
#{\footnote JGE::4}
#{\footnote JL::4}
#{\footnote JLE::4}
#{\footnote JNA::4}
#{\footnote JNAE::4}
#{\footnote JNB::4}
#{\footnote JNBE::4}
#{\footnote JNC::4}
#{\footnote JNE::4}
#{\footnote JNG::4}
#{\footnote JNGE::4}
#{\footnote JNL::4}
#{\footnote JNLE::4}
#{\footnote JNO::4}
#{\footnote JNP::4}
#{\footnote JNS::4}
#{\footnote JNZ::4}
#{\footnote JO::4}
#{\footnote JP::4}
#{\footnote JPE::4}
#{\footnote JPO::4}
#{\footnote JS::4}
#{\footnote JZ::4}

{\fs20\b JA/JAE/JB/JBE/JC/JCXZ/JECXZ/JE/JG/JGE/JL/JLE/JNA/JNAE/JNB/JNBE/JNC/JNE/JNG/JNGE/JNL/JNLE/JNO/JNP/JNS/JNZ/JO/JP/JPE/JPO/JS/JZ}\tab{\b Exceptions}\par\par
Protected Mode Exceptions
\par 
\par #GP(0) If the offset being jumped to is beyond the limits of the CS segment.
\par 
\par Real-Address Mode Exceptions
\par 
\par #GP If the offset being jumped to is beyond the limits of the CS segment or is outside of the effective address space from 0 to FFFFH. This condition can occur if 32-address size override prefix is used.
\par 
\par Virtual-8086 Mode Exceptions
\par 
\par #GP(0) If the offset being jumped to is beyond the limits of the CS segment or is outside of the effective address space from 0 to FFFFH. This condition can occur if 32-address size override prefix is used.
{\page}

${\footnote JA,Opcode}
K{\footnote JA,JA;JAE,JAE;JB,JB;JBE,JBE;JC,JC;JCXZ,JCXZ;JECXZ,JECXZ;JE,JE;JG,JG;JGE,JGE;JL,JL;JLE,JLE;JNA,JNA;JNAE,JNAE;JNB,JNB;JNBE,JNBE;JNC,JNC;JNE,JNE;JNG,JNG;JNGE,JNGE;JNL,JNL;JNLE,JNLE;JNO,JNO;JNP,JNP;JNS,JNS;JNZ,JNZ;JO,JO;JP,JP;JPE,JPE;JPO,JPO;JS,JS;JZ,JZ;JA,Opcode;JAE,Opcode;JB,Opcode;JBE,Opcode;JC,Opcode;JCXZ,Opcode;JECXZ,Opcode;JE,Opcode;JG,Opcode;JGE,Opcode;JL,Opcode;JLE,Opcode;JNA,Opcode;JNAE,Opcode;JNB,Opcode;JNBE,Opcode;JNC,Opcode;JNE,Opcode;JNG,Opcode;JNGE,Opcode;JNL,Opcode;JNLE,Opcode;JNO,Opcode;JNP,Opcode;JNS,Opcode;JNZ,Opcode;JO,Opcode;JP,Opcode;JPE,Opcode;JPO,Opcode;JS,Opcode;JZ,Opcode}
#{\footnote JA::5}
#{\footnote JAE::5}
#{\footnote JB::5}
#{\footnote JBE::5}
#{\footnote JC::5}
#{\footnote JCXZ::5}
#{\footnote JECXZ::5}
#{\footnote JE::5}
#{\footnote JG::5}
#{\footnote JGE::5}
#{\footnote JL::5}
#{\footnote JLE::5}
#{\footnote JNA::5}
#{\footnote JNAE::5}
#{\footnote JNB::5}
#{\footnote JNBE::5}
#{\footnote JNC::5}
#{\footnote JNE::5}
#{\footnote JNG::5}
#{\footnote JNGE::5}
#{\footnote JNL::5}
#{\footnote JNLE::5}
#{\footnote JNO::5}
#{\footnote JNP::5}
#{\footnote JNS::5}
#{\footnote JNZ::5}
#{\footnote JO::5}
#{\footnote JP::5}
#{\footnote JPE::5}
#{\footnote JPO::5}
#{\footnote JS::5}
#{\footnote JZ::5}

{\fs20\b JA/JAE/JB/JBE/JC/JCXZ/JECXZ/JE/JG/JGE/JL/JLE/JNA/JNAE/JNB/JNBE/JNC/JNE/JNG/JNGE/JNL/JNLE/JNO/JNP/JNS/JNZ/JO/JP/JPE/JPO/JS/JZ}\tab{\b Opcode}\par\par
77 cb JA rel8 Jump short if above (CF=0 and ZF=0)
\par 73 cb JAE rel8 Jump short if above or equal (CF=0)
\par 72 cb JB rel8 Jump short if below (CF=1)
\par 76 cb JBE rel8 Jump short if below or equal (CF=1 or ZF=1)
\par 72 cb JC rel8 Jump short if carry (CF=1)
\par E3 cb JCXZ rel8 Jump short if CX register is 0
\par E3 cb JECXZ rel8 Jump short if ECX register is 0
\par 74 cb JE rel8 Jump short if equal (ZF=1)
\par 7F cb JG rel8 Jump short if greater (ZF=0 and SF=OF)
\par 7D cb JGE rel8 Jump short if greater or equal (SF=OF)
\par 7C cb JL rel8 Jump short if less (SF<>OF)
\par 7E cb JLE rel8 Jump short if less or equal (ZF=1 or SF<>OF)
\par 76 cb JNA rel8 Jump short if not above (CF=1 or ZF=1)
\par 72 cb JNAE rel8 Jump short if not above or equal (CF=1)
\par 73 cb JNB rel8 Jump short if not below (CF=0)
\par 77 cb JNBE rel8 Jump short if not below or equal (CF=0 and ZF=0)
\par 73 cb JNC rel8 Jump short if not carry (CF=0)
\par 75 cb JNE rel8 Jump short if not equal (ZF=0)
\par 7E cb JNG rel8 Jump short if not greater (ZF=1 or SF<>OF)
\par 7C cb JNGE rel8 Jump short if not greater or equal (SF<>OF)
\par 7D cb JNL rel8 Jump short if not less (SF=OF)
\par 7F cb JNLE rel8 Jump short if not less or equal (ZF=0 and SF=OF)
\par 71 cb JNO rel8 Jump short if not overflow (OF=0)
\par 7B cb JNP rel8 Jump short if not parity (PF=0)
\par 79 cb JNS rel8 Jump short if not sign (SF=0)
\par 75 cb JNZ rel8 Jump short if not zero (ZF=0)
\par 70 cb JO rel8 Jump short if overflow (OF=1)
\par 7A cb JP rel8 Jump short if parity (PF=1)
\par 7A cb JPE rel8 Jump short if parity even (PF=1)
\par 7B cb JPO rel8 Jump short if parity odd (PF=0)
\par 78 cb JS rel8 Jump short if sign (SF=1)
\par 74 cb JZ rel8 Jump short if zero (ZF = 1)
\par 0F 87 cw/cd JA rel16/32 Jump near if above (CF=0 and ZF=0)
\par 0F 83 cw/cd JAE rel16/32 Jump near if above or equal (CF=0)
\par 0F 82 cw/cd JB rel16/32 Jump near if below (CF=1)
\par 0F 86 cw/cd JBE rel16/32 Jump near if below or equal (CF=1 or ZF=1)
\par 0F 82 cw/cd JC rel16/32 Jump near if carry (CF=1)
\par 0F 84 cw/cd JE rel16/32 Jump near if equal (ZF=1)
\par 0F 84 cw/cd JZ rel16/32 Jump near if 0 (ZF=1)
\par 0F 8F cw/cd JG rel16/32 Jump near if greater (ZF=0 and SF=OF)
\par 0F 8D cw/cd JGE rel16/32 Jump near if greater or equal (SF=OF)
\par 0F 8C cw/cd JL rel16/32 Jump near if less (SF<>OF)
\par 0F 8E cw/cd JLE rel16/32 Jump near if less or equal (ZF=1 or SF<>OF)
\par 0F 86 cw/cd JNA rel16/32 Jump near if not above (CF=1 or ZF=1)
\par 0F 82 cw/cd JNAE rel16/32 Jump near if not above or equal (CF=1)
\par 0F 83 cw/cd JNB rel16/32 Jump near if not below (CF=0)
\par 0F 87 cw/cd JNBE rel16/32 Jump near if not below or equal (CF=0 and ZF=0)
\par 0F 83 cw/cd JNC rel16/32 Jump near if not carry (CF=0)
\par 0F 85 cw/cd JNE rel16/32 Jump near if not equal (ZF=0)
\par 0F 8E cw/cd JNG rel16/32 Jump near if not greater (ZF=1 or SF<>OF)
\par 0F 8C cw/cd JNGE rel16/32 Jump near if not greater or equal (SF<>OF)
\par 0F 8D cw/cd JNL rel16/32 Jump near if not less (SF=OF)
\par 0F 8F cw/cd JNLE rel16/32 Jump near if not less or equal (ZF=0 and SF=OF)
\par 0F 81 cw/cd JNO rel16/32 Jump near if not overflow (OF=0)
\par 0F 8B cw/cd JNP rel16/32 Jump near if not parity (PF=0)
\par 0F 89 cw/cd JNS rel16/32 Jump near if not sign (SF=0)
\par 0F 85 cw/cd JNZ rel16/32 Jump near if not zero (ZF=0)
\par 0F 80 cw/cd JO rel16/32 Jump near if overflow (OF=1)
\par 0F 8A cw/cd JP rel16/32 Jump near if parity (PF=1)
\par 0F 8A cw/cd JPE rel16/32 Jump near if parity even (PF=1)
\par 0F 8B cw/cd JPO rel16/32 Jump near if parity odd (PF=0)
\par 0F 88 cw/cd JS rel16/32 Jump near if sign (SF=1)
\par 0F 84 cw/cd JZ rel16/32 Jump near if 0 (ZF=1)
{\page}

${\footnote JMP,Description}
K{\footnote JMP,JMP;JMP,Description}
#{\footnote JMP::1}

{\fs20\b JMP}\tab{\b Description}\par\par
JMP: Jump
\par 
\par Transfers program control to a different point in the instruction stream without recording return information. The destination (target) operand specifies the address of the instruction being jumped to. This operand can be an immediate value, a general-purpose register, or a memory location.
\par This instruction can be used to execute four different types of jumps:
\par 
\par - Near jump--A jump to an instruction within the current code segment (the segment currently pointed to by the CS register), sometimes referred to as an intrasegment jump.
\par - Short jump--A near jump where the jump range is limited to -128 to +127 from the current EIP value.
\par - Far jump--A jump to an instruction located in a different segment than the current code segment but at the same privilege level, sometimes referred to as an intersegment jump.
\par - Task switch--A jump to an instruction located in a different task.
\par 
\par NOTE: A task switch can only be executed in protected mode.
\par 
\par Near and Short Jumps.
\par 
\par When executing a near jump, the processor jumps to the address (within the current code segment) that is specified with the target operand. The target operand specifies either an absolute offset (that is an offset from the base of the code segment) or a relative offset (a signed displacement relative to the current value of the instruction pointer in the EIP register). A near jump to a relative offset of 8-bits (rel8) is referred to as a short jump. The CS register is not changed on near and short jumps.
\par An absolute offset is specified indirectly in a general-purpose register or a memory location (r/m16 or r/m32). The operand-size attribute determines the size of the target operand (16 or 32 bits). Absolute offsets are loaded directly into the EIP register. If the operand-size attribute is 16, the upper two bytes of the EIP register are cleared to 0s, resulting in a maximum instruction pointer size of 16 bits.
\par A relative offset (rel8, rel16, or rel32) is generally specified as a label in assembly code, but at the machine code level, it is encoded as a signed 8-, 16-, or 32-bit immediate value. This value is added to the value in the EIP register. (Here, the EIP register contains the address of the instruction following the JMP instruction). When using relative offsets, the opcode (for short vs. near jumps) and the operand-size attribute (for near relative jumps) determines the size of the target operand (8, 16, or 32 bits).
\par 
\par Far Jumps in Real-Address or Virtual-8086 Mode.
\par 
\par When executing a far jump in real-address or virtual-8086 mode, the processor jumps to the code segment and offset specified with the target operand. Here the target operand specifies an absolute far address either directly with a pointer (ptr16:16 or ptr16:32) or indirectly with a memory location (m16:16 or m16:32). With the pointer method, the segment and address of the called procedure is encoded in the instruction, using a 4-byte (16-bit operand size) or 6-byte (32-bit operand size) far address immediate.
\par With the indirect method, the target operand specifies a memory location that contains a 4-byte (16-bit operand size) or 6-byte (32-bit operand size) far address. The far address is loaded directly into the CS and EIP registers. If the operand-size attribute is 16, the upper two bytes of the EIP register are cleared to 0s.
\par 
\par Far Jumps in Protected Mode.
\par 
\par When the processor is operating in protected mode, the JMP instruction can be used to perform the following three types of far jumps:
\par 
\par - A far jump to a conforming or non-conforming code segment.
\par - A far jump through a call gate.
\par - A task switch.
\par (The JMP instruction cannot be used to perform interprivilege level far jumps.)
\par 
\par In protected mode, the processor always uses the segment selector part of the far address to access the corresponding descriptor in the GDT or LDT. The descriptor type (code segment, call gate, task gate, or TSS) and access rights determine the type of jump to be performed. If the selected descriptor is for a code segment, a far jump to a code segment at the same privilege level is performed. (If the selected code segment is at a different privilege level and the code segment is non-conforming, a general-protection exception is generated.) A far jump to the same privilege level in protected mode is very similar to one carried out in real-address or virtual-8086 mode. The target operand specifies an absolute far address either directly with a pointer (ptr16:16 or ptr16:32) or indirectly with a memory location (m16:16 or m16:32). The operand-size attribute determines the size of the offset (16 or 32 bits) in the far address. The new code segment selector and its descriptor are loaded into CS register, and the offset from the instruction is loaded into the EIP register. Note that a call gate (described in the next paragraph) can also be used to perform far call to a code segment at the same privilege level. Using this mechanism provides an extra level of indirection and is the preferred method of making jumps between 16-bit and 32-bit code segments.
\par When executing a far jump through a call gate, the segment selector specified by the target operand identifies the call gate. (The offset part of the target operand is ignored.) The processor then jumps to the code segment specified in the call gate descriptor and begins executing the instruction at the offset specified in the call gate. No stack switch occurs. Here again, the target operand can specify the far address of the call gate either directly with a pointer (ptr16:16 or ptr16:32) or indirectly with a memory location (m16:16 or m16:32). Executing a task switch with the JMP instruction, is somewhat similar to executing a jump through a call gate. Here the target operand specifies the segment selector of the task gate for the task being switched to (and the offset part of the target operand is ignored). The task gate in turn points to the TSS for the task, which contains the segment selectors for the task's code and stack segments. The TSS also contains the EIP value for the next instruction that was to be executed before the task was suspended. This instruction pointer value is loaded into EIP register so that the task begins executing again at this next instruction.
\par The JMP instruction can also specify the segment selector of the TSS directly, which eliminates the indirection of the task gate. Note that when you execute at task switch with a JMP instruction, the nested task flag (NT) is not set in the EFLAGS register and the new TSS's previous task link field is not loaded with the old task's TSS selector. A return to the previous task can thus not be carried out by executing the IRET instruction. Switching tasks with the JMP instruction differs in this regard from the CALL instruction which does set the NT flag and save the previous task link information, allowing a return to the calling task with an IRET instruction.
{\page}

${\footnote JMP,Operation}
K{\footnote JMP,JMP;JMP,Operation}
#{\footnote JMP::2}

{\fs20\b JMP}\tab{\b Operation}\par\par
IF near jump
\par THEN IF near relative jump
\par THEN
\par tempEIP <- EIP + DEST; (* EIP is instruction following JMP instruction*)
\par ELSE (* near absolute jump *)
\par tempEIP <- DEST;
\par FI;
\par IF tempEIP is beyond code segment limit THEN #GP(0); FI;
\par IF OperandSize = 32
\par THEN
\par EIP <- tempEIP;
\par ELSE (* OperandSize=16 *)
\par EIP <- tempEIP AND 0000FFFFH;
\par FI;
\par FI:
\par IF far jump AND (PE = 0 OR (PE = 1 AND VM = 1)) (* real-address or virtual-8086 mode *)
\par THEN
\par tempEIP <- DEST(offset); (* DEST is ptr16:32 or [ m16:32] *)
\par IF tempEIP is beyond code segment limit THEN #GP(0); FI;
\par CS <- DEST(segment selector); (* DEST is ptr16:32 or [ m16:32] *)
\par IF OperandSize = 32
\par THEN
\par EIP <- tempEIP; (* DEST is ptr16:32 or [ m16:32] *)
\par ELSE (* OperandSize = 16 *)
\par EIP <- tempEIP AND 0000FFFFH; (* clear upper 16 bits *)
\par FI;
\par FI;
\par IF far jump AND (PE = 1 AND VM = 0) (* Protected mode, not virtual-8086 mode *)
\par THEN
\par IF effective address in the CS, DS, ES, FS, GS, or SS segment is illegal
\par OR segment selector in target operand null
\par THEN #GP(0);
\par FI;
\par IF segment selector index not within descriptor table limits
\par THEN #GP(new selector);
\par FI;
\par Read type and access rights of segment descriptor;
\par IF segment type is not a conforming or nonconforming code segment, call gate, task gate, or TSS THEN #GP(segment selector);
\par FI;
\par Depending on type and access rights
\par GO TO CONFORMING-CODE-SEGMENT;
\par GO TO NONCONFORMING-CODE-SEGMENT;
\par GO TO CALL-GATE;
\par GO TO TASK-GATE;
\par GO TO TASK-STATE-SEGMENT;
\par ELSE
\par #GP(segment selector);
\par FI;
\par 
\par CONFORMING-CODE-SEGMENT:
\par IF DPL > CPL THEN #GP(segment selector); FI;
\par IF segment not present THEN #NP(segment selector); FI;
\par tempEIP <- DEST(offset);
\par IF OperandSize=16
\par THEN tempEIP <- tempEIP AND 0000FFFFH;
\par FI;
\par IF tempEIP not in code segment limit THEN #GP(0); FI;
\par CS <- DEST(SegmentSelector); (* segment descriptor information also loaded *)
\par CS(RPL) <- CPL
\par EIP <- tempEIP;
\par END;
\par 
\par NONCONFORMING-CODE-SEGMENT:
\par IF (RPL > CPL) OR (DPL != CPL) THEN #GP(code segment selector); FI;
\par IF segment not present THEN #NP(segment selector); FI;
\par IF instruction pointer outside code segment limit THEN #GP(0); FI;
\par tempEIP <- DEST(offset);
\par IF OperandSize=16
\par THEN tempEIP <- tempEIP AND 0000FFFFH;
\par FI;
\par IF tempEIP not in code segment limit THEN #GP(0); FI;
\par CS <- DEST(SegmentSelector); (* segment descriptor information also loaded *)
\par CS(RPL) <- CPL
\par EIP <- tempEIP;
\par END;
\par 
\par CALL-GATE:
\par IF call gate DPL < CPL
\par OR call gate DPL < call gate segment-selector RPL
\par THEN #GP(call gate selector); FI;
\par IF call gate not present THEN #NP(call gate selector); FI;
\par IF call gate code-segment selector is null THEN #GP(0); FI;
\par IF call gate code-segment selector index is outside descriptor table limits THEN #GP(code segment selector); FI;
\par Read code segment descriptor;
\par IF code-segment segment descriptor does not indicate a code segment
\par OR code-segment segment descriptor is conforming and DPL > CPL
\par OR code-segment segment descriptor is non-conforming and DPL != CPL
\par THEN #GP(code segment selector); FI;
\par IF code segment is not present THEN #NP(code-segment selector); FI;
\par IF instruction pointer is not within code-segment limit THEN #GP(0); FI;
\par tempEIP <- DEST(offset);
\par IF GateSize=16
\par THEN tempEIP <- tempEIP AND 0000FFFFH;
\par FI;
\par IF tempEIP not in code segment limit THEN #GP(0); FI;
\par CS <- DEST(SegmentSelector); (* segment descriptor information also loaded *)
\par CS(RPL) <- CPL
\par EIP <- tempEIP;
\par END;
\par 
\par TASK-GATE:
\par IF task gate DPL < CPL
\par OR task gate DPL < task gate segment-selector RPL
\par THEN #GP(task gate selector); FI;
\par IF task gate not present THEN #NP(gate selector); FI;
\par Read the TSS segment selector in the task-gate descriptor;
\par IF TSS segment selector local/global bit is set to local
\par OR index not within GDT limits
\par OR TSS descriptor specifies that the TSS is busy
\par THEN #GP(TSS selector); FI;
\par IF TSS not present THEN #NP(TSS selector); FI;
\par SWITCH-TASKS to TSS;
\par IF EIP not within code segment limit THEN #GP(0); FI;
\par END;
\par 
\par TASK-STATE-SEGMENT:
\par IF TSS DPL < CPL
\par OR TSS DPL < TSS segment-selector RPL
\par OR TSS descriptor indicates TSS not available
\par THEN #GP(TSS selector); FI;
\par IF TSS is not present THEN #NP(TSS selector); FI;
\par SWITCH-TASKS to TSS
\par IF EIP not within code segment limit THEN #GP(0); FI;
\par END;
{\page}

${\footnote JMP,Flags affected}
K{\footnote JMP,JMP;JMP,Flags affected}
#{\footnote JMP::3}

{\fs20\b JMP}\tab{\b Flags affected}\par\par
All flags are affected if a task switch occurs; no flags are affected if a task switch does not occur.
{\page}

${\footnote JMP,Exceptions}
K{\footnote JMP,JMP;JMP,Exceptions}
#{\footnote JMP::4}

{\fs20\b JMP}\tab{\b Exceptions}\par\par
Protected Mode Exceptions
\par 
\par #GP(0) If offset in target operand, call gate, or TSS is beyond the code segment limits. If the segment selector in the destination operand, call gate, task gate, or TSS is null. If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit. If the DS, ES, FS, or GS register is used to access memory and it contains a null segment selector.
\par #GP(selector) If segment selector index is outside descriptor table limits. If the segment descriptor pointed to by the segment selector in the destination operand is not for a conforming-code segment, nonconforming-code segment, call gate, task gate, or task state segment. If the DPL for a nonconforming-code segment is not equal to the CPL (When not using a call gate.) If the RPL for the segment's segment selector is greater than the CPL. If the DPL for a conforming-code segment is greater than the CPL. If the DPL from a call-gate, task-gate, or TSS segment descriptor is less than the CPL or than the RPL of the call-gate, task-gate, or TSS's segment selector. If the segment descriptor for selector in a call gate does not indicate it is a code segment. If the segment descriptor for the segment selector in a task gate does not indicate available TSS. If the segment selector for a TSS has its local/global bit set for local. If a TSS segment descriptor specifies that the TSS is busy or not available.
\par #SS(0) If a memory operand effective address is outside the SS segment limit.
\par #NP (selector) If the code segment being accessed is not present. If call gate, task gate, or TSS not present.
\par #PF(fault-code) If a page fault occurs.
\par #AC(0) If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3. (Only occurs when fetching target from memory.)
\par 
\par Real-Address Mode Exceptions
\par 
\par #GP If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit. If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.
\par #SS If a memory operand effective address is outside the SS segment limit.
\par 
\par Virtual-8086 Mode Exceptions
\par 
\par #GP(0) If the target operand is beyond the code segment limits. If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.
\par #SS(0) If a memory operand effective address is outside the SS segment limit.
\par #PF(fault-code) If a page fault occurs.
\par #AC(0) If alignment checking is enabled and an unaligned memory reference is made. (Only occurs when fetching target from memory.)
{\page}

${\footnote JMP,Opcode}
K{\footnote JMP,JMP;JMP,Opcode}
#{\footnote JMP::5}

{\fs20\b JMP}\tab{\b Opcode}\par\par
EB cb JMP rel8 Jump short, relative, displacement relative to next instruction
\par E9 cw JMP rel16 Jump near, relative, displacement relative to next instruction
\par E9 cd JMP rel32 Jump near, relative, displacement relative to next instruction
\par FF /4 JMP r/m16 Jump near, absolute indirect, address given in r/m16
\par FF /4 JMP r/m32 Jump near, absolute indirect, address given in r/m32
\par EA cd JMP ptr16:16 Jump far, absolute, address given in operand
\par EA cp JMP ptr16:32 Jump far, absolute, address given in operand
\par FF /5 JMP m16:16 Jump far, absolute indirect, address given in m16:16
\par FF /5 JMP m16:32 Jump far, absolute indirect, address given in m16:32
{\page}

${\footnote LAHF,Description}
K{\footnote LAHF,LAHF;LAHF,Description}
#{\footnote LAHF::1}

{\fs20\b LAHF}\tab{\b Description}\par\par
LAHF: Load Status Flags into AH Register
\par 
\par Moves the low byte of the EFLAGS register (which includes status flags SF, ZF, AF, PF, and CF) to the AH register. Reserved bits 1, 3, and 5 of the EFLAGS register are set in the AH register as shown in the "Operation" section.
{\page}

${\footnote LAHF,Operation}
K{\footnote LAHF,LAHF;LAHF,Operation}
#{\footnote LAHF::2}

{\fs20\b LAHF}\tab{\b Operation}\par\par
AH <- EFLAGS(SF:ZF:0:AF:0:PF:1:CF);
{\page}

${\footnote LAHF,Flags affected}
K{\footnote LAHF,LAHF;LAHF,Flags affected}
#{\footnote LAHF::3}

{\fs20\b LAHF}\tab{\b Flags affected}\par\par
None (that is, the state of the flags in the EFLAGS register are not affected).
{\page}

${\footnote LAHF,Exceptions}
K{\footnote LAHF,LAHF;LAHF,Exceptions}
#{\footnote LAHF::4}

{\fs20\b LAHF}\tab{\b Exceptions}\par\par
(All Operating Modes)
\par None.
{\page}

${\footnote LAHF,Opcode}
K{\footnote LAHF,LAHF;LAHF,Opcode}
#{\footnote LAHF::5}

{\fs20\b LAHF}\tab{\b Opcode}\par\par
9F LAHF Load: AH = EFLAGS(SF:ZF:0:AF:0:PF:1:CF)
{\page}

${\footnote LAR,Description}
K{\footnote LAR,LAR;LAR,Description}
#{\footnote LAR::1}

{\fs20\b LAR}\tab{\b Description}\par\par
LAR: Load Access Rights Byte
\par 
\par Loads the access rights from the segment descriptor specified by the second operand (source operand) into the first operand (destination operand) and sets the ZF flag in the EFLAGS register. The source operand (which can be a register or a memory location) contains the segment selector for the segment descriptor being accessed. The destination operand is a general-purpose register.
\par The processor performs access checks as part of the loading process. Once loaded in the destination register, software can perform additional checks on the access rights information. When the operand size is 32 bits, the access rights for a segment descriptor include the type and DPL fields and the S, P, AVL, D/B, and G flags, all of which are located in the second double-word (bytes 4 through 7) of the segment descriptor. The doubleword is masked by 00FXFF00H before it is loaded into the destination operand. When the operand size is 16 bits, the access rights include the type and DPL fields. Here, the two lower-order bytes of the doubleword are masked by FF00H before being loaded into the destination operand.
\par This instruction performs the following checks before it loads the access rights in the destination register:
\par 
\par - Checks that the segment selector is not null.
\par - Checks that the segment selector points to a descriptor that is within the limits of the GDT or LDT being accessed
\par - Checks that the descriptor type is valid for this instruction. All code and data segment descriptors are valid for (can be accessed with) the LAR instruction. The valid system segment and gate descriptor types are given in the following table.
\par - If the segment is not a conforming code segment, it checks that the specified segment descriptor is visible at the CPL (that is, if the CPL and the RPL of the segment selector are less than or equal to the DPL of the segment selector).
\par 
\par If the segment descriptor cannot be accessed or is an invalid type for the instruction, the ZF flag is cleared and no access rights are loaded in the destination operand. The LAR instruction can only be executed in protected mode.
{\page}

${\footnote LAR,Operation}
K{\footnote LAR,LAR;LAR,Operation}
#{\footnote LAR::2}

{\fs20\b LAR}\tab{\b Operation}\par\par
IF SRC(Offset) > descriptor table limit THEN ZF <- 0; FI;
\par Read segment descriptor;
\par IF SegmentDescriptor(Type) != conforming code segment
\par AND (CPL > DPL) OR (RPL > DPL)
\par OR Segment type is not valid for instruction
\par THEN
\par ZF <- 0
\par ELSE
\par IF OperandSize = 32
\par THEN
\par DEST <- [SRC] AND 00FxFF00H;
\par ELSE (*OperandSize = 16*)
\par DEST <- [SRC] AND FF00H;
\par FI;
\par FI;
{\page}

${\footnote LAR,Flags affected}
K{\footnote LAR,LAR;LAR,Flags affected}
#{\footnote LAR::3}

{\fs20\b LAR}\tab{\b Flags affected}\par\par
The ZF flag is set to 1 if the access rights are loaded successfully; otherwise, it is cleared to 0.
{\page}

${\footnote LAR,Exceptions}
K{\footnote LAR,LAR;LAR,Exceptions}
#{\footnote LAR::4}

{\fs20\b LAR}\tab{\b Exceptions}\par\par
Protected Mode Exceptions
\par 
\par #GP(0) If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit. If the DS, ES, FS, or GS register is used to access memory and it contains a null segment selector.
\par #SS(0) If a memory operand effective address is outside the SS segment limit.
\par #PF(fault-code) If a page fault occurs.
\par #AC(0) If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3. (Only occurs when fetching target from memory.)
\par 
\par Real-Address Mode Exceptions
\par 
\par #UD The LAR instruction is not recognized in real-address mode.
\par 
\par Virtual-8086 Mode Exceptions
\par 
\par #UD The LAR instruction cannot be executed in virtual-8086 mode.
{\page}

${\footnote LAR,Opcode}
K{\footnote LAR,LAR;LAR,Opcode}
#{\footnote LAR::5}

{\fs20\b LAR}\tab{\b Opcode}\par\par
0F 02 / r LAR r16,r/m16 r16 <- r/m16 masked by FF00H
\par 0F 02 / r LAR r32,r/m32 r32 <- r/m32 masked by 00FxFF00H
{\page}

${\footnote LDS,Description}
K{\footnote LDS,LDS;LES,LES;LFS,LFS;LGS,LGS;LSS,LSS;LDS,Description;LES,Description;LFS,Description;LGS,Description;LSS,Description}
#{\footnote LDS::1}
#{\footnote LES::1}
#{\footnote LFS::1}
#{\footnote LGS::1}
#{\footnote LSS::1}

{\fs20\b LDS/LES/LFS/LGS/LSS}\tab{\b Description}\par\par
LDS/LES/LFS/LGS/LSS: Load Far Pointer
\par 
\par Loads a far pointer (segment selector and offset) from the second operand (source operand) into a segment register and the first operand (destination operand). The source operand specifies a 48-bit or a 32-bit pointer in memory depending on the current setting of the operand-size attribute (32 bits or 16 bits, respectively). The instruction opcode and the destination operand specify a segment register/general-purpose register pair. The 16-bit segment selector from the source operand is loaded into the segment register specified with the opcode (DS, SS, ES, FS, or GS). The 32-bit or 16-bit offset is loaded into the register specified with the destination operand.
\par If one of these instructions is executed in protected mode, additional information from the segment descriptor pointed to by the segment selector in the source operand is loaded in the hidden part of the selected segment register.
\par Also in protected mode, a null selector (values 0000 through 0003) can be loaded into DS, ES, FS, or GS registers without causing a protection exception. (Any subsequent reference to a segment whose corresponding segment register is loaded with a null selector, causes a general-protection exception (#GP) and no memory reference to the segment occurs.)
{\page}

${\footnote LDS,Operation}
K{\footnote LDS,LDS;LES,LES;LFS,LFS;LGS,LGS;LSS,LSS;LDS,Operation;LES,Operation;LFS,Operation;LGS,Operation;LSS,Operation}
#{\footnote LDS::2}
#{\footnote LES::2}
#{\footnote LFS::2}
#{\footnote LGS::2}
#{\footnote LSS::2}

{\fs20\b LDS/LES/LFS/LGS/LSS}\tab{\b Operation}\par\par
IF ProtectedMode
\par THEN IF SS is loaded
\par THEN IF SegementSelector = null
\par THEN #GP(0);
\par FI;
\par ELSE IF Segment selector index is not within descriptor table limits
\par OR Segment selector RPL != CPL
\par OR Access rights indicate nonwritable data segment
\par OR DPL != CPL
\par THEN #GP(selector);
\par FI;
\par ELSE IF Segment marked not present
\par THEN #SS(selector);
\par FI;
\par SS <- SegmentSelector(SRC);
\par SS <- SegmentDescriptor([SRC]);
\par ELSE IF DS, ES, FS, or GS is loaded with non-null segment selector
\par THEN IF Segment selector index is not within descriptor table limits
\par OR Access rights indicate segment neither data nor readable code segment
\par OR (Segment is data or nonconforming-code segment
\par AND both RPL and CPL > DPL)
\par THEN #GP(selector);
\par FI;
\par ELSE IF Segment marked not present
\par THEN #NP(selector);
\par FI;
\par SegmentRegister <- SegmentSelector(SRC) AND RPL;
\par SegmentRegister <- SegmentDescriptor([SRC]);
\par ELSE IF DS, ES, FS or GS is loaded with a null selector:
\par SegmentRegister <- NullSelector;
\par SegmentRegister(DescriptorValidBit) <- 0; (*hidden flag; not accessible by software*)
\par FI;
\par FI;
\par IF (Real-Address or Virtual-8086 Mode)
\par THEN
\par SegmentRegister <- SegmentSelector(SRC);
\par FI;
\par DEST <- Offset(SRC);
{\page}

${\footnote LDS,Flags affected}
K{\footnote LDS,LDS;LES,LES;LFS,LFS;LGS,LGS;LSS,LSS;LDS,Flags affected;LES,Flags affected;LFS,Flags affected;LGS,Flags affected;LSS,Flags affected}
#{\footnote LDS::3}
#{\footnote LES::3}
#{\footnote LFS::3}
#{\footnote LGS::3}
#{\footnote LSS::3}

{\fs20\b LDS/LES/LFS/LGS/LSS}\tab{\b Flags affected}\par\par
None.
{\page}

${\footnote LDS,Exceptions}
K{\footnote LDS,LDS;LES,LES;LFS,LFS;LGS,LGS;LSS,LSS;LDS,Exceptions;LES,Exceptions;LFS,Exceptions;LGS,Exceptions;LSS,Exceptions}
#{\footnote LDS::4}
#{\footnote LES::4}
#{\footnote LFS::4}
#{\footnote LGS::4}
#{\footnote LSS::4}

{\fs20\b LDS/LES/LFS/LGS/LSS}\tab{\b Exceptions}\par\par
Protected Mode Exceptions
\par 
\par #UD If source operand is not a memory location.
\par #GP(0) If a null selector is loaded into the SS register. If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit. If the DS, ES, FS, or GS register is used to access memory and it contains a null segment selector.
\par #GP(selector) If the SS register is being loaded and any of the following is true: the segment selector index is not within the descriptor table limits, the segment selector RPL is not equal to CPL, the segment is a nonwritable data segment, or DPL is not equal to CPL. If the DS, ES, FS, or GS register is being loaded with a non-null segment selector and any of the following is true: the segment selector index is not within descriptor table limits, the segment is neither a data nor a readable code segment, or the segment is a data or nonconforming-code segment and both RPL and CPL are greater than DPL.
\par #SS(0) If a memory operand effective address is outside the SS segment limit.
\par #SS(selector) If the SS register is being loaded and the segment is marked not present.
\par #NP(selector) If DS, ES, FS, or GS register is being loaded with a non-null segment selector and the segment is marked not present.
\par #PF(fault-code) If a page fault occurs.
\par #AC(0) If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.
\par 
\par Real-Address Mode Exceptions
\par 
\par #GP If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.
\par #SS If a memory operand effective address is outside the SS segment limit.
\par #UD If source operand is not a memory location.
\par 
\par Virtual-8086 Mode Exceptions
\par 
\par #UD If source operand is not a memory location.
\par #GP(0) If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.
\par #SS(0) If a memory operand effective address is outside the SS segment limit.
\par #PF(fault-code) If a page fault occurs.
\par #AC(0) If alignment checking is enabled and an unaligned memory reference is made.
{\page}

${\footnote LDS,Opcode}
K{\footnote LDS,LDS;LES,LES;LFS,LFS;LGS,LGS;LSS,LSS;LDS,Opcode;LES,Opcode;LFS,Opcode;LGS,Opcode;LSS,Opcode}
#{\footnote LDS::5}
#{\footnote LES::5}
#{\footnote LFS::5}
#{\footnote LGS::5}
#{\footnote LSS::5}

{\fs20\b LDS/LES/LFS/LGS/LSS}\tab{\b Opcode}\par\par
C5 / r LDS r16,m16:16 Load DS: r16 with far pointer from memory
\par C5 / r LDS r32,m16:32 Load DS: r32 with far pointer from memory
\par 0F B2 / r LSS r16,m16:16 Load SS: r16 with far pointer from memory
\par 0F B2 / r LSS r32,m16:32 Load SS: r32 with far pointer from memory
\par C4 / r LES r16,m16:16 Load ES: r16 with far pointer from memory
\par C4 / r LES r32,m16:32 Load ES: r32 with far pointer from memory
\par 0F B4 / r LFS r16,m16:16 Load FS: r16 with far pointer from memory
\par 0F B4 / r LFS r32,m16:32 Load FS: r32 with far pointer from memory
\par 0F B5 / r LGS r16,m16:16 Load GS: r16 with far pointer from memory
\par 0F B5 / r LGS r32,m16:32 Load GS: r32 with far pointer from memory
{\page}

${\footnote LEA,Description}
K{\footnote LEA,LEA;LEA,Description}
#{\footnote LEA::1}

{\fs20\b LEA}\tab{\b Description}\par\par
LEA: Load Effective Address
\par 
\par Computes the effective address of the second operand (the source operand) and stores it in the first operand (destination operand). The source operand is a memory address (offset part) specified with one of the processors addressing modes; the destination operand is a general-purpose register. The address-size and operand-size attributes affect the action performed by this instruction, as shown in the following table. The operand-size attribute of the instruction is determined by the chosen register; the address-size attribute is determined by the attribute of the code segment.
\par Different assemblers may use different algorithms based on the size attribute and symbolic reference of the source operand.
\par 
\par Operand Size Address Size Action Performed
\par       16          16          16-bit effective address is calculated and stored in requested 16-bit register destination.
\par       16          32          32-bit effective address is calculated. The lower 16 bits of the address are stored in the requested 16-bit register destination.
\par       32          16          16-bit effective address is calculated. The 16-bit address is zero-extended and stored in the requested 32-bit register destination.
\par       32          32          32-bit effective address is calculated and stored in the requested 32-bit register destination.
{\page}

${\footnote LEA,Operation}
K{\footnote LEA,LEA;LEA,Operation}
#{\footnote LEA::2}

{\fs20\b LEA}\tab{\b Operation}\par\par
IF OperandSize = 16 AND AddressSize = 16
\par THEN
\par DEST <- EffectiveAddress(SRC); (* 16-bit address *)
\par ELSE IF OperandSize = 16 AND AddressSize = 32
\par THEN
\par temp <- EffectiveAddress(SRC); (* 32-bit address *)
\par DEST <- temp[0..15]; (* 16-bit address *)
\par ELSE IF OperandSize = 32 AND AddressSize = 16
\par THEN
\par temp <- EffectiveAddress(SRC); (* 16-bit address *)
\par DEST <- ZeroExtend(temp); (* 32-bit address *)
\par ELSE IF OperandSize = 32 AND AddressSize = 32
\par THEN
\par DEST <- EffectiveAddress(SRC); (* 32-bit address *)
\par FI;
\par FI;
{\page}

${\footnote LEA,Flags affected}
K{\footnote LEA,LEA;LEA,Flags affected}
#{\footnote LEA::3}

{\fs20\b LEA}\tab{\b Flags affected}\par\par
None.
{\page}

${\footnote LEA,Exceptions}
K{\footnote LEA,LEA;LEA,Exceptions}
#{\footnote LEA::4}

{\fs20\b LEA}\tab{\b Exceptions}\par\par
Protected Mode Exceptions
\par 
\par #UD If source operand is not a memory location.
\par 
\par Real-Address Mode Exceptions
\par 
\par #UD If source operand is not a memory location.
\par 
\par Virtual-8086 Mode Exceptions
\par 
\par #UD If source operand is not a memory location.
{\page}

${\footnote LEA,Opcode}
K{\footnote LEA,LEA;LEA,Opcode}
#{\footnote LEA::5}

{\fs20\b LEA}\tab{\b Opcode}\par\par
8D / r LEA r16,m Store effective address for m in register r16
\par 8D / r LEA r32,m Store effective address for m in register r32
{\page}

${\footnote LEAVE,Description}
K{\footnote LEAVE,LEAVE;LEAVE,Description}
#{\footnote LEAVE::1}

{\fs20\b LEAVE}\tab{\b Description}\par\par
LEAVE: High Level Procedure Exit
\par 
\par Releases the stack frame set up by an earlier ENTER instruction. The LEAVE instruction copies the frame pointer (in the EBP register) into the stack pointer register (ESP), which releases the stack space allocated to the stack frame. The old frame pointer (the frame pointer for the calling procedure that was saved by the ENTER instruction) is then popped from the stack into the EBP register, restoring the calling procedure's stack frame.
\par A RET instruction is commonly executed following a LEAVE instruction to return program control to the calling procedure.
{\page}

${\footnote LEAVE,Operation}
K{\footnote LEAVE,LEAVE;LEAVE,Operation}
#{\footnote LEAVE::2}

{\fs20\b LEAVE}\tab{\b Operation}\par\par
IF StackAddressSize = 32
\par THEN
\par ESP <- EBP;
\par ELSE (* StackAddressSize = 16*)
\par SP <- BP;
\par FI;
\par IF OperandSize = 32
\par THEN
\par EBP <- Pop();
\par ELSE (* OperandSize = 16*)
\par BP <- Pop();
\par FI;
{\page}

${\footnote LEAVE,Flags affected}
K{\footnote LEAVE,LEAVE;LEAVE,Flags affected}
#{\footnote LEAVE::3}

{\fs20\b LEAVE}\tab{\b Flags affected}\par\par
None.
{\page}

${\footnote LEAVE,Exceptions}
K{\footnote LEAVE,LEAVE;LEAVE,Exceptions}
#{\footnote LEAVE::4}

{\fs20\b LEAVE}\tab{\b Exceptions}\par\par
Protected Mode Exceptions
\par 
\par #SS(0) If the EBP register points to a location that is not within the limits of the current stack segment.
\par #PF(fault-code) If a page fault occurs.
\par #AC(0) If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.
\par 
\par Real-Address Mode Exceptions
\par 
\par #GP If the EBP register points to a location outside of the effective address space from 0 to 0FFFFH.
\par 
\par Virtual-8086 Mode Exceptions
\par 
\par #GP(0) If the EBP register points to a location outside of the effective address space from 0 to 0FFFFH.
\par #PF(fault-code) If a page fault occurs.
\par #AC(0) If alignment checking is enabled and an unaligned memory reference is made.
{\page}

${\footnote LEAVE,Opcode}
K{\footnote LEAVE,LEAVE;LEAVE,Opcode}
#{\footnote LEAVE::5}

{\fs20\b LEAVE}\tab{\b Opcode}\par\par
C9 LEAVE Set SP to BP, then pop BP
\par C9 LEAVE Set ESP to EBP, then pop EBP
{\page}

${\footnote LGDT,Description}
K{\footnote LGDT,LGDT;LIDT,LIDT;LGDT,Description;LIDT,Description}
#{\footnote LGDT::1}
#{\footnote LIDT::1}

{\fs20\b LGDT/LIDT}\tab{\b Description}\par\par
LGDT/LIDT: Load Global/Interrupt Descriptor Table Register
\par 
\par Loads the values in the source operand into the global descriptor table register (GDTR) or the interrupt descriptor table register (IDTR). The source operand specifies a 6-byte memory location that contains the base address (a linear address) and the limit (size of table in bytes) of the global descriptor table (GDT) or the interrupt descriptor table (IDT). If operand-size attribute is 32 bits, a 16-bit limit (lower 2 bytes of the 6-byte data operand) and a 32-bit base address (upper 4 bytes of the data operand) are loaded into the register. If the operand-size attribute is 16 bits, a 16-bit limit (lower 2 bytes) and a 24-bit base address (third, fourth, and fifth byte) are loaded. Here, the high-order byte of the operand is not used and the high-order byte of the base address in the GDTR or IDTR is filled with zeros.
\par The LGDT and LIDT instructions are used only in operating-system software; they are not used in application programs. They are the only instructions that directly load a linear address (that is, not a segment-relative address) and a limit in protected mode. They are commonly executed in real-address mode to allow processor initialization prior to switching to protected mode.
{\page}

${\footnote LGDT,Operation}
K{\footnote LGDT,LGDT;LIDT,LIDT;LGDT,Operation;LIDT,Operation}
#{\footnote LGDT::2}
#{\footnote LIDT::2}

{\fs20\b LGDT/LIDT}\tab{\b Operation}\par\par
IF instruction is LIDT
\par THEN
\par IF OperandSize = 16
\par THEN
\par IDTR(Limit) <- SRC[0:15];
\par IDTR(Base) <- SRC[16:47] AND 00FFFFFFH;
\par ELSE (* 32-bit Operand Size *)
\par IDTR(Limit) <- SRC[0:15];
\par IDTR(Base) <- SRC[16:47];
\par FI;
\par ELSE (* instruction is LGDT *)
\par IF OperandSize = 16
\par THEN
\par GDTR(Limit) <- SRC[0:15];
\par GDTR(Base) <- SRC[16:47] AND 00FFFFFFH;
\par ELSE (* 32-bit Operand Size *)
\par GDTR(Limit) <- SRC[0:15];
\par GDTR(Base) <- SRC[16:47];
\par FI; FI;
{\page}

${\footnote LGDT,Flags affected}
K{\footnote LGDT,LGDT;LIDT,LIDT;LGDT,Flags affected;LIDT,Flags affected}
#{\footnote LGDT::3}
#{\footnote LIDT::3}

{\fs20\b LGDT/LIDT}\tab{\b Flags affected}\par\par
None.
{\page}

${\footnote LGDT,Exceptions}
K{\footnote LGDT,LGDT;LIDT,LIDT;LGDT,Exceptions;LIDT,Exceptions}
#{\footnote LGDT::4}
#{\footnote LIDT::4}

{\fs20\b LGDT/LIDT}\tab{\b Exceptions}\par\par
Protected Mode Exceptions
\par 
\par #UD If source operand is not a memory location.
\par #GP(0) If the current privilege level is not 0. If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit. If the DS, ES, FS, or GS register is used to access memory and it contains a null segment selector.
\par #SS(0) If a memory operand effective address is outside the SS segment limit.
\par #PF(fault-code) If a page fault occurs.
\par 
\par Real-Address Mode Exceptions
\par 
\par #UD If source operand is not a memory location.
\par #GP If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.
\par #SS If a memory operand effective address is outside the SS segment limit.
\par 
\par Virtual-8086 Mode Exceptions
\par 
\par #GP(0) If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.
{\page}

${\footnote LGDT,Opcode}
K{\footnote LGDT,LGDT;LIDT,LIDT;LGDT,Opcode;LIDT,Opcode}
#{\footnote LGDT::5}
#{\footnote LIDT::5}

{\fs20\b LGDT/LIDT}\tab{\b Opcode}\par\par
0F 01 /2 LGDT m16&32 Load m into GDTR
\par 0F 01 /3 LIDT m16&32 Load m into IDTR
{\page}

${\footnote LLDT,Description}
K{\footnote LLDT,LLDT;LLDT,Description}
#{\footnote LLDT::1}

{\fs20\b LLDT}\tab{\b Description}\par\par
LLDT: Load Local Descriptor Table Register
\par 
\par Loads the source operand into the segment selector field of the local descriptor table register (LDTR). The source operand (a general-purpose register or a memory location) contains a segment selector that points to a local descriptor table (LDT). After the segment selector is loaded in the LDTR, the processor uses to segment selector to locate the segment descriptor for the LDT in the global descriptor table (GDT). It then loads the segment limit and base address for the LDT from the segment descriptor into the LDTR. The segment registers DS, ES, SS, FS, GS, and CS are not affected by this instruction, nor is the LDTR field in the task state segment (TSS) for the current task.
\par If the source operand is 0, the LDTR is marked invalid and all references to descriptors in the LDT (except by the LAR, VERR, VERW or LSL instructions) cause a general protection exception (#GP). The operand-size attribute has no effect on this instruction. The LLDT instruction is provided for use in operating-system software; it should not be used in application programs. Also, this instruction can only be executed in protected mode.
{\page}

${\footnote LLDT,Operation}
K{\footnote LLDT,LLDT;LLDT,Operation}
#{\footnote LLDT::2}

{\fs20\b LLDT}\tab{\b Operation}\par\par
IF SRC(Offset) > descriptor table limit THEN #GP(segment selector); FI;
\par Read segment descriptor;
\par IF SegmentDescriptor(Type) != LDT THEN #GP(segment selector); FI;
\par IF segment descriptor is not present THEN #NP(segment selector);
\par LDTR(SegmentSelector) <- SRC;
\par LDTR(SegmentDescriptor) <- GDTSegmentDescriptor;
{\page}

${\footnote LLDT,Flags affected}
K{\footnote LLDT,LLDT;LLDT,Flags affected}
#{\footnote LLDT::3}

{\fs20\b LLDT}\tab{\b Flags affected}\par\par
None.
{\page}

${\footnote LLDT,Exceptions}
K{\footnote LLDT,LLDT;LLDT,Exceptions}
#{\footnote LLDT::4}

{\fs20\b LLDT}\tab{\b Exceptions}\par\par
Protected Mode Exceptions
\par 
\par #GP(0) If the current privilege level is not 0. If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit. If the DS, ES, FS, or GS register contains a null segment selector.
\par #GP(selector) If the selector operand does not point into the Global Descriptor Table or if the entry in the GDT is not a Local Descriptor Table. Segment selector is beyond GDT limit.
\par #SS(0) If a memory operand effective address is outside the SS segment limit.
\par #NP(selector) If the LDT descriptor is not present.
\par #PF(fault-code) If a page fault occurs.
\par 
\par Real-Address Mode Exceptions
\par 
\par #UD The LLDT instruction is not recognized in real-address mode.
\par 
\par Virtual-8086 Mode Exceptions
\par 
\par #UD The LLDT instruction is recognized in virtual-8086 mode.
{\page}

${\footnote LLDT,Opcode}
K{\footnote LLDT,LLDT;LLDT,Opcode}
#{\footnote LLDT::5}

{\fs20\b LLDT}\tab{\b Opcode}\par\par
0F 00 /2 LLDT r/m16 Load segment selector r/m16 into LDTR
{\page}

${\footnote LMSW,Description}
K{\footnote LMSW,LMSW;LMSW,Description}
#{\footnote LMSW::1}

{\fs20\b LMSW}\tab{\b Description}\par\par
LMSW: Load Machine Status Word
\par 
\par Loads the source operand into the machine status word, bits 0 through 15 of register CR0. The source operand can be a 16-bit general-purpose register or a memory location. Only the low-order 4 bits of the source operand (which contains the PE, MP, EM, and TS flags) are loaded into CR0. The PG, CD, NW, AM, WP, NE, and ET flags of CR0 are not affected. The operand-size attribute has no effect on this instruction.
\par If the PE flag of the source operand (bit 0) is set to 1, the instruction causes the processor to switch to protected mode. While in protected mode, the LMSW instruction cannot be used clear the PE flag and force a switch back to real-address mode.
\par The LMSW instruction is provided for use in operating-system software; it should not be used in application programs. In protected or virtual-8086 mode, it can only be executed at CPL 0. This instruction is provided for compatibility with the Intel 286 processor; programs and procedures intended to run on the Pentium Pro, Pentium, Intel486, and Intel386 processors should use the MOV (control registers) instruction to load the whole CR0 register. The MOV CR0 instruction can be used to set and clear the PE flag in CR0, allowing a procedure or program to switch between protected and real-address modes. This instruction is a serializing instruction.
{\page}

${\footnote LMSW,Operation}
K{\footnote LMSW,LMSW;LMSW,Operation}
#{\footnote LMSW::2}

{\fs20\b LMSW}\tab{\b Operation}\par\par
CR0[0:3] <- SRC[0:3];
{\page}

${\footnote LMSW,Flags affected}
K{\footnote LMSW,LMSW;LMSW,Flags affected}
#{\footnote LMSW::3}

{\fs20\b LMSW}\tab{\b Flags affected}\par\par
None.
{\page}

${\footnote LMSW,Exceptions}
K{\footnote LMSW,LMSW;LMSW,Exceptions}
#{\footnote LMSW::4}

{\fs20\b LMSW}\tab{\b Exceptions}\par\par
Protected Mode Exceptions
\par #GP(0) If the current privilege level is not 0. If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit. If the DS, ES, FS, or GS register is used to access memory and it contains a null segment selector.
\par #SS(0) If a memory operand effective address is outside the SS segment limit.
\par #PF(fault-code) If a page fault occurs.
\par 
\par Real-Address Mode Exceptions
\par 
\par #GP If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.
\par 
\par Virtual-8086 Mode Exceptions
\par 
\par #GP(0) If the current privilege level is not 0. If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.
\par #SS(0) If a memory operand effective address is outside the SS segment limit.
\par #PF(fault-code) If a page fault occurs.
{\page}

${\footnote LMSW,Opcode}
K{\footnote LMSW,LMSW;LMSW,Opcode}
#{\footnote LMSW::5}

{\fs20\b LMSW}\tab{\b Opcode}\par\par
0F 01 /6 LMSW r/m16 Loads r/m16 in machine status word of CR0
{\page}

${\footnote LOCK,Description}
K{\footnote LOCK,LOCK;LOCK,Description}
#{\footnote LOCK::1}

{\fs20\b LOCK}\tab{\b Description}\par\par
LOCK: Assert LOCK# Signal Prefix
\par 
\par Causes the processor's LOCK# signal to be asserted during execution of the accompanying instruction (turns the instruction into an atomic instruction). In a multiprocessor environment, the LOCK# signal insures that the processor has exclusive use of any shared memory while the signal is asserted.
\par Note that in later Intel Architecture processors (such as the Pentium Pro processor), locking may occur without the LOCK# signal being asserted. See Intel Architecture Compatibility below. The LOCK prefix can be prepended only to the following instructions and to those forms of the instructions that use a memory operand: ADD, ADC, AND, BTC, BTR, BTS, CMPXCHG, DEC, INC, NEG, NOT, OR, SBB, SUB, XOR, XADD, and XCHG. An undefined opcode exception will be generated if the LOCK prefix is used with any other instruction. The XCHG instruction always asserts the LOCK# signal regardless of the presence or absence of the LOCK prefix.
\par The LOCK prefix is typically used with the BTS instruction to perform a read-modify-write operation on a memory location in shared memory environment. The integrity of the LOCK prefix is not affected by the alignment of the memory field. Memory locking is observed for arbitrarily misaligned fields.
\par 
\par Intel Architecture Compatibility
\par 
\par Beginning with the Pentium Pro processor, when the LOCK prefix is prefixed to an instruction and the memory area being accessed is cached internally in the processor, the LOCK# signal is generally not asserted. Instead, only the processor's cache is locked. Here, the processor's cache coherency mechanism insures that the operation is carried out atomically with regards to memory.
{\page}

${\footnote LOCK,Operation}
K{\footnote LOCK,LOCK;LOCK,Operation}
#{\footnote LOCK::2}

{\fs20\b LOCK}\tab{\b Operation}\par\par
AssertLOCK#(DurationOfAccompaningInstruction)
{\page}

${\footnote LOCK,Flags affected}
K{\footnote LOCK,LOCK;LOCK,Flags affected}
#{\footnote LOCK::3}

{\fs20\b LOCK}\tab{\b Flags affected}\par\par
None.
{\page}

${\footnote LOCK,Exceptions}
K{\footnote LOCK,LOCK;LOCK,Exceptions}
#{\footnote LOCK::4}

{\fs20\b LOCK}\tab{\b Exceptions}\par\par
Protected Mode Exceptions
\par 
\par #UD If the LOCK prefix is used with an instruction not listed in the "Description" section. Other exceptions can be generated by the instruction that the LOCK prefix is being applied to.
\par 
\par Real-Address Mode Exceptions
\par 
\par #UD If the LOCK prefix is used with an instruction not listed in the "Description" section. Other exceptions can be generated by the instruction that the LOCK prefix is being applied to.
\par 
\par Virtual-8086 Mode Exceptions
\par 
\par #UD If the LOCK prefix is used with an instruction not listed in the "Description" section. Other exceptions can be generated by the instruction that the LOCK prefix is being applied to.
{\page}

${\footnote LOCK,Opcode}
K{\footnote LOCK,LOCK;LOCK,Opcode}
#{\footnote LOCK::5}

{\fs20\b LOCK}\tab{\b Opcode}\par\par
F0 LOCK Asserts LOCK# signal for duration of the accompanying instruction
{\page}

${\footnote LODS,Description}
K{\footnote LODS,LODS;LODSB,LODSB;LODSD,LODSD;LODSW,LODSW;LODS,Description;LODSB,Description;LODSD,Description;LODSW,Description}
#{\footnote LODS::1}
#{\footnote LODSB::1}
#{\footnote LODSD::1}
#{\footnote LODSW::1}

{\fs20\b LODS/LODSB/LODSD/LODSW}\tab{\b Description}\par\par
LODS/LODSB/LODSW/LODSD: Load String
\par 
\par Loads a byte, word, or doubleword from the source operand into the AL, AX, or EAX register, respectively. The source operand is a memory location, the address of which is read from the DS:EDI or the DS:SI registers (depending on the address-size attribute of the instruction, 32 or 16, respectively). The DS segment may be overridden with a segment override prefix. At the assembly-code level, two forms of this instruction are allowed: the "explicit-operands" form and the "no-operands" form. The explicit-operands form (specified with the LODS mnemonic) allows the source operand to be specified explicitly. Here, the source operand should be a symbol that indicates the size and location of the source value. The destination operand is then automatically selected to match the size of the source operand (the AL register for byte operands, AX for word operands, and EAX for doubleword operands). This explicit-operands form is provided to allow documentation; however, note that the documentation provided by this form can be misleading. That is, the source operand symbol must specify the correct type (size) of the operand (byte, word, or doubleword), but it does not have to specify the correct location.
\par The location is always specified by the DS:(E)SI registers, which must be loaded correctly before the load string instruction is executed. The no-operands form provides "short forms" of the byte, word, and doubleword versions of the LODS instructions. Here also DS:(E)SI is assumed to be the source operand and the AL, AX, or EAX register is assumed to be the destination operand. The size of the source and destination operands is selected with the mnemonic: LODSB (byte loaded into register AL), LODSW (word loaded into AX), or LODSD (doubleword loaded into EAX). After the byte, word, or doubleword is transferred from the memory location into the AL, AX, or EAX register, the (E)SI register is incremented or decremented automatically according to the setting of the DF flag in the EFLAGS register. (If the DF flag is 0, the (E)SI register is incremented; if the DF flag is 1, the ESI register is decremented.) The (E)SI register is incremented or decremented by 1 for byte operations, by 2 for word operations, or by 4 for doubleword operations.
\par The LODS, LODSB, LODSW, and LODSD instructions can be preceded by the REP prefix for block loads of ECX bytes, words, or doublewords. More often, however, these instructions are used within a LOOP construct because further processing of the data moved into the register is usually necessary before the next transfer can be made.
{\page}

${\footnote LODS,Operation}
K{\footnote LODS,LODS;LODSB,LODSB;LODSD,LODSD;LODSW,LODSW;LODS,Operation;LODSB,Operation;LODSD,Operation;LODSW,Operation}
#{\footnote LODS::2}
#{\footnote LODSB::2}
#{\footnote LODSD::2}
#{\footnote LODSW::2}

{\fs20\b LODS/LODSB/LODSD/LODSW}\tab{\b Operation}\par\par
IF (byte load)"
\par THEN
\par AL <- SRC; (* byte load *)
\par THEN IF DF = 0
\par THEN (E)SI <- (E)SI + 1;
\par ELSE (E)SI <- (E)SI - 1;
\par FI;
\par ELSE IF (word load)
\par THEN
\par AX <- SRC; (* word load *)
\par THEN IF DF = 0
\par THEN (E)SI <- (E)SI + 2;
\par ELSE (E)SI <- (E)SI - 2;
\par FI;
\par ELSE (* doubleword transfer *)
\par EAX <- SRC; (* doubleword load *)
\par THEN IF DF = 0
\par THEN (E)SI <- (E)SI + 4;
\par ELSE (E)SI <- (E)SI - 4;
\par FI;
\par FI;
\par FI;
{\page}

${\footnote LODS,Flags affected}
K{\footnote LODS,LODS;LODSB,LODSB;LODSD,LODSD;LODSW,LODSW;LODS,Flags affected;LODSB,Flags affected;LODSD,Flags affected;LODSW,Flags affected}
#{\footnote LODS::3}
#{\footnote LODSB::3}
#{\footnote LODSD::3}
#{\footnote LODSW::3}

{\fs20\b LODS/LODSB/LODSD/LODSW}\tab{\b Flags affected}\par\par
None.
{\page}

${\footnote LODS,Exceptions}
K{\footnote LODS,LODS;LODSB,LODSB;LODSD,LODSD;LODSW,LODSW;LODS,Exceptions;LODSB,Exceptions;LODSD,Exceptions;LODSW,Exceptions}
#{\footnote LODS::4}
#{\footnote LODSB::4}
#{\footnote LODSD::4}
#{\footnote LODSW::4}

{\fs20\b LODS/LODSB/LODSD/LODSW}\tab{\b Exceptions}\par\par
Protected Mode Exceptions
\par 
\par #GP(0) If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit. If the DS, ES, FS, or GS register contains a null segment selector.
\par #SS(0) If a memory operand effective address is outside the SS segment limit.
\par #PF(fault-code) If a page fault occurs.
\par #AC(0) If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.
\par 
\par Real-Address Mode Exceptions
\par 
\par #GP If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.
\par #SS If a memory operand effective address is outside the SS segment limit.
\par 
\par Virtual-8086 Mode Exceptions
\par 
\par #GP(0) If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.
\par #SS(0) If a memory operand effective address is outside the SS segment limit.
\par #PF(fault-code) If a page fault occurs.
\par #AC(0) If alignment checking is enabled and an unaligned memory reference is made.
{\page}

${\footnote LODS,Opcode}
K{\footnote LODS,LODS;LODSB,LODSB;LODSD,LODSD;LODSW,LODSW;LODS,Opcode;LODSB,Opcode;LODSD,Opcode;LODSW,Opcode}
#{\footnote LODS::5}
#{\footnote LODSB::5}
#{\footnote LODSD::5}
#{\footnote LODSW::5}

{\fs20\b LODS/LODSB/LODSD/LODSW}\tab{\b Opcode}\par\par
AC LODS m8 Load byte at address DS:(E)SI into AL
\par AD LODS m16 Load word at address DS:(E)SI into AX
\par AD LODS m32 Load doubleword at address DS:(E)SI into EAX
\par AC LODSB Load byte at address DS:(E)SI into AL
\par AD LODSW Load word at address DS:(E)SI into AX
\par AD LODSD Load doubleword at address DS:(E)SI into EAX
{\page}

${\footnote LOOP,Description}
K{\footnote LOOP,LOOP;LOOPE,LOOPE;LOOPNE,LOOPNE;LOOPNZ,LOOPNZ;LOOPZ,LOOPZ;LOOP,Description;LOOPE,Description;LOOPNE,Description;LOOPNZ,Description;LOOPZ,Description}
#{\footnote LOOP::1}
#{\footnote LOOPE::1}
#{\footnote LOOPNE::1}
#{\footnote LOOPNZ::1}
#{\footnote LOOPZ::1}

{\fs20\b LOOP/LOOPE/LOOPNE/LOOPNZ/LOOPZ}\tab{\b Description}\par\par
LOOP/LOOP cc: Loop According to ECX Counter
\par 
\par Performs a loop operation using the ECX or CX register as a counter. Each time the LOOP instruction is executed, the count register is decremented, then checked for 0. If the count is 0, the loop is terminated and program execution continues with the instruction following the LOOP instruction. If the count is not zero, a near jump is performed to the destination (target) operand, which is presumably the instruction at the beginning of the loop. If the address-size attribute is 32 bits, the ECX register is used as the count register; otherwise the CX register is used. The target instruction is specified with a relative offset (a signed offset relative to the current value of the instruction pointer in the EIP register). This offset is generally specified as a label in assembly code, but at the machine code level, it is encoded as a signed, 8-bit immediate value, which is added to the instruction pointer. Offsets of -128 to +127 are allowed with this instruction.
\par Some forms of the loop instruction (LOOPcc) also accept the ZF flag as a condition for terminating the loop before the count reaches zero. With these forms of the instruction, a condition code (cc) is associated with each instruction to indicate the condition being tested for. Here, the LOOPcc instruction itself does not affect the state of the ZF flag; the ZF flag is changed by other instructions in the loop.
{\page}

${\footnote LOOP,Operation}
K{\footnote LOOP,LOOP;LOOPE,LOOPE;LOOPNE,LOOPNE;LOOPNZ,LOOPNZ;LOOPZ,LOOPZ;LOOP,Operation;LOOPE,Operation;LOOPNE,Operation;LOOPNZ,Operation;LOOPZ,Operation}
#{\footnote LOOP::2}
#{\footnote LOOPE::2}
#{\footnote LOOPNE::2}
#{\footnote LOOPNZ::2}
#{\footnote LOOPZ::2}

{\fs20\b LOOP/LOOPE/LOOPNE/LOOPNZ/LOOPZ}\tab{\b Operation}\par\par
IF AddressSize = 32
\par THEN
\par Count is ECX;
\par ELSE (* AddressSize = 16 *)
\par Count is CX;
\par FI;
\par Count <- Count - 1;
\par IF instruction is not LOOP
\par THEN
\par IF (instruction = LOOPE) OR (instruction = LOOPZ)
\par THEN
\par IF (ZF =1) AND (Count != 0)
\par THEN BranchCond <- 1;
\par ELSE BranchCond <- 0;
\par FI;
\par FI;
\par IF (instruction = LOOPNE) OR (instruction = LOOPNZ)
\par THEN
\par IF (ZF =0 ) AND (Count != 0)
\par THEN BranchCond <- 1;
\par ELSE BranchCond <- 0;
\par FI;
\par FI;
\par ELSE (* instruction = LOOP *)
\par IF (Count != 0)
\par THEN BranchCond <- 1;
\par ELSE BranchCond <- 0;
\par FI;
\par FI;
\par IF BranchCond = 1
\par THEN
\par EIP <- EIP + SignExtend(DEST);
\par IF OperandSize = 16
\par THEN
\par EIP <- EIP AND 0000FFFFH;
\par FI;
\par ELSE
\par Terminate loop and continue program execution at EIP;
\par FI;
{\page}

${\footnote LOOP,Flags affected}
K{\footnote LOOP,LOOP;LOOPE,LOOPE;LOOPNE,LOOPNE;LOOPNZ,LOOPNZ;LOOPZ,LOOPZ;LOOP,Flags affected;LOOPE,Flags affected;LOOPNE,Flags affected;LOOPNZ,Flags affected;LOOPZ,Flags affected}
#{\footnote LOOP::3}
#{\footnote LOOPE::3}
#{\footnote LOOPNE::3}
#{\footnote LOOPNZ::3}
#{\footnote LOOPZ::3}

{\fs20\b LOOP/LOOPE/LOOPNE/LOOPNZ/LOOPZ}\tab{\b Flags affected}\par\par
None.
{\page}

${\footnote LOOP,Exceptions}
K{\footnote LOOP,LOOP;LOOPE,LOOPE;LOOPNE,LOOPNE;LOOPNZ,LOOPNZ;LOOPZ,LOOPZ;LOOP,Exceptions;LOOPE,Exceptions;LOOPNE,Exceptions;LOOPNZ,Exceptions;LOOPZ,Exceptions}
#{\footnote LOOP::4}
#{\footnote LOOPE::4}
#{\footnote LOOPNE::4}
#{\footnote LOOPNZ::4}
#{\footnote LOOPZ::4}

{\fs20\b LOOP/LOOPE/LOOPNE/LOOPNZ/LOOPZ}\tab{\b Exceptions}\par\par
Protected Mode Exceptions
\par 
\par #GP(0) If the offset jumped to is beyond the limits of the code segment.
\par 
\par Real-Address Mode Exceptions
\par 
\par None.
\par 
\par Virtual-8086 Mode Exceptions
\par 
\par None.
{\page}

${\footnote LOOP,Opcode}
K{\footnote LOOP,LOOP;LOOPE,LOOPE;LOOPNE,LOOPNE;LOOPNZ,LOOPNZ;LOOPZ,LOOPZ;LOOP,Opcode;LOOPE,Opcode;LOOPNE,Opcode;LOOPNZ,Opcode;LOOPZ,Opcode}
#{\footnote LOOP::5}
#{\footnote LOOPE::5}
#{\footnote LOOPNE::5}
#{\footnote LOOPNZ::5}
#{\footnote LOOPZ::5}

{\fs20\b LOOP/LOOPE/LOOPNE/LOOPNZ/LOOPZ}\tab{\b Opcode}\par\par
E2 cb LOOP rel8 Decrement count; jump short if count != 0
\par E1 cb LOOPE rel8 Decrement count; jump short if count != 0 and ZF=1
\par E1 cb LOOPZ rel8 Decrement count; jump short if count != 0 and ZF=1
\par E0 cb LOOPNE rel8 Decrement count; jump short if count != 0 and ZF=0
\par E0 cb LOOPNZ rel8 Decrement count; jump short if count != 0 and ZF=0
{\page}

${\footnote LSL,Description}
K{\footnote LSL,LSL;LSL,Description}
#{\footnote LSL::1}

{\fs20\b LSL}\tab{\b Description}\par\par
LSL: Load Segment Limit
\par 
\par Loads the unscrambled segment limit from the segment descriptor specified with the second operand (source operand) into the first operand (destination operand) and sets the ZF flag in the EFLAGS register. The source operand (which can be a register or a memory location) contains the segment selector for the segment descriptor being accessed. The destination operand is a general-purpose register.
\par The processor performs access checks as part of the loading process. Once loaded in the destination register, software can compare the segment limit with the offset of a pointer.
\par The segment limit is a 20-bit value contained in bytes 0 and 1 and in the first 4 bits of byte of the segment descriptor. If the descriptor has a byte granular segment limit (the granularity flag is set to 0), the destination operand is loaded with a byte granular value (byte limit). If the descriptor has a page granular segment limit (the granularity flag is set to 1), the LSL instruction will translate the page granular limit (page limit) into a byte limit before loading it into the destination operand. The translation is performed by shifting the 20-bit "raw" limit left 12 bits and filling the low-order 12 bits with 1s.
\par When the operand size is 32 bits, the 32-bit byte limit is stored in the destination operand. When the operand size is 16 bits, a valid 32-bit limit is computed; however, the upper 16 bits are truncated and only the low-order 16 bits are loaded into the destination operand. This instruction performs the following checks before it loads the segment limit into the destination register:
\par 
\par - Checks that the segment selector is not null.
\par - Checks that the segment selector points to a descriptor that is within the limits of the GDT or LDT being accessed
\par - Checks that the descriptor type is valid for this instruction. All code and data segment descriptors are valid for (can be accessed with) the LSL instruction. The valid special segment and gate descriptor types are given in the following table.
\par - If the segment is not a conforming code segment, the instruction checks that the specified segment descriptor is visible at the CPL (that is, if the CPL and the RPL of the segment selector are less than or equal to the DPL of the segment selector).
\par 
\par If the segment descriptor cannot be accessed or is an invalid type for the instruction, the ZF flag is cleared and no value is loaded in the destination operand.
\par 
\par \tabType \tab\tabName \tab\tab         \tabValid
\par -----------------------------------------------------
\par \tab 0 \tab  Reserved                         No
\par \tab 1 \tab  Available 16-bit TSS             Yes
\par \tab 2 \tab  LDT                              Yes
\par \tab 3 \tab  Busy 16-bit TSS                  Yes
\par \tab 4\tab  16-bit call gate                 No
\par \tab 5 \tab  16-bit/32-bit task gate          No
\par \tab 6 \tab  16-bit interrupt gate            No
\par \tab 7\tab  16-bit trap gate                 No
\par \tab 8\tab  Reserved                         No
\par \tab 9\tab  Available 32-bit TSS             Yes
\par \tab A\tab  Reserved                         No
\par \tab B\tab  Busy 32-bit TSS                  Yes
\par \tab C\tab  32-bit call gate                 No
\par \tab D\tab  Reserved                         No
\par \tab E\tab  32-bit interrupt gate            No
\par \tab F \tab  32-bit trap gate                 No
{\page}

${\footnote LSL,Operation}
K{\footnote LSL,LSL;LSL,Operation}
#{\footnote LSL::2}

{\fs20\b LSL}\tab{\b Operation}\par\par
IF SRC(Offset) > descriptor table limit
\par THEN ZF <- 0; FI;
\par Read segment descriptor;
\par IF SegmentDescriptor(Type) != conforming code segment
\par AND (CPL > DPL) OR (RPL > DPL)
\par OR Segment type is not valid for instruction
\par THEN
\par ZF <- 0
\par ELSE
\par temp <- SegmentLimit([SRC]);
\par IF (G = 1)
\par THEN
\par temp <- ShiftLeft(12, temp) OR 00000FFFH;
\par FI;
\par IF OperandSize = 32
\par THEN
\par DEST <- temp;
\par ELSE (*OperandSize = 16*)
\par DEST <- temp AND FFFFH;
\par FI;
\par FI;
{\page}

${\footnote LSL,Flags affected}
K{\footnote LSL,LSL;LSL,Flags affected}
#{\footnote LSL::3}

{\fs20\b LSL}\tab{\b Flags affected}\par\par
The ZF flag is set to 1 if the segment limit is loaded successfully; otherwise, it is cleared to 0.
{\page}

${\footnote LSL,Exceptions}
K{\footnote LSL,LSL;LSL,Exceptions}
#{\footnote LSL::4}

{\fs20\b LSL}\tab{\b Exceptions}\par\par
Protected Mode Exceptions
\par 
\par #GP(0) If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit. If the DS, ES, FS, or GS register is used to access memory and it contains a null segment selector.
\par #SS(0) If a memory operand effective address is outside the SS segment limit.
\par #PF(fault-code) If a page fault occurs.
\par #AC(0) If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.
\par 
\par Real-Address Mode Exceptions
\par 
\par #UD The LSL instruction is not recognized in real-address mode.
\par 
\par Virtual-8086 Mode Exceptions
\par 
\par #UD The LSL instruction is not recognized in virtual-8086 mode.
{\page}

${\footnote LSL,Opcode}
K{\footnote LSL,LSL;LSL,Opcode}
#{\footnote LSL::5}

{\fs20\b LSL}\tab{\b Opcode}\par\par
0F 03 / r LSL r16,r/m16 Load: r16 <- segment limit, selector r/m16
\par 0F 03 / r LSL r32,r/m32 Load: r32 <- segment limit, selector r/m32)
{\page}

${\footnote LTR,Description}
K{\footnote LTR,LTR;LTR,Description}
#{\footnote LTR::1}

{\fs20\b LTR}\tab{\b Description}\par\par
LTR: Load Task Register
\par 
\par Loads the source operand into the segment selector field of the task register. The source operand (a general-purpose register or a memory location) contains a segment selector that points to a task state segment (TSS). After the segment selector is loaded in the task register, the processor uses the segment selector to locate the segment descriptor for the TSS in the global descriptor table (GDT). It then loads the segment limit and base address for the TSS from the segment descriptor into the task register. The task pointed to by the task register is marked busy, but a switch to the task does not occur.
\par The LTR instruction is provided for use in operating-system software; it should not be used in application programs. It can only be executed in protected mode when the CPL is 0. It is commonly used in initialization code to establish the first task to be executed. The operand-size attribute has no effect on this instruction.
{\page}

${\footnote LTR,Operation}
K{\footnote LTR,LTR;LTR,Operation}
#{\footnote LTR::2}

{\fs20\b LTR}\tab{\b Operation}\par\par
IF SRC(Offset) > descriptor table limit OR IF SRC(type) != global
\par THEN #GP(segment selector);
\par FI;
\par Read segment descriptor;
\par IF segment descriptor is not for an available TSS THEN #GP(segment selector); FI;
\par IF segment descriptor is not present THEN #NP(segment selector);
\par TSSsegmentDescriptor(busy) <- 1;
\par (* Locked read-modify-write operation on the entire descriptor when setting busy flag *)
\par TaskRegister(SegmentSelector) <- SRC;
\par TaskRegister(SegmentDescriptor) <- TSSSegmentDescriptor;
{\page}

${\footnote LTR,Flags affected}
K{\footnote LTR,LTR;LTR,Flags affected}
#{\footnote LTR::3}

{\fs20\b LTR}\tab{\b Flags affected}\par\par
None.
{\page}

${\footnote LTR,Exceptions}
K{\footnote LTR,LTR;LTR,Exceptions}
#{\footnote LTR::4}

{\fs20\b LTR}\tab{\b Exceptions}\par\par
Protected Mode Exceptions
\par 
\par #GP(0) If the current privilege level is not 0. If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit. If the DS, ES, FS, or GS register is used to access memory and it contains a null segment selector.
\par #GP(selector) If the source selector points to a segment that is not a TSS or to one for a task that is already busy. If the selector points to LDT or is beyond the GDT limit.
\par #NP(selector) If the TSS is marked not present.
\par #SS(0) If a memory operand effective address is outside the SS segment limit.
\par #PF(fault-code) If a page fault occurs.
\par 
\par Real-Address Mode Exceptions
\par 
\par #UD The LTR instruction is not recognized in real-address mode.
\par 
\par Virtual-8086 Mode Exceptions
\par 
\par #UD The LTR instruction is not recognized in virtual-8086 mode.
{\page}

${\footnote LTR,Opcode}
K{\footnote LTR,LTR;LTR,Opcode}
#{\footnote LTR::5}

{\fs20\b LTR}\tab{\b Opcode}\par\par
0F 00 /3 LTR r/m16 Load r/m16 into task register
{\page}

${\footnote MOV,Description}
K{\footnote MOV,MOV;MOV,Description}
#{\footnote MOV::1}

{\fs20\b MOV}\tab{\b Description}\par\par
MOV: Move
\par 
\par NOTES:
\par ------
\par *The moffs8, moffs16, and moffs32 operands specify a simple offset relative to the segment base , where 8, 16, and 32 refer to the size of the data. The address-size attribute of the instruction determines the size of the offset, either 16 or 32 bits.
\par ** In 32-bit mode, the assembler may insert the 16-bit operand-size prefix with this instruction.
\par 
\par Copies the second operand (source operand) to the first operand (destination operand). The source operand can be an immediate value, general-purpose register, segment register, or memory location; the destination register can be a general-purpose register, segment register, or memory location. Both operands must be the same size, which can be a byte, a word, or a doubleword.
\par The MOV instruction cannot be used to load the CS register. Attempting to do so results in an invalid opcode exception (#UD). To load the CS register, use the far JMP, CALL, or RET instruction.
\par If the destination operand is a segment register (DS, ES, FS, GS, or SS), the source operand must be a valid segment selector. In protected mode, moving a segment selector into a segment register automatically causes the segment descriptor information associated with that segment selector to be loaded into the hidden (shadow) part of the segment register. While loading this information, the segment selector and segment descriptor information is validated (see the "Operation" algorithm). The segment descriptor data is obtained from the GDT or LDT entry for the specified segment selector.
\par A null segment selector (values 0000-0003) can be loaded into the DS, ES, FS, and GS registers without causing a protection exception. However, any subsequent attempt to reference a segment whose corresponding segment register is loaded with a null value causes a general protection exception (#GP) and no memory reference occurs.
\par Loading the SS register with a MOV instruction inhibits all interrupts until after the execution of the next instruction. This operation allows a stack pointer to be loaded into the ESP register with the next instruction (MOV ESP, stack-pointer value) before an interrupt occurs 1 . The LSS instruction offers a more efficient method of loading the SS and ESP registers.
\par When operating in 32-bit mode and moving data between a segment register and a general-purpose register, the Intel Architecture 32-bit processors do not require the use of the 16-bit operand-size prefix (a byte with the value 66H) with this instruction, but most assemblers will insert it if the standard form of the instruction is used (for example, MOV DS, AX). The processor will execute this instruction correctly, but it will usually require an extra clock. With most assemblers, using the instruction form MOV DS, EAX will avoid this unneeded 66H prefix. When the processor executes the instruction with a 32-bit general-purpose register, it assumes that the 16 least-significant bits of the general-purpose register are the destination or source operand. If the register is a destination operand, the resulting value in the two high-order bytes of the register is implementation dependent. For the Pentium Pro processor, the two high-order bytes are filled with zeros; for earlier 32-bit Intel Architecture processors, the two high order bytes are undefined.
\par 
\par NOTE: In a sequence of instructions that individually delay interrupts past the following instruction, only the first instruction in the sequence is guaranteed to delay the interrupt, but subsequent interrupt-delaying instructions may not delay the interrupt. Thus, in the following instruction sequence:
\par 
\par STI
\par MOV SS, EAX
\par MOV ESP, EBP
\par 
\par interrupts may be recognized before MOV ESP, EBP executes, because STI also delays interrupts for one instruction.
{\page}

${\footnote MOV,Operation}
K{\footnote MOV,MOV;MOV,Operation}
#{\footnote MOV::2}

{\fs20\b MOV}\tab{\b Operation}\par\par
DEST <- SRC;
\par Loading a segment register while in protected mode results in special checks and actions, as described in the following listing. These checks are performed on the segment selector and the segment descriptor it points to.
\par IF SS is loaded;
\par THEN
\par IF segment selector is null
\par THEN #GP(0);
\par FI;
\par IF segment selector index is outside descriptor table limits
\par OR segment selector's RPL != CPL
\par OR segment is not a writable data segment
\par OR DPL != CPL
\par THEN #GP(selector);
\par FI;
\par IF segment not marked present
\par THEN #SS(selector);
\par ELSE
\par SS <- segment selector;
\par SS <- segment descriptor;
\par FI;
\par FI;
\par IF DS, ES, FS or GS is loaded with non-null selector;
\par THEN
\par IF segment selector index is outside descriptor table limits
\par OR segment is not a data or readable code segment
\par OR ((segment is a data or nonconforming code segment)
\par AND (both RPL and CPL > DPL))
\par THEN #GP(selector);
\par IF segment not marked present
\par THEN #NP(selector);
\par ELSE
\par SegmentRegister <- segment selector;
\par SegmentRegister <- segment descriptor;
\par FI;
\par FI;
\par IF DS, ES, FS or GS is loaded with a null selector;
\par THEN
\par SegmentRegister <- segment selector;
\par SegmentRegister <- segment descriptor;
\par FI;
{\page}

${\footnote MOV,Flags affected}
K{\footnote MOV,MOV;MOV,Flags affected}
#{\footnote MOV::3}

{\fs20\b MOV}\tab{\b Flags affected}\par\par
None.
{\page}

${\footnote MOV,Exceptions}
K{\footnote MOV,MOV;MOV,Exceptions}
#{\footnote MOV::4}

{\fs20\b MOV}\tab{\b Exceptions}\par\par
Protected Mode Exceptions
\par 
\par #GP(0) If attempt is made to load SS register with null segment selector. If the destination operand is in a nonwritable segment. If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit. If the DS, ES, FS, or GS register contains a null segment selector.
\par #GP(selector) If segment selector index is outside descriptor table limits. If the SS register is being loaded and the segment selector's RPL and the segment descriptor's DPL are not equal to the CPL. If the SS register is being loaded and the segment pointed to is a nonwritable data segment. If the DS, ES, FS, or GS register is being loaded and the segment pointed to is not a data or readable code segment. If the DS, ES, FS, or GS register is being loaded and the segment pointed to is a data or nonconforming code segment, but both the RPL and the CPL are greater than the DPL.
\par #SS(0) If a memory operand effective address is outside the SS segment limit.
\par #SS(selector) If the SS register is being loaded and the segment pointed to is marked not present.
\par #NP If the DS, ES, FS, or GS register is being loaded and the segment pointed to is marked not present.
\par #PF(fault-code) If a page fault occurs.
\par #AC(0) If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.
\par #UD If attempt is made to load the CS register.
\par 
\par Real-Address Mode Exceptions
\par 
\par #GP If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.
\par #SS If a memory operand effective address is outside the SS segment limit.
\par #UD If attempt is made to load the CS register.
\par 
\par Virtual-8086 Mode Exceptions
\par 
\par #GP(0) If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.
\par #SS(0) If a memory operand effective address is outside the SS segment limit.
\par #PF(fault-code) If a page fault occurs.
\par #AC(0) If alignment checking is enabled and an unaligned memory reference is made.
\par #UD If attempt is made to load the CS register.
{\page}

${\footnote MOV,Opcode}
K{\footnote MOV,MOV;MOV,Opcode}
#{\footnote MOV::5}

{\fs20\b MOV}\tab{\b Opcode}\par\par
88 / r MOV r/m8,r8 Move r8 to r/m8
\par 89 / r MOV r/m16,r16 Move r16 to r/m16
\par 89 / r MOV r/m32,r32 Move r32 to r/m32
\par 8A / r MOV r8,r/m8 Move r/m8 to r8
\par 8B / r MOV r16,r/m16 Move r/m16 to r16
\par 8B / r MOV r32,r/m32 Move r/m32 to r32
\par 8C / r MOV r/m16,Sreg** Move segment register to r/m16
\par 8E / r MOV Sreg,r/m16** Move r/m16 to segment register
\par A0 MOV AL, moffs8* Move byte at ( seg:offset) to AL
\par A1 MOV AX, moffs16* Move word at ( seg:offset) to AX
\par A1 MOV EAX, moffs32* Move doubleword at ( seg:offset) to EAX
\par A2 MOV moffs8*,AL Move AL to ( seg:offset)
\par A3 MOV moffs16*,AX Move AX to ( seg:offset)
\par A3 MOV moffs32*,EAX Move EAX to ( seg:offset)
\par B0+ rb MOV r8,imm8 Move imm8 to r8
\par B8+ rw MOV r16,imm16 Move imm16 to r16
\par B8+ rd MOV r32,imm32 Move imm32 to r32
\par C6 / 0 MOV r/m8,imm8 Move imm8 to r/m8
\par C7 / 0 MOV r/m16,imm16 Move imm16 to r/m16
\par C7 / 0 MOV r/m32,imm32 Move imm32 to r/m32
{\page}

${\footnote MOVD,Description}
K{\footnote MOVD,MOVD;MOVD,Description}
#{\footnote MOVD::1}

{\fs20\b MOVD}\tab{\b Description}\par\par
MOVD: Move 32 Bits
\par 
\par Copies doubleword from the source operand (second operand) to the destination operand (first operand). Source and destination operands can be MMX registers, memory locations, or 32-bit general-purpose registers; however, data cannot be transferred from an MMX register to an MMX register, from one memory location to another memory location, or from one general-purpose register to another general-purpose register.
\par When the destination operand is an MMX register, the 32-bit source value is written to the low-order 32 bits of the 64-bit MMX register and zero-extended to 64 bits. When the source operand is an MMX register, the low-order 32 bits of the MMX register are written to the 32-bit general-purpose register or 32-bit memory location selected with the destination operand.
{\page}

${\footnote MOVD,Operation}
K{\footnote MOVD,MOVD;MOVD,Operation}
#{\footnote MOVD::2}

{\fs20\b MOVD}\tab{\b Operation}\par\par
IF DEST is MMX register
\par THEN
\par DEST <- ZeroExtend(SRC);
\par ELSE (* SRC is MMX register *)
\par DEST <- LowOrderDoubleword(SRC);
{\page}

${\footnote MOVD,Flags affected}
K{\footnote MOVD,MOVD;MOVD,Flags affected}
#{\footnote MOVD::3}

{\fs20\b MOVD}\tab{\b Flags affected}\par\par
None.
{\page}

${\footnote MOVD,Exceptions}
K{\footnote MOVD,MOVD;MOVD,Exceptions}
#{\footnote MOVD::4}

{\fs20\b MOVD}\tab{\b Exceptions}\par\par
Protected Mode Exceptions
\par 
\par #GP(0) If the destination operand is in a nonwritable segment. If a memory operand effective address is outside the CS, DS, ES, FS or GS segment limit.
\par #SS(0) If a memory operand effective address is outside the SS segment limit.
\par #UD If EM in CR0 is set.
\par #NM If TS in CR0 is set.
\par #MF If there is a pending FPU exception.
\par #PF(fault-code) If a page fault occurs.
\par #AC(0) If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.
\par 
\par Real-Address Mode Exceptions
\par 
\par #GP If any part of the operand lies outside of the effective address space from 0 to FFFFH.
\par #UD If EM in CR0 is set.
\par #NM If TS in CR0 is set.
\par #MF If there is a pending FPU exception.
\par 
\par Virtual-8086 Mode Exceptions
\par 
\par #GP If any part of the operand lies outside of the effective address space from 0 to FFFFH.
\par #UD If EM in CR0 is set.
\par #NM If TS in CR0 is set.
\par #MF If there is a pending FPU exception.
\par #PF(fault-code) If a page fault occurs.
\par #AC(0) If alignment checking is enabled and an unaligned memory reference is made.
{\page}

${\footnote MOVD,Opcode}
K{\footnote MOVD,MOVD;MOVD,Opcode}
#{\footnote MOVD::5}

{\fs20\b MOVD}\tab{\b Opcode}\par\par
0F 6E /r MOVD mm, r/m32 Move doubleword from r/m32 to mm.
\par 0F 7E /r MOVD r/m32, mm Move doubleword from mm to r/m32.
{\page}

${\footnote MOVQ,Description}
K{\footnote MOVQ,MOVQ;MOVQ,Description}
#{\footnote MOVQ::1}

{\fs20\b MOVQ}\tab{\b Description}\par\par
MOVQ: Move 64 Bits
\par 
\par Copies quadword from the source operand (second operand) to the destination operand (first operand). A source or destination operand can be either an MMX register or a memory location; however, data cannot be transferred from one memory location to another memory location. Data can be transferred from one MMX register to another MMX register.
{\page}

${\footnote MOVQ,Operation}
K{\footnote MOVQ,MOVQ;MOVQ,Operation}
#{\footnote MOVQ::2}

{\fs20\b MOVQ}\tab{\b Operation}\par\par
DEST <- SRC;
{\page}

${\footnote MOVQ,Flags affected}
K{\footnote MOVQ,MOVQ;MOVQ,Flags affected}
#{\footnote MOVQ::3}

{\fs20\b MOVQ}\tab{\b Flags affected}\par\par
None.
{\page}

${\footnote MOVQ,Exceptions}
K{\footnote MOVQ,MOVQ;MOVQ,Exceptions}
#{\footnote MOVQ::4}

{\fs20\b MOVQ}\tab{\b Exceptions}\par\par
Protected Mode Exceptions
\par 
\par #GP(0) If the destination operand is in a nonwritable segment. If a memory operand effective address is outside the CS, DS, ES, FS or GS segment limit.
\par #SS(0) If a memory operand effective address is outside the SS segment limit.
\par #UD If EM in CR0 is set.
\par #NM If TS in CR0 is set.
\par #MF If there is a pending FPU exception.
\par #PF(fault-code) If a page fault occurs.
\par #AC(0) If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.
\par 
\par Real-Address Mode Exceptions
\par 
\par #GP If any part of the operand lies outside of the effective address space from 0 to FFFFH.
\par #UD If EM in CR0 is set.
\par #NM If TS in CR0 is set.
\par #MF If there is a pending FPU exception.
\par 
\par Virtual-8086 Mode Exceptions
\par 
\par #GP If any part of the operand lies outside of the effective address space from 0 to FFFFH.
\par #UD If EM in CR0 is set.
\par #NM If TS in CR0 is set.
\par #MF If there is a pending FPU exception.
\par #PF(fault-code) If a page fault occurs.
\par #AC(0) If alignment checking is enabled and an unaligned memory reference is made.
{\page}

${\footnote MOVQ,Opcode}
K{\footnote MOVQ,MOVQ;MOVQ,Opcode}
#{\footnote MOVQ::5}

{\fs20\b MOVQ}\tab{\b Opcode}\par\par
0F 6F /r MOVQ mm, mm/m64 Move quadword from mm/m64 to mm.
\par 0F 7F /r MOVQ mm/m64, mm Move quadword from mm to mm/m64.
{\page}

${\footnote MOVS,Description}
K{\footnote MOVS,MOVS;MOVSB,MOVSB;MOVSD,MOVSD;MOVSW,MOVSW;MOVS,Description;MOVSB,Description;MOVSD,Description;MOVSW,Description}
#{\footnote MOVS::1}
#{\footnote MOVSB::1}
#{\footnote MOVSD::1}
#{\footnote MOVSW::1}

{\fs20\b MOVS/MOVSB/MOVSD/MOVSW}\tab{\b Description}\par\par
MOVS/MOVSB/MOVSW/MOVSD: Move Data from String to String
\par 
\par Moves the byte, word, or doubleword specified with the second operand (source operand) to the location specified with the first operand (destination operand). Both the source and destination operands are located in memory. The address of the source operand is read from the DS:ESI or the DS:SI registers (depending on the address-size attribute of the instruction, 32 or 16, respectively). The address of the destination operand is read from the ES:EDI or the ES:DI registers (again depending on the address-size attribute of the instruction). The DS segment may be overridden with a segment override prefix, but the ES segment cannot be overridden.
\par At the assembly-code level, two forms of this instruction are allowed: the "explicit-operands" form and the "no-operands" form. The explicit-operands form (specified with the MOVS mnemonic) allows the source and destination operands to be specified explicitly. Here, the source and destination operands should be symbols that indicate the size and location of the source value and the destination, respectively. This explicit-operands form is provided to allow documentation; however, note that the documentation provided by this form can be misleading. That is, the source and destination operand symbols must specify the correct type (size) of the operands (bytes, words, or doublewords), but they do not have to specify the correct location. The locations of the source and destination operands are always specified by the DS:(E)SI and ES:(E)DI registers, which must be loaded correctly before the move string instruction is executed.
\par The no-operands form provides "short forms" of the byte, word, and doubleword versions of the MOVS instructions. Here also DS:(E)SI and ES:(E)DI are assumed to be the source and destination operands, respectively. The size of the source and destination operands is selected with the mnemonic: MOVSB (byte move), MOVSW (word move), or MOVSD (doubleword move).
\par After the move operation, the (E)SI and (E)DI registers are incremented or decremented automatically according to the setting of the DF flag in the EFLAGS register. (If the DF flag is 0, the (E)SI and (E)DI register are incremented; if the DF flag is 1, the (E)SI and (E)DI registers are decremented.) The registers are incremented or decremented by 1 for byte operations, by 2 for word operations, or by 4 for doubleword operations.
\par The MOVS, MOVSB, MOVSW, and MOVSD instructions can be preceded by the REP prefix for block moves of ECX bytes, words, or doublewords.
{\page}

${\footnote MOVS,Operation}
K{\footnote MOVS,MOVS;MOVSB,MOVSB;MOVSD,MOVSD;MOVSW,MOVSW;MOVS,Operation;MOVSB,Operation;MOVSD,Operation;MOVSW,Operation}
#{\footnote MOVS::2}
#{\footnote MOVSB::2}
#{\footnote MOVSD::2}
#{\footnote MOVSW::2}

{\fs20\b MOVS/MOVSB/MOVSD/MOVSW}\tab{\b Operation}\par\par
DEST <-SRC;
\par IF (byte move)
\par THEN IF DF = 0
\par THEN
\par (E)SI <- (E)SI + 1;
\par (E)DI <- (E)DI + 1;
\par ELSE
\par (E)SI <- (E)SI - 1;
\par (E)DI <- (E)DI - 1;
\par FI;
\par ELSE IF (word move)
\par THEN IF DF = 0
\par (E)SI <- (E)SI + 2;
\par (E)DI <- (E)DI + 2;
\par ELSE
\par (E)SI <- (E)SI - 2;
\par (E)DI <- (E)DI - 2;
\par FI;
\par ELSE (* doubleword move*)
\par THEN IF DF = 0
\par (E)SI <- (E)SI + 4;
\par (E)DI <- (E)DI + 4;
\par ELSE
\par (E)SI <- (E)SI - 4;
\par (E)DI <- (E)DI - 4;
\par FI;
\par FI;
{\page}

${\footnote MOVS,Flags affected}
K{\footnote MOVS,MOVS;MOVSB,MOVSB;MOVSD,MOVSD;MOVSW,MOVSW;MOVS,Flags affected;MOVSB,Flags affected;MOVSD,Flags affected;MOVSW,Flags affected}
#{\footnote MOVS::3}
#{\footnote MOVSB::3}
#{\footnote MOVSD::3}
#{\footnote MOVSW::3}

{\fs20\b MOVS/MOVSB/MOVSD/MOVSW}\tab{\b Flags affected}\par\par
None.
{\page}

${\footnote MOVS,Exceptions}
K{\footnote MOVS,MOVS;MOVSB,MOVSB;MOVSD,MOVSD;MOVSW,MOVSW;MOVS,Exceptions;MOVSB,Exceptions;MOVSD,Exceptions;MOVSW,Exceptions}
#{\footnote MOVS::4}
#{\footnote MOVSB::4}
#{\footnote MOVSD::4}
#{\footnote MOVSW::4}

{\fs20\b MOVS/MOVSB/MOVSD/MOVSW}\tab{\b Exceptions}\par\par
Protected Mode Exceptions
\par 
\par #GP(0) If the destination is located in a nonwritable segment. If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit. If the DS, ES, FS, or GS register contains a null segment selector.
\par #SS(0) If a memory operand effective address is outside the SS segment limit.
\par #PF(fault-code) If a page fault occurs.
\par #AC(0) If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.
\par 
\par Real-Address Mode Exceptions
\par 
\par #GP If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.
\par #SS If a memory operand effective address is outside the SS segment limit.
\par 
\par Virtual-8086 Mode Exceptions
\par 
\par #GP(0) If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.
\par #SS(0) If a memory operand effective address is outside the SS segment limit.
\par #PF(fault-code) If a page fault occurs.
\par #AC(0) If alignment checking is enabled and an unaligned memory reference is made.
{\page}

${\footnote MOVS,Opcode}
K{\footnote MOVS,MOVS;MOVSB,MOVSB;MOVSD,MOVSD;MOVSW,MOVSW;MOVS,Opcode;MOVSB,Opcode;MOVSD,Opcode;MOVSW,Opcode}
#{\footnote MOVS::5}
#{\footnote MOVSB::5}
#{\footnote MOVSD::5}
#{\footnote MOVSW::5}

{\fs20\b MOVS/MOVSB/MOVSD/MOVSW}\tab{\b Opcode}\par\par
A4 MOVS m8, m8 Move byte at address DS:(E)SI to address ES:(E)DI
\par A5 MOVS m16, m16 Move word at address DS:(E)SI to address ES:(E)DI
\par A5 MOVS m32, m32 Move doubleword at address DS:(E)SI to address ES:(E)DI
\par A4 MOVSB Move byte at address DS:(E)SI to address ES:(E)DI
\par A5 MOVSW Move word at address DS:(E)SI to address ES:(E)DI
\par A5 MOVSD Move doubleword at address DS:(E)SI to address ES:(E)DI
{\page}

${\footnote MOVSX,Description}
K{\footnote MOVSX,MOVSX;MOVSX,Description}
#{\footnote MOVSX::1}

{\fs20\b MOVSX}\tab{\b Description}\par\par
MOVSX: Move with Sign-Extension
\par 
\par Copies the contents of the source operand (register or memory location) to the destination operand (register) and sign extends the value to 16 or 32 bits. The size of the converted value depends on the operand-size attribute.
{\page}

${\footnote MOVSX,Operation}
K{\footnote MOVSX,MOVSX;MOVSX,Operation}
#{\footnote MOVSX::2}

{\fs20\b MOVSX}\tab{\b Operation}\par\par
DEST <- SignExtend(SRC);
{\page}

${\footnote MOVSX,Flags affected}
K{\footnote MOVSX,MOVSX;MOVSX,Flags affected}
#{\footnote MOVSX::3}

{\fs20\b MOVSX}\tab{\b Flags affected}\par\par
None.
{\page}

${\footnote MOVSX,Exceptions}
K{\footnote MOVSX,MOVSX;MOVSX,Exceptions}
#{\footnote MOVSX::4}

{\fs20\b MOVSX}\tab{\b Exceptions}\par\par
Protected Mode Exceptions
\par 
\par #GP(0) If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit. If the DS, ES, FS, or GS register contains a null segment selector.
\par #SS(0) If a memory operand effective address is outside the SS segment limit.
\par #PF(fault-code) If a page fault occurs.
\par #AC(0) If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.
\par 
\par Real-Address Mode Exceptions
\par 
\par #GP If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.
\par #SS If a memory operand effective address is outside the SS segment limit.
\par 
\par Virtual-8086 Mode Exceptions
\par 
\par #GP(0) If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.
\par #SS(0) If a memory operand effective address is outside the SS segment limit.
\par #PF(fault-code) If a page fault occurs.
{\page}

${\footnote MOVSX,Opcode}
K{\footnote MOVSX,MOVSX;MOVSX,Opcode}
#{\footnote MOVSX::5}

{\fs20\b MOVSX}\tab{\b Opcode}\par\par
0F BE / r MOVSX r16,r/m8 Move byte to word with sign-extension
\par 0F BE / r MOVSX r32,r/m8 Move byte to doubleword, sign-extension
\par 0F BF / r MOVSX r32,r/m16 Move word to doubleword, sign-extension
{\page}

${\footnote MOVZX,Description}
K{\footnote MOVZX,MOVZX;MOVZX,Description}
#{\footnote MOVZX::1}

{\fs20\b MOVZX}\tab{\b Description}\par\par
MOVZX: Move with Zero-Extend
\par 
\par Copies the contents of the source operand (register or memory location) to the destination operand (register) and zero extends the value to 16 or 32 bits. The size of the converted value depends on the operand-size attribute
{\page}

${\footnote MOVZX,Operation}
K{\footnote MOVZX,MOVZX;MOVZX,Operation}
#{\footnote MOVZX::2}

{\fs20\b MOVZX}\tab{\b Operation}\par\par
DEST <- ZeroExtend(SRC);
{\page}

${\footnote MOVZX,Flags affected}
K{\footnote MOVZX,MOVZX;MOVZX,Flags affected}
#{\footnote MOVZX::3}

{\fs20\b MOVZX}\tab{\b Flags affected}\par\par
None.
{\page}

${\footnote MOVZX,Exceptions}
K{\footnote MOVZX,MOVZX;MOVZX,Exceptions}
#{\footnote MOVZX::4}

{\fs20\b MOVZX}\tab{\b Exceptions}\par\par
Protected Mode Exceptions
\par 
\par #GP(0) If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit. If the DS, ES, FS, or GS register contains a null segment selector.
\par #SS(0) If a memory operand effective address is outside the SS segment limit.
\par #PF(fault-code) If a page fault occurs.
\par #AC(0) If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.
\par 
\par Real-Address Mode Exceptions
\par 
\par #GP If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.
\par #SS If a memory operand effective address is outside the SS segment limit.
\par 
\par Virtual-8086 Mode Exceptions
\par 
\par #GP(0) If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.
\par #SS(0) If a memory operand effective address is outside the SS segment limit.
\par #PF(fault-code) If a page fault occurs.
\par #AC(0) If alignment checking is enabled and an unaligned memory reference is made.
{\page}

${\footnote MOVZX,Opcode}
K{\footnote MOVZX,MOVZX;MOVZX,Opcode}
#{\footnote MOVZX::5}

{\fs20\b MOVZX}\tab{\b Opcode}\par\par
0F B6 / r MOVZX r16,r/m8 Move byte to word with zero-extension
\par 0F B6 / r MOVZX r32,r/m8 Move byte to doubleword, zero-extension
\par 0F B7 / r MOVZX r32,r/m16 Move word to doubleword, zero-extension
{\page}

${\footnote MUL,Description}
K{\footnote MUL,MUL;MUL,Description}
#{\footnote MUL::1}

{\fs20\b MUL}\tab{\b Description}\par\par
MUL: Unsigned Multiply
\par 
\par Performs an unsigned multiplication of the first operand (destination operand) and the second operand (source operand) and stores the result in the destination operand. The destination operand is an implied operand located in register AL, AX or EAX (depending on the size of the operand); the source operand is located in a general-purpose register or a memory location.
\par The result is stored in register AX, register pair DX:AX, or register pair EDX:EAX (depending on the operand size), with the high-order bits of the product contained in register AH, DX, or EDX, respectively. If the high-order bits of the product are 0, the CF and OF flags are cleared; otherwise, the flags are set.
{\page}

${\footnote MUL,Operation}
K{\footnote MUL,MUL;MUL,Operation}
#{\footnote MUL::2}

{\fs20\b MUL}\tab{\b Operation}\par\par
IF byte operation
\par THEN
\par AX <- AL * SRC
\par ELSE (* word or doubleword operation *)
\par IF OperandSize = 16
\par THEN
\par DX:AX <- AX * SRC
\par ELSE (* OperandSize = 32 *)
\par EDX:EAX <- EAX * SRC
\par FI;
\par FI;
{\page}

${\footnote MUL,Flags affected}
K{\footnote MUL,MUL;MUL,Flags affected}
#{\footnote MUL::3}

{\fs20\b MUL}\tab{\b Flags affected}\par\par
The OF and CF flags are cleared to 0 if the upper half of the result is 0; otherwise, they are set to 1. The SF, ZF, AF, and PF flags are undefined.
{\page}

${\footnote MUL,Exceptions}
K{\footnote MUL,MUL;MUL,Exceptions}
#{\footnote MUL::4}

{\fs20\b MUL}\tab{\b Exceptions}\par\par
Protected Mode Exceptions
\par 
\par #GP(0) If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit. If the DS, ES, FS, or GS register contains a null segment selector.
\par #SS(0) If a memory operand effective address is outside the SS segment limit.
\par #PF(fault-code) If a page fault occurs.
\par #AC(0) If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.
\par 
\par Real-Address Mode Exceptions
\par 
\par #GP If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.
\par #SS If a memory operand effective address is outside the SS segment limit.
\par 
\par Virtual-8086 Mode Exceptions
\par 
\par #GP(0) If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.
\par #SS(0) If a memory operand effective address is outside the SS segment limit.
\par #PF(fault-code) If a page fault occurs.
\par #AC(0) If alignment checking is enabled and an unaligned memory reference is made.
{\page}

${\footnote MUL,Opcode}
K{\footnote MUL,MUL;MUL,Opcode}
#{\footnote MUL::5}

{\fs20\b MUL}\tab{\b Opcode}\par\par
F6 /4 MUL r/m8 Unsigned multiply (AX <- AL * r/m8)
\par F7 /4 MUL r/m16 Unsigned multiply (DX:AX <- AX * r/m16)
\par F7 /4 MUL r/m32 Unsigned multiply (EDX:EAX <- EAX * r/m32)
{\page}

${\footnote NEG,Description}
K{\footnote NEG,NEG;NEG,Description}
#{\footnote NEG::1}

{\fs20\b NEG}\tab{\b Description}\par\par
NEG: Two's Complement Negation
\par 
\par Replaces the value of operand (the destination operand) with its two's complement. (This operation is equivalent to subtracting the operand from 0.) The destination operand is located in a general-purpose register or a memory location.
{\page}

${\footnote NEG,Operation}
K{\footnote NEG,NEG;NEG,Operation}
#{\footnote NEG::2}

{\fs20\b NEG}\tab{\b Operation}\par\par
IF DEST = 0
\par THEN CF <- 0
\par ELSE CF <- 1;
\par FI;
\par DEST <- (DEST)
{\page}

${\footnote NEG,Flags affected}
K{\footnote NEG,NEG;NEG,Flags affected}
#{\footnote NEG::3}

{\fs20\b NEG}\tab{\b Flags affected}\par\par
The CF flag cleared to 0 if the source operand is 0; otherwise it is set to 1. The OF, SF, ZF, AF, and PF flags are set according to the result.
{\page}

${\footnote NEG,Exceptions}
K{\footnote NEG,NEG;NEG,Exceptions}
#{\footnote NEG::4}

{\fs20\b NEG}\tab{\b Exceptions}\par\par
Protected Mode Exceptions
\par 
\par #GP(0) If the destination is located in a nonwritable segment. If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit. If the DS, ES, FS, or GS register contains a null segment selector.
\par #SS(0) If a memory operand effective address is outside the SS segment limit.
\par #PF(fault-code) If a page fault occurs.
\par #AC(0) If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.
\par 
\par Real-Address Mode Exceptions
\par 
\par #GP If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.
\par #SS If a memory operand effective address is outside the SS segment limit.
\par 
\par Virtual-8086 Mode Exceptions
\par 
\par #GP(0) If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.
\par #SS(0) If a memory operand effective address is outside the SS segment limit.
\par #PF(fault-code) If a page fault occurs.
\par #AC(0) If alignment checking is enabled and an unaligned memory reference is made.
{\page}

${\footnote NEG,Opcode}
K{\footnote NEG,NEG;NEG,Opcode}
#{\footnote NEG::5}

{\fs20\b NEG}\tab{\b Opcode}\par\par
F6 /3 NEG r/m8 Two's complement negate r/m8
\par F7 /3 NEG r/m16 Two's complement negate r/m16
\par F7 /3 NEG r/m32 Two's complement negate r/m32
{\page}

${\footnote NOP,Description}
K{\footnote NOP,NOP;NOP,Description}
#{\footnote NOP::1}

{\fs20\b NOP}\tab{\b Description}\par\par
NOP: No Operation
\par 
\par Performs no operation. This instruction is a one-byte instruction that takes up space in the instruction stream but does not affect the machine context, except the EIP register. The NOP instruction is an alias mnemonic for the XCHG (E)AX, (E)AX instruction.
{\page}

${\footnote NOP,Operation}
K{\footnote NOP,NOP;NOP,Operation}
#{\footnote NOP::2}

{\fs20\b NOP}\tab{\b Operation}\par\par
No operation.
{\page}

${\footnote NOP,Flags affected}
K{\footnote NOP,NOP;NOP,Flags affected}
#{\footnote NOP::3}

{\fs20\b NOP}\tab{\b Flags affected}\par\par
None.
{\page}

${\footnote NOP,Exceptions}
K{\footnote NOP,NOP;NOP,Exceptions}
#{\footnote NOP::4}

{\fs20\b NOP}\tab{\b Exceptions}\par\par
(All Operating Modes)
\par None.
{\page}

${\footnote NOP,Opcode}
K{\footnote NOP,NOP;NOP,Opcode}
#{\footnote NOP::5}

{\fs20\b NOP}\tab{\b Opcode}\par\par
90 NOP No operation
{\page}

${\footnote NOT,Description}
K{\footnote NOT,NOT;NOT,Description}
#{\footnote NOT::1}

{\fs20\b NOT}\tab{\b Description}\par\par
NOT: One's Complement Negation
\par 
\par Performs a bitwise NOT operation (each 1 is cleared to 0, and each 0 is set to 1) on the destination operand and stores the result in the destination operand location. The destination operand can be a register or a memory location.
{\page}

${\footnote NOT,Operation}
K{\footnote NOT,NOT;NOT,Operation}
#{\footnote NOT::2}

{\fs20\b NOT}\tab{\b Operation}\par\par
DEST <- NOT DEST;
{\page}

${\footnote NOT,Flags affected}
K{\footnote NOT,NOT;NOT,Flags affected}
#{\footnote NOT::3}

{\fs20\b NOT}\tab{\b Flags affected}\par\par
None.
{\page}

${\footnote NOT,Exceptions}
K{\footnote NOT,NOT;NOT,Exceptions}
#{\footnote NOT::4}

{\fs20\b NOT}\tab{\b Exceptions}\par\par
Protected Mode Exceptions
\par 
\par #GP(0) If the destination operand points to a nonwritable segment. If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit. If the DS, ES, FS, or GS register contains a null segment selector.
\par #SS(0) If a memory operand effective address is outside the SS segment limit.
\par #PF(fault-code) If a page fault occurs.
\par #AC(0) If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.
\par 
\par Real-Address Mode Exceptions
\par 
\par #GP If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.
\par #SS If a memory operand effective address is outside the SS segment limit.
\par 
\par Virtual-8086 Mode Exceptions
\par 
\par #GP(0) If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.
\par #SS(0) If a memory operand effective address is outside the SS segment limit.
\par #PF(fault-code) If a page fault occurs.
\par #AC(0) If alignment checking is enabled and an unaligned memory reference is made.
{\page}

${\footnote NOT,Opcode}
K{\footnote NOT,NOT;NOT,Opcode}
#{\footnote NOT::5}

{\fs20\b NOT}\tab{\b Opcode}\par\par
F6 /2 NOT r/m8 Reverse each bit of r/m8
\par F7 /2 NOT r/m16 Reverse each bit of r/m16
\par F7 /2 NOT r/m32 Reverse each bit of r/m32
{\page}

${\footnote OR,Description}
K{\footnote OR,OR;OR,Description}
#{\footnote OR::1}

{\fs20\b OR}\tab{\b Description}\par\par
OR: Logical Inclusive OR
\par 
\par Performs a bitwise inclusive OR operation between the destination (first) and source (second) operands and stores the result in the destination operand location. The source operand can be an immediate, a register, or a memory location; the destination operand can be a register or a memory location. (However, two memory operands cannot be used in one instruction.) Each bit of the result of the OR instruction is 0 if both corresponding bits of the operands are 0; otherwise, each bit is 1.
{\page}

${\footnote OR,Operation}
K{\footnote OR,OR;OR,Operation}
#{\footnote OR::2}

{\fs20\b OR}\tab{\b Operation}\par\par
DEST <- DEST OR SRC;
{\page}

${\footnote OR,Flags affected}
K{\footnote OR,OR;OR,Flags affected}
#{\footnote OR::3}

{\fs20\b OR}\tab{\b Flags affected}\par\par
The OF and CF flags are cleared; the SF, ZF, and PF flags are set according to the result. The state of the AF flag is undefined.
{\page}

${\footnote OR,Exceptions}
K{\footnote OR,OR;OR,Exceptions}
#{\footnote OR::4}

{\fs20\b OR}\tab{\b Exceptions}\par\par
Protected Mode Exceptions
\par 
\par #GP(0) If the destination operand points to a nonwritable segment. If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit. If the DS, ES, FS, or GS register contains a null segment selector.
\par #SS(0) If a memory operand effective address is outside the SS segment limit.
\par #PF(fault-code) If a page fault occurs.
\par #AC(0) If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.
\par 
\par Real-Address Mode Exceptions
\par 
\par #GP If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.
\par #SS If a memory operand effective address is outside the SS segment limit.
\par 
\par Virtual-8086 Mode Exceptions
\par 
\par #GP(0) If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.
\par #SS(0) If a memory operand effective address is outside the SS segment limit.
\par #PF(fault-code) If a page fault occurs.
\par #AC(0) If alignment checking is enabled and an unaligned memory reference is made.
{\page}

${\footnote OR,Opcode}
K{\footnote OR,OR;OR,Opcode}
#{\footnote OR::5}

{\fs20\b OR}\tab{\b Opcode}\par\par
0C ib OR AL, imm8 AL OR imm8
\par 0D iw OR AX, imm16 AX OR imm16
\par 0D id OR EAX, imm32 EAX OR imm32
\par 80 /1 ib OR r/m8,imm8 r/m8 OR imm8
\par 81 /1 iw OR r/m16,imm16 r/m16 OR imm16
\par 81 /1 id OR r/m32,imm32 r/m32 OR imm32
\par 83 /1 ib OR r/m16,imm8 r/m16 OR imm8 (sign-extended)
\par 83 /1 ib OR r/m32,imm8 r/m32 OR imm8 (sign-extended)
\par 08 / r OR r/m8,r8 r/m8 OR r8
\par 09 / r OR r/m16,r16 r/m16 OR r16
\par 09 / r OR r/m32,r32 r/m32 OR r32
\par 0A / r OR r8,r/m8 r8 OR r/m8
\par 0B / r OR r16,r/m16 r16 OR r/m16
\par 0B / r OR r32,r/m32 r32 OR r/m32
{\page}

${\footnote OUT,Description}
K{\footnote OUT,OUT;OUT,Description}
#{\footnote OUT::1}

{\fs20\b OUT}\tab{\b Description}\par\par
OUT: Output to Port
\par 
\par Copies the value from the second operand (source operand) to the I/O port specified with the destination operand (first operand). The source operand can be register AL, AX, or EAX, depending on the size of the port being accessed (8, 16, or 32 bits, respectively); the destination operand can be a byte-immediate or the DX register. Using a byte immediate allows I/O port addresses 0 to 255 to be accessed; using the DX register as a source operand allows I/O ports from 0 to 65,535 to be accessed.
\par The size of the I/O port being accessed is determined by the opcode for an 8-bit I/O port or by the operand-size attribute of the instruction for a 16- or 32-bit I/O port. At the machine code level, I/O instructions are shorter when accessing 8-bit I/O ports. Here, the upper eight bits of the port address will be 0. This instruction is only useful for accessing I/O ports located in the processor's I/O address space.
\par 
\par Intel Architecture Compatibility
\par 
\par After executing an OUT instruction, the Pentium processor insures that the EWBE# pin has been sampled active before it begins to execute the next instruction. (Note that the instruction can be prefetched if EWBE# is not active, but it will not be executed until the EWBE# pin is sampled active.) Only the Pentium processor family has the EWBE# pin; the other Intel Architecture processors do not.
{\page}

${\footnote OUT,Operation}
K{\footnote OUT,OUT;OUT,Operation}
#{\footnote OUT::2}

{\fs20\b OUT}\tab{\b Operation}\par\par
IF ((PE = 1) AND ((CPL > IOPL) OR (VM = 1)))
\par THEN (* Protected mode with CPL > IOPL or virtual-8086 mode *)
\par IF (Any I/O Permission Bit for I/O port being accessed = 1)
\par THEN (* I/O operation is not allowed *)
\par #GP(0);
\par ELSE ( * I/O operation is allowed *)
\par DEST <- SRC; (* Writes to selected I/O port *)
\par FI;
\par ELSE (Real Mode or Protected Mode with CPL  IOPL *)
\par DEST <- SRC; (* Writes to selected I/O port *)
\par FI;
{\page}

${\footnote OUT,Flags affected}
K{\footnote OUT,OUT;OUT,Flags affected}
#{\footnote OUT::3}

{\fs20\b OUT}\tab{\b Flags affected}\par\par
None.
{\page}

${\footnote OUT,Exceptions}
K{\footnote OUT,OUT;OUT,Exceptions}
#{\footnote OUT::4}

{\fs20\b OUT}\tab{\b Exceptions}\par\par
Protected Mode Exceptions
\par 
\par #GP(0) If the CPL is greater than (has less privilege) the I/O privilege level (IOPL) and any of the corresponding I/O permission bits in TSS for the I/O port being accessed is 1.
\par 
\par Real-Address Mode Exceptions
\par 
\par None.
\par 
\par Virtual-8086 Mode Exceptions
\par 
\par #GP(0) If any of the I/O permission bits in the TSS for the I/O port being accessed is 1.
{\page}

${\footnote OUT,Opcode}
K{\footnote OUT,OUT;OUT,Opcode}
#{\footnote OUT::5}

{\fs20\b OUT}\tab{\b Opcode}\par\par
E6 ib OUT imm8, AL Output byte in AL to I/O port address imm8
\par E7 ib OUT imm8, AX Output word in AX to I/O port address imm8
\par E7 ib OUT imm8, EAX Output doubleword in EAX to I/O port address imm8
\par EE OUT DX, AL Output byte in AL to I/O port address in DX
\par EF OUT DX, AX Output word in AX to I/O port address in DX
\par EF OUT DX, EAX Output doubleword in EAX to I/O port address in DX
{\page}

${\footnote OUTS,Description}
K{\footnote OUTS,OUTS;OUTSB,OUTSB;OUTSD,OUTSD;OUTSW,OUTSW;OUTS,Description;OUTSB,Description;OUTSD,Description;OUTSW,Description}
#{\footnote OUTS::1}
#{\footnote OUTSB::1}
#{\footnote OUTSD::1}
#{\footnote OUTSW::1}

{\fs20\b OUTS/OUTSB/OUTSD/OUTSW}\tab{\b Description}\par\par
OUTS/OUTSB/OUTSW/OUTSD: Output String to Port
\par 
\par Copies data from the source operand (second operand) to the I/O port specified with the destination operand (first operand). The source operand is a memory location, the address of which is read from either the DS:EDI or the DS:DI registers (depending on the address-size attribute of the instruction, 32 or 16, respectively). (The DS segment may be overridden with a segment override prefix.) The destination operand is an I/O port address (from 0 to 65,535) that is read from the DX register. The size of the I/O port being accessed (that is, the size of the source and destination operands) is determined by the opcode for an 8-bit I/O port or by the operand-size attribute of the instruction for a 16- or 32-bit I/O port.
\par At the assembly-code level, two forms of this instruction are allowed: the "explicit-operands" form and the "no-operands" form. The explicit-operands form (specified with the OUTS mnemonic) allows the source and destination operands to be specified explicitly. Here, the source operand should be a symbol that indicates the size of the I/O port and the source address, and the destination operand must be DX. This explicit-operands form is provided to allow documentation; however, note that the documentation provided by this form can be misleading. That is, the source operand symbol must specify the correct type (size) of the operand (byte, word, or doubleword), but it does not have to specify the correct location. The location is always specified by the DS:(E)SI registers, which must be loaded correctly before the OUTS instruction is executed.
\par The no-operands form provides "short forms" of the byte, word, and doubleword versions of the OUTS instructions. Here also DS:(E)SI is assumed to be the source operand and DX is assumed to be the destination operand. The size of the I/O port is specified with the choice of mnemonic: OUTSB (byte), OUTSW (word), or OUTSD (doubleword).
\par After the byte, word, or doubleword is transferred from the memory location to the I/O port, the (E)SI register is incremented or decremented automatically according to the setting of the DF flag in the EFLAGS register. (If the DF flag is 0, the (E)SI register is incremented; if the DF flag is 1, the (E)SI register is decremented.) The (E)SI register is incremented or decremented by 1 for byte operations, by 2 for word operations, or by 4 for doubleword operations.
\par The OUTS, OUTSB, OUTSW, and OUTSD instructions can be preceded by the REP prefix for block input of ECX bytes, words, or doublewords. See "REP/REPE/REPZ/REPNE/REPNZ--Repeat String Operation Prefix" in this help manual for a description of the REP prefix. This instruction is only useful for accessing I/O ports located in the processor's I/O address space.
\par 
\par Intel Architecture Compatibility
\par 
\par After executing an OUTS, OUTSB, OUTSW, or OUTSD instruction, the Pentium processor insures that the EWBE# pin has been sampled active before it begins to execute the next instruction. (Note that the instruction can be prefetched if EWBE# is not active, but it will not be executed until the EWBE# pin is sampled active.) Only the Pentium processor family has the EWBE# pin; the other Intel Architecture processors do not.
{\page}

${\footnote OUTS,Operation}
K{\footnote OUTS,OUTS;OUTSB,OUTSB;OUTSD,OUTSD;OUTSW,OUTSW;OUTS,Operation;OUTSB,Operation;OUTSD,Operation;OUTSW,Operation}
#{\footnote OUTS::2}
#{\footnote OUTSB::2}
#{\footnote OUTSD::2}
#{\footnote OUTSW::2}

{\fs20\b OUTS/OUTSB/OUTSD/OUTSW}\tab{\b Operation}\par\par
IF ((PE = 1) AND ((CPL > IOPL) OR (VM = 1)))
\par THEN (* Protected mode with CPL > IOPL or virtual-8086 mode *)
\par IF (Any I/O Permission Bit for I/O port being accessed = 1)
\par THEN (* I/O operation is not allowed *)
\par #GP(0);
\par ELSE ( * I/O operation is allowed *)
\par DEST <- SRC; (* Writes to I/O port *)
\par FI;
\par ELSE (Real Mode or Protected Mode with CPL  IOPL *)
\par DEST <- SRC; (* Writes to I/O port *)
\par FI;
\par IF (byte transfer)
\par THEN IF DF = 0
\par THEN (E)SI <- (E)SI + 1;
\par ELSE (E)SI <- (E)SI - 1;
\par FI;
\par ELSE IF (word transfer)
\par THEN IF DF = 0
\par THEN (E)SI <- (E)SI + 2;
\par ELSE (E)SI <- (E)SI - 2;
\par FI;
\par ELSE (* doubleword transfer *)
\par THEN IF DF = 0
\par THEN (E)SI <- (E)SI + 4;
\par ELSE (E)SI <- (E)SI - 4;
\par FI;
\par FI;
\par FI;
{\page}

${\footnote OUTS,Flags affected}
K{\footnote OUTS,OUTS;OUTSB,OUTSB;OUTSD,OUTSD;OUTSW,OUTSW;OUTS,Flags affected;OUTSB,Flags affected;OUTSD,Flags affected;OUTSW,Flags affected}
#{\footnote OUTS::3}
#{\footnote OUTSB::3}
#{\footnote OUTSD::3}
#{\footnote OUTSW::3}

{\fs20\b OUTS/OUTSB/OUTSD/OUTSW}\tab{\b Flags affected}\par\par
None.
{\page}

${\footnote OUTS,Exceptions}
K{\footnote OUTS,OUTS;OUTSB,OUTSB;OUTSD,OUTSD;OUTSW,OUTSW;OUTS,Exceptions;OUTSB,Exceptions;OUTSD,Exceptions;OUTSW,Exceptions}
#{\footnote OUTS::4}
#{\footnote OUTSB::4}
#{\footnote OUTSD::4}
#{\footnote OUTSW::4}

{\fs20\b OUTS/OUTSB/OUTSD/OUTSW}\tab{\b Exceptions}\par\par
Protected Mode Exceptions
\par 
\par #GP(0) If the CPL is greater than (has less privilege) the I/O privilege level (IOPL) and any of the corresponding I/O permission bits in TSS for the I/O port being accessed is 1. If a memory operand effective address is outside the limit of the CS, DS, ES, FS, or GS segment. If the segment register contains a null segment selector.
\par #PF(fault-code) If a page fault occurs.
\par #AC(0) If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.
\par 
\par Real-Address Mode Exceptions
\par 
\par #GP If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.
\par #SS If a memory operand effective address is outside the SS segment limit.
\par 
\par Virtual-8086 Mode Exceptions
\par 
\par #GP(0) If any of the I/O permission bits in the TSS for the I/O port being accessed is 1.
\par #PF(fault-code) If a page fault occurs.
\par #AC(0) If alignment checking is enabled and an unaligned memory reference is made.
{\page}

${\footnote OUTS,Opcode}
K{\footnote OUTS,OUTS;OUTSB,OUTSB;OUTSD,OUTSD;OUTSW,OUTSW;OUTS,Opcode;OUTSB,Opcode;OUTSD,Opcode;OUTSW,Opcode}
#{\footnote OUTS::5}
#{\footnote OUTSB::5}
#{\footnote OUTSD::5}
#{\footnote OUTSW::5}

{\fs20\b OUTS/OUTSB/OUTSD/OUTSW}\tab{\b Opcode}\par\par
6E OUTS DX, m8 Output byte from memory location specified in DS:(E)SI to I/O port specified in DX
\par 6F OUTS DX, m16 Output word from memory location specified in DS:(E)SI to I/O port specified in DX
\par 6F OUTS DX, m32 Output doubleword from memory location specified in DS:(E)SI to I/O port specified in DX
\par 6E OUTSB Output byte from memory location specified in DS:(E)SI to I/O port specified in DX
\par 6F OUTSW Output word from memory location specified in DS:(E)SI to I/O port specified in DX
\par 6F OUTSD Output doubleword from memory location specified in DS:(E)SI to I/O port specified in DX
{\page}

${\footnote PACKSSWB,Description}
K{\footnote PACKSSWB,PACKSSWB;PACKSSDW,PACKSSDW;PACKSSWB,Description;PACKSSDW,Description}
#{\footnote PACKSSWB::1}
#{\footnote PACKSSDW::1}

{\fs20\b PACKSSWB/PACKSSDW}\tab{\b Description}\par\par
PACKSSWB/PACKSSDW: Pack with Signed Saturation
\par 
\par Packs and saturates signed words into bytes (PACKSSWB) or signed doublewords into words (PACKSSDW). The PACKSSWB instruction packs 4 signed words from the destination operand (first operand) and 4 signed words from the source operand (second operand) into 8 signed bytes in the destination operand. If the signed value of a word is beyond the range of a signed byte (that is, greater than 7FH or less than 80H), the saturated byte value of 7FH or 80H, respectively, is stored into the destination.
\par The PACKSSDW instruction packs 2 signed doublewords from the destination operand (first operand) and 2 signed doublewords from the source operand (second operand) into 4 signed words in the destination operand. If the signed value of a doubleword is beyond the range of a signed word (that is, greater than 7FFFH or less than 8000H), the saturated word value of 7FFFH or 8000H, respectively, is stored into the destination. The destination operand for either the PACKSSWB or PACKSSDW instruction must be an MMX register; the source operand may be either an MMX register or a quadword memory location.
{\page}

${\footnote PACKSSWB,Operation}
K{\footnote PACKSSWB,PACKSSWB;PACKSSDW,PACKSSDW;PACKSSWB,Operation;PACKSSDW,Operation}
#{\footnote PACKSSWB::2}
#{\footnote PACKSSDW::2}

{\fs20\b PACKSSWB/PACKSSDW}\tab{\b Operation}\par\par
IF instruction is PACKSSWB
\par THEN
\par DEST(7..0) <- SaturateSignedWordToSignedByte DEST(15..0);
\par DEST(15..8) <- SaturateSignedWordToSignedByte DEST(31..16);
\par DEST(23..16) <- SaturateSignedWordToSignedByte DEST(47..32);
\par DEST(31..24) <- SaturateSignedWordToSignedByte DEST(63..48);
\par DEST(39..32) <- SaturateSignedWordToSignedByte SRC(15..0);
\par DEST(47..40) <- SaturateSignedWordToSignedByte SRC(31..16);
\par DEST(55..48) <- SaturateSignedWordToSignedByte SRC(47..32);
\par DEST(63..56) <- SaturateSignedWordToSignedByte SRC(63..48);
\par ELSE (* instruction is PACKSSDW *)
\par DEST(15..0) <- SaturateSignedDoublewordToSignedWord DEST(31..0);
\par DEST(31..16) <- SaturateSignedDoublewordToSignedWord DEST(63..32);
\par DEST(47..32) <- SaturateSignedDoublewordToSignedWord SRC(31..0);
\par DEST(63..48) <- SaturateSignedDoublewordToSignedWord SRC(63..32);
\par FI;
{\page}

${\footnote PACKSSWB,Flags affected}
K{\footnote PACKSSWB,PACKSSWB;PACKSSDW,PACKSSDW;PACKSSWB,Flags affected;PACKSSDW,Flags affected}
#{\footnote PACKSSWB::3}
#{\footnote PACKSSDW::3}

{\fs20\b PACKSSWB/PACKSSDW}\tab{\b Flags affected}\par\par
None.
{\page}

${\footnote PACKSSWB,Exceptions}
K{\footnote PACKSSWB,PACKSSWB;PACKSSDW,PACKSSDW;PACKSSWB,Exceptions;PACKSSDW,Exceptions}
#{\footnote PACKSSWB::4}
#{\footnote PACKSSDW::4}

{\fs20\b PACKSSWB/PACKSSDW}\tab{\b Exceptions}\par\par
Protected Mode Exceptions
\par 
\par #GP(0) If a memory operand effective address is outside the CS, DS, ES, FS or GS segment limit.
\par #SS(0) If a memory operand effective address is outside the SS segment limit.
\par #UD If EM in CR0 is set.
\par #NM If TS in CR0 is set.
\par #MF If there is a pending FPU exception.
\par #PF(fault-code) If a page fault occurs.
\par #AC(0) If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.
\par 
\par Real-Address Mode Exceptions
\par 
\par #GP If any part of the operand lies outside of the effective address space from 0 to FFFFH.
\par #UD If EM in CR0 is set.
\par #NM If TS in CR0 is set.
\par #MF If there is a pending FPU exception.
\par 
\par Virtual-8086 Mode Exceptions
\par 
\par #GP If any part of the operand lies outside of the effective address space from 0 to FFFFH.
\par #UD If EM in CR0 is set.
\par #NM If TS in CR0 is set.
\par #MF If there is a pending FPU exception.
\par #PF(fault-code) If a page fault occurs.
\par #AC(0) If alignment checking is enabled and an unaligned memory reference is made.
{\page}

${\footnote PACKSSWB,Opcode}
K{\footnote PACKSSWB,PACKSSWB;PACKSSDW,PACKSSDW;PACKSSWB,Opcode;PACKSSDW,Opcode}
#{\footnote PACKSSWB::5}
#{\footnote PACKSSDW::5}

{\fs20\b PACKSSWB/PACKSSDW}\tab{\b Opcode}\par\par
0F 63 /r PACKSSWB mm,mm/m64 Packs and saturate pack 4 signed words from mm and 4 signed words from mm/m64 into 8 signed bytes in mm.
\par 0F 6B /r PACKSSDW mm,mm/m64 Pack and saturate 2 signed doublewords from mm and 2 signed doublewords from mm/m64 into 4 signed words in mm.
{\page}

${\footnote PACKUSWB,Description}
K{\footnote PACKUSWB,PACKUSWB;PACKUSWB,Description}
#{\footnote PACKUSWB::1}

{\fs20\b PACKUSWB}\tab{\b Description}\par\par
PACKUSWB: Pack with Unsigned Saturation
\par 
\par Packs and saturates 4 signed words from the destination operand (first operand) and 4 signed words from the source operand (second operand) into 8 unsigned bytes in the destination operand. If the signed value of a word is beyond the range of an unsigned byte (that is, greater than FFH or less than 00H), the saturated byte value of FFH or 00H, respectively, is stored into the destination. The destination operand must be an MMX register; the source operand may be either an MMX register or a quadword memory location.
{\page}

${\footnote PACKUSWB,Operation}
K{\footnote PACKUSWB,PACKUSWB;PACKUSWB,Operation}
#{\footnote PACKUSWB::2}

{\fs20\b PACKUSWB}\tab{\b Operation}\par\par
DEST(7..0) <- SaturateSignedWordToUnsignedByte DEST(15..0);
\par DEST(15..8) <- SaturateSignedWordToUnsignedByte DEST(31..16);
\par DEST(23..16) <- SaturateSignedWordToUnsignedByte DEST(47..32);
\par DEST(31..24) <- SaturateSignedWordToUnsignedByte DEST(63..48);
\par DEST(39..32) <- SaturateSignedWordToUnsignedByte SRC(15..0);
\par DEST(47..40) <- SaturateSignedWordToUnsignedByte SRC(31..16);
\par DEST(55..48) <- SaturateSignedWordToUnsignedByte SRC(47..32);
\par DEST(63..56) <- SaturateSignedWordToUnsignedByte SRC(63..48);
{\page}

${\footnote PACKUSWB,Flags affected}
K{\footnote PACKUSWB,PACKUSWB;PACKUSWB,Flags affected}
#{\footnote PACKUSWB::3}

{\fs20\b PACKUSWB}\tab{\b Flags affected}\par\par
None.
{\page}

${\footnote PACKUSWB,Exceptions}
K{\footnote PACKUSWB,PACKUSWB;PACKUSWB,Exceptions}
#{\footnote PACKUSWB::4}

{\fs20\b PACKUSWB}\tab{\b Exceptions}\par\par
Protected Mode Exceptions
\par 
\par #GP(0) If a memory operand effective address is outside the CS, DS, ES, FS or GS segment limit.
\par #SS(0) If a memory operand effective address is outside the SS segment limit.
\par #UD If EM in CR0 is set.
\par #NM If TS in CR0 is set.
\par #MF If there is a pending FPU exception.
\par #PF(fault-code) If a page fault occurs.
\par #AC(0) If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.
\par 
\par Real-Address Mode Exceptions
\par 
\par #GP If any part of the operand lies outside of the effective address space from 0 to FFFFH.
\par #UD If EM in CR0 is set.
\par #NM If TS in CR0 is set.
\par #MF If there is a pending FPU exception.
\par 
\par Virtual-8086 Mode Exceptions
\par 
\par #GP If any part of the operand lies outside of the effective address space from 0 to FFFFH.
\par #UD If EM in CR0 is set.
\par #NM If TS in CR0 is set.
\par #MF If there is a pending FPU exception.
\par #PF(fault-code) If a page fault occurs.
\par #AC(0) If alignment checking is enabled and an unaligned memory reference is made.
{\page}

${\footnote PACKUSWB,Opcode}
K{\footnote PACKUSWB,PACKUSWB;PACKUSWB,Opcode}
#{\footnote PACKUSWB::5}

{\fs20\b PACKUSWB}\tab{\b Opcode}\par\par
0F 67 /r PACKUSWB mm, mm/m64 Pack and saturate 4 signed words from mm and 4 signed words from mm/m64 into 8 unsigned bytes in mm.
{\page}

${\footnote PADDB,Description}
K{\footnote PADDB,PADDB;PADDD,PADDD;PADDW,PADDW;PADDB,Description;PADDD,Description;PADDW,Description}
#{\footnote PADDB::1}
#{\footnote PADDD::1}
#{\footnote PADDW::1}

{\fs20\b PADDB/PADDD/PADDW}\tab{\b Description}\par\par
PADDB/PADDW/PADDD: Packed Add
\par 
\par Adds the individual data elements (bytes, words, or doublewords) of the source operand (second operand) to the individual data elements of the destination operand (first operand). If the result of an individual addition exceeds the range for the specified data type (overflows), the result is wrapped around, meaning that the result is truncated so that only the lower (least significant) bits of the result are returned (that is, the carry is ignored). The destination operand must be an MMX register; the source operand can be either an MMX register or a quadword memory location.
\par The PADDB instruction adds the bytes of the source operand to the bytes of the destination operand and stores the results to the destination operand. When an individual result is too large to be represented in 8 bits, the lower 8 bits of the result are written to the destination operand and therefore the result wraps around.
\par The PADDW instruction adds the words of the source operand to the words of the destination operand and stores the results to the destination operand. When an individual result is too large to be represented in 16 bits, the lower 16 bits of the result are written to the destination operand and therefore the result wraps around.
\par The PADDD instruction adds the doublewords of the source operand to the doublewords of the destination operand and stores the results to the destination operand. When an individual result is too large to be represented in 32 bits, the lower 32 bits of the result are written to the destination operand and therefore the result wraps around.
\par Note that like the integer ADD instruction, the PADDB, PADDW, and PADDD instructions can operate on either unsigned or signed (two's complement notation) packed integers. Unlike the integer instructions, none of the MMX instructions affect the EFLAGS register. With MMX instructions, there are no carry or overflow flags to indicate when overflow has occurred, so the software must control the range of values or else use the "with saturation" MMX instructions.
{\page}

${\footnote PADDB,Operation}
K{\footnote PADDB,PADDB;PADDD,PADDD;PADDW,PADDW;PADDB,Operation;PADDD,Operation;PADDW,Operation}
#{\footnote PADDB::2}
#{\footnote PADDD::2}
#{\footnote PADDW::2}

{\fs20\b PADDB/PADDD/PADDW}\tab{\b Operation}\par\par
IF instruction is PADDB
\par THEN
\par DEST(7..0) <- DEST(7..0) + SRC(7..0);
\par DEST(15..8) <- DEST(15..8) + SRC(15..8);
\par DEST(23..16) <- DEST(23..16)+ SRC(23..16);
\par DEST(31..24) <- DEST(31..24) + SRC(31..24);
\par DEST(39..32) <- DEST(39..32) + SRC(39..32);
\par DEST(47..40) <- DEST(47..40)+ SRC(47..40);
\par DEST(55..48) <- DEST(55..48) + SRC(55..48);
\par DEST(63..56) <- DEST(63..56) + SRC(63..56);
\par ELSEIF instruction is PADDW
\par THEN
\par DEST(15..0) <- DEST(15..0) + SRC(15..0);
\par DEST(31..16) <- DEST(31..16 ) + SRC(31..16);
\par DEST(47..32) <- DEST(47..32 ) + SRC(47..32);
\par DEST(63..48) <- DEST(63..48) + SRC(63..48);
\par ELSE (* instruction is PADDD *)
\par DEST(31..0) <- DEST(31..0) + SRC(31..0);
\par DEST(63..32) <- DEST(63..32) + SRC(63..32);
\par FI;
{\page}

${\footnote PADDB,Flags affected}
K{\footnote PADDB,PADDB;PADDD,PADDD;PADDW,PADDW;PADDB,Flags affected;PADDD,Flags affected;PADDW,Flags affected}
#{\footnote PADDB::3}
#{\footnote PADDD::3}
#{\footnote PADDW::3}

{\fs20\b PADDB/PADDD/PADDW}\tab{\b Flags affected}\par\par
None.
{\page}

${\footnote PADDB,Exceptions}
K{\footnote PADDB,PADDB;PADDD,PADDD;PADDW,PADDW;PADDB,Exceptions;PADDD,Exceptions;PADDW,Exceptions}
#{\footnote PADDB::4}
#{\footnote PADDD::4}
#{\footnote PADDW::4}

{\fs20\b PADDB/PADDD/PADDW}\tab{\b Exceptions}\par\par
Protected Mode Exceptions
\par 
\par #GP(0) If a memory operand effective address is outside the CS, DS, ES, FS or GS segment limit.
\par #SS(0) If a memory operand effective address is outside the SS segment limit.
\par #UD If EM in CR0 is set.
\par #NM If TS in CR0 is set.
\par #MF If there is a pending FPU exception.
\par #PF(fault-code) If a page fault occurs.
\par #AC(0) If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.
\par 
\par Real-Address Mode Exceptions
\par 
\par #GP If any part of the operand lies outside of the effective address space from 0 to FFFFH.
\par #UD If EM in CR0 is set.
\par #NM If TS in CR0 is set.
\par #MF If there is a pending FPU exception.
\par 
\par Virtual-8086 Mode Exceptions
\par 
\par #GP If any part of the operand lies outside of the effective address space from 0 to FFFFH.
\par #UD If EM in CR0 is set.
\par #NM If TS in CR0 is set.
\par #MF If there is a pending FPU exception.
\par #PF(fault-code) If a page fault occurs.
\par #AC(0) If alignment checking is enabled and an unaligned memory reference is made.
{\page}

${\footnote PADDB,Opcode}
K{\footnote PADDB,PADDB;PADDD,PADDD;PADDW,PADDW;PADDB,Opcode;PADDD,Opcode;PADDW,Opcode}
#{\footnote PADDB::5}
#{\footnote PADDD::5}
#{\footnote PADDW::5}

{\fs20\b PADDB/PADDD/PADDW}\tab{\b Opcode}\par\par
0F FC /r PADDB mm, mm/m64 Add packed bytes from mm/m64 to packed bytes in mm.
\par 0F FD /r PADDW mm, mm/m64 Add packed words from mm/m64 to packed words in mm.
\par 0F FE /r PADDD mm, mm/m64 Add packed doublewords from mm/m64 to packed doublewords in mm.
{\page}

${\footnote PADDSB,Description}
K{\footnote PADDSB,PADDSB;PADDSW,PADDSW;PADDSB,Description;PADDSW,Description}
#{\footnote PADDSB::1}
#{\footnote PADDSW::1}

{\fs20\b PADDSB/PADDSW}\tab{\b Description}\par\par
PADDSB/PADDSW: Packed Add with Saturation
\par 
\par Adds the individual signed data elements (bytes or words) of the source operand (second operand) to the individual signed data elements of the destination operand (first operand). If the result of an individual addition exceeds the range for the specified data type, the result is saturated. The destination operand must be an MMX register; the source operand can be either an MMX register or a quadword memory location.
\par The PADDSB instruction adds the signed bytes of the source operand to the signed bytes of the destination operand and stores the results to the destination operand. When an individual result is beyond the range of a signed byte (that is, greater than 7FH or less than 80H), the saturated byte value of 7FH or 80H, respectively, is written to the destination operand.
\par The PADDSW instruction adds the signed words of the source operand to the signed words of the destination operand and stores the results to the destination operand. When an individual result is beyond the range of a signed word (that is, greater than 7FFFH or less than 8000H), the saturated word value of 7FFFH or 8000H, respectively, is written to the destination operand.
{\page}

${\footnote PADDSB,Operation}
K{\footnote PADDSB,PADDSB;PADDSW,PADDSW;PADDSB,Operation;PADDSW,Operation}
#{\footnote PADDSB::2}
#{\footnote PADDSW::2}

{\fs20\b PADDSB/PADDSW}\tab{\b Operation}\par\par
IF instruction is PADDSB
\par THEN
\par DEST(7..0) <- SaturateToSignedByte(DEST(7..0) + SRC (7..0)) ;
\par DEST(15..8) <- SaturateToSignedByte(DEST(15..8) + SRC(15..8) );
\par DEST(23..16) <- SaturateToSignedByte(DEST(23..16)+ SRC(23..16) );
\par DEST(31..24) <- SaturateToSignedByte(DEST(31..24) + SRC(31..24) );
\par DEST(39..32) <- SaturateToSignedByte(DEST(39..32) + SRC(39..32) );
\par DEST(47..40) <- SaturateToSignedByte(DEST(47..40)+ SRC(47..40) );
\par DEST(55..48) <- SaturateToSignedByte(DEST(55..48) + SRC(55..48) );
\par DEST(63..56) <- SaturateToSignedByte(DEST(63..56) + SRC(63..56) );
\par ELSE \{ (* instruction is PADDSW *)
\par DEST(15..0) <- SaturateToSignedWord(DEST(15..0) + SRC(15..0) );
\par DEST(31..16) <- SaturateToSignedWord(DEST(31..16) + SRC(31..16) );
\par DEST(47..32) <- SaturateToSignedWord(DEST(47..32) + SRC(47..32) );
\par DEST(63..48) <- SaturateToSignedWord(DEST(63..48) + SRC(63..48) );
\par FI;
{\page}

${\footnote PADDSB,Flags affected}
K{\footnote PADDSB,PADDSB;PADDSW,PADDSW;PADDSB,Flags affected;PADDSW,Flags affected}
#{\footnote PADDSB::3}
#{\footnote PADDSW::3}

{\fs20\b PADDSB/PADDSW}\tab{\b Flags affected}\par\par
None.
{\page}

${\footnote PADDSB,Exceptions}
K{\footnote PADDSB,PADDSB;PADDSW,PADDSW;PADDSB,Exceptions;PADDSW,Exceptions}
#{\footnote PADDSB::4}
#{\footnote PADDSW::4}

{\fs20\b PADDSB/PADDSW}\tab{\b Exceptions}\par\par
Protected Mode Exceptions
\par 
\par #GP(0) If a memory operand effective address is outside the CS, DS, ES, FS or GS segment limit.
\par #SS(0) If a memory operand effective address is outside the SS segment limit.
\par #UD If EM in CR0 is set.
\par #NM If TS in CR0 is set.
\par #MF If there is a pending FPU exception.
\par #PF(fault-code) If a page fault occurs.
\par #AC(0) If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.
\par 
\par Real-Address Mode Exceptions
\par 
\par #GP If any part of the operand lies outside of the effective address space from 0 to FFFFH.
\par #UD If EM in CR0 is set.
\par #NM If TS in CR0 is set.
\par #MF If there is a pending FPU exception.
\par 
\par Virtual-8086 Mode Exceptions
\par 
\par #GP If any part of the operand lies outside of the effective address space from 0 to FFFFH.
\par #UD If EM in CR0 is set.
\par #NM If TS in CR0 is set.
\par #MF If there is a pending FPU exception.
\par #PF(fault-code) If a page fault occurs.
\par #AC(0) If alignment checking is enabled and an unaligned memory reference is made.
{\page}

${\footnote PADDSB,Opcode}
K{\footnote PADDSB,PADDSB;PADDSW,PADDSW;PADDSB,Opcode;PADDSW,Opcode}
#{\footnote PADDSB::5}
#{\footnote PADDSW::5}

{\fs20\b PADDSB/PADDSW}\tab{\b Opcode}\par\par
0F EC /r PADDSB mm, mm/m64 Add signed packed bytes from mm/m64 to signed packed bytes in mm and saturate.
\par 0F ED /r PADDSW mm, mm/m64 Add signed packed words from mm/m64 to signed packed words in mm and saturate.
{\page}

${\footnote PADDUSB,Description}
K{\footnote PADDUSB,PADDUSB;PADDUSW,PADDUSW;PADDUSB,Description;PADDUSW,Description}
#{\footnote PADDUSB::1}
#{\footnote PADDUSW::1}

{\fs20\b PADDUSB/PADDUSW}\tab{\b Description}\par\par
PADDUSB/PADDUSW: Packed Add Unsigned with Saturation
\par 
\par Adds the individual unsigned data elements (bytes or words) of the packed source operand (second operand) to the individual unsigned data elements of the packed destination operand (first operand). If the result of an individual addition exceeds the range for the specified unsigned data type, the result is saturated. The destination operand must be an MMX register; the source operand can be either an MMX register or a quadword memory location.
\par The PADDUSB instruction adds the unsigned bytes of the source operand to the unsigned bytes of the destination operand and stores the results to the destination operand. When an individual result is beyond the range of an unsigned byte (that is, greater than FFH), the saturated unsigned byte value of FFH is written to the destination operand.
\par The PADDUSW instruction adds the unsigned words of the source operand to the unsigned words of the destination operand and stores the results to the destination operand. When an individual result is beyond the range of an unsigned word (that is, greater than FFFFH), the saturated unsigned word value of FFFFH is written to the destination operand.
{\page}

${\footnote PADDUSB,Operation}
K{\footnote PADDUSB,PADDUSB;PADDUSW,PADDUSW;PADDUSB,Operation;PADDUSW,Operation}
#{\footnote PADDUSB::2}
#{\footnote PADDUSW::2}

{\fs20\b PADDUSB/PADDUSW}\tab{\b Operation}\par\par
IF instruction is PADDUSB
\par THEN
\par DEST(7..0) <- SaturateToUnsignedByte(DEST(7..0) + SRC (7..0) );
\par DEST(15..8) <- SaturateToUnsignedByte(DEST(15..8) + SRC(15..8) );
\par DEST(23..16) <- SaturateToUnsignedByte(DEST(23..16)+ SRC(23..16) );
\par DEST(31..24) <- SaturateToUnsignedByte(DEST(31..24) + SRC(31..24) );
\par DEST(39..32) <- SaturateToUnsignedByte(DEST(39..32) + SRC(39..32) );
\par DEST(47..40) <- SaturateToUnsignedByte(DEST(47..40)+ SRC(47..40) );
\par DEST(55..48) <- SaturateToUnsignedByte(DEST(55..48) + SRC(55..48) );
\par DEST(63..56) <- SaturateToUnsignedByte(DEST(63..56) + SRC(63..56) );
\par ELSE \{ (* instruction is PADDUSW *)
\par DEST(15..0) <- SaturateToUnsignedWord(DEST(15..0) + SRC(15..0) );
\par DEST(31..16) <- SaturateToUnsignedWord(DEST(31..16 ) + SRC(31..16) );
\par DEST(47..32) <- SaturateToUnsignedWord(DEST(47..32 ) + SRC(47..32) );
\par DEST(63..48) <- SaturateToUnsignedWord(DEST(63..48) + SRC(63..48) );
\par FI;
{\page}

${\footnote PADDUSB,Flags affected}
K{\footnote PADDUSB,PADDUSB;PADDUSW,PADDUSW;PADDUSB,Flags affected;PADDUSW,Flags affected}
#{\footnote PADDUSB::3}
#{\footnote PADDUSW::3}

{\fs20\b PADDUSB/PADDUSW}\tab{\b Flags affected}\par\par
None.
{\page}

${\footnote PADDUSB,Exceptions}
K{\footnote PADDUSB,PADDUSB;PADDUSW,PADDUSW;PADDUSB,Exceptions;PADDUSW,Exceptions}
#{\footnote PADDUSB::4}
#{\footnote PADDUSW::4}

{\fs20\b PADDUSB/PADDUSW}\tab{\b Exceptions}\par\par
Protected Mode Exceptions
\par 
\par #GP(0) If a memory operand effective address is outside the CS, DS, ES, FS or GS segment limit.
\par #SS(0) If a memory operand effective address is outside the SS segment limit.
\par #UD If EM in CR0 is set.
\par #NM If TS in CR0 is set.
\par #MF If there is a pending FPU exception.
\par #PF(fault-code) If a page fault occurs.
\par #AC(0) If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.
\par 
\par Real-Address Mode Exceptions
\par 
\par #GP If any part of the operand lies outside of the effective address space from 0 to FFFFH.
\par #UD If EM in CR0 is set.
\par #NM If TS in CR0 is set.
\par #MF If there is a pending FPU exception.
\par 
\par Virtual-8086 Mode Exceptions
\par 
\par #GP If any part of the operand lies outside of the effective address space from 0 to FFFFH.
\par #UD If EM in CR0 is set.
\par #NM If TS in CR0 is set.
\par #MF If there is a pending FPU exception.
\par #PF(fault-code) If a page fault occurs.
\par #AC(0) If alignment checking is enabled and an unaligned memory reference is made.
{\page}

${\footnote PADDUSB,Opcode}
K{\footnote PADDUSB,PADDUSB;PADDUSW,PADDUSW;PADDUSB,Opcode;PADDUSW,Opcode}
#{\footnote PADDUSB::5}
#{\footnote PADDUSW::5}

{\fs20\b PADDUSB/PADDUSW}\tab{\b Opcode}\par\par
0F DC /r PADDUSB mm, mm/m64 Add unsigned packed bytes from mm/m64 to unsigned packed bytes in mm and saturate.
\par 0F DD /r PADDUSW mm, mm/m64 Add unsigned packed words from mm/m64 to unsigned packed words in mm and saturate.
{\page}

${\footnote PAND,Description}
K{\footnote PAND,PAND;PAND,Description}
#{\footnote PAND::1}

{\fs20\b PAND}\tab{\b Description}\par\par
PAND: Logical AND
\par 
\par Performs a bitwise logical AND operation on the quadword source (second) and destination (first) operands and stores the result in the destination operand location. The source operand can be an MMX register or a quadword memory location; the destination operand must be an MMX register. Each bit of the result of the PAND instruction is set to 1 if the corresponding bits of the operands are both 1; otherwise it is made zero.
{\page}

${\footnote PAND,Operation}
K{\footnote PAND,PAND;PAND,Operation}
#{\footnote PAND::2}

{\fs20\b PAND}\tab{\b Operation}\par\par
DEST <- DEST AND SRC;
{\page}

${\footnote PAND,Flags affected}
K{\footnote PAND,PAND;PAND,Flags affected}
#{\footnote PAND::3}

{\fs20\b PAND}\tab{\b Flags affected}\par\par
None.
{\page}

${\footnote PAND,Exceptions}
K{\footnote PAND,PAND;PAND,Exceptions}
#{\footnote PAND::4}

{\fs20\b PAND}\tab{\b Exceptions}\par\par
Protected Mode Exceptions
\par 
\par #GP(0) If a memory operand effective address is outside the CS, DS, ES, FS or GS segment limit.
\par #SS(0) If a memory operand effective address is outside the SS segment limit.
\par #UD If EM in CR0 is set.
\par #NM If TS in CR0 is set.
\par #MF If there is a pending FPU exception.
\par #PF(fault-code) If a page fault occurs.
\par #AC(0) If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.
\par 
\par Real-Address Mode Exceptions
\par 
\par #GP If any part of the operand lies outside of the effective address space from 0 to FFFFH.
\par #UD If EM in CR0 is set.
\par #NM If TS in CR0 is set.
\par #MF If there is a pending FPU exception.
\par 
\par Virtual-8086 Mode Exceptions
\par 
\par #GP If any part of the operand lies outside of the effective address space from 0 to FFFFH.
\par #UD If EM in CR0 is set.
\par #NM If TS in CR0 is set.
\par #MF If there is a pending FPU exception.
\par #PF(fault-code) If a page fault occurs.
\par #AC(0) If alignment checking is enabled and an unaligned memory reference is made.
{\page}

${\footnote PAND,Opcode}
K{\footnote PAND,PAND;PAND,Opcode}
#{\footnote PAND::5}

{\fs20\b PAND}\tab{\b Opcode}\par\par
0F DB /r PAND mm, mm/m64 AND quadword from mm/m64 to quadword in mm.
{\page}

${\footnote PANDN,Description}
K{\footnote PANDN,PANDN;PANDN,Description}
#{\footnote PANDN::1}

{\fs20\b PANDN}\tab{\b Description}\par\par
PANDN: Logical AND NOT
\par 
\par Performs a bitwise logical NOT on the quadword destination operand (first operand). Then, the instruction performs a bitwise logical AND operation on the inverted destination operand and the quadword source operand (second operand). Each bit of the result of the AND operation is set to one if the corresponding bits of the source and inverted destination bits are one; otherwise it is set to zero. The result is stored in the destination operand location.
\par The source operand can be an MMX register or a quadword memory location; the destination operand must be an MMX register.
{\page}

${\footnote PANDN,Operation}
K{\footnote PANDN,PANDN;PANDN,Operation}
#{\footnote PANDN::2}

{\fs20\b PANDN}\tab{\b Operation}\par\par
DEST <- (NOT DEST) AND SRC;
{\page}

${\footnote PANDN,Flags affected}
K{\footnote PANDN,PANDN;PANDN,Flags affected}
#{\footnote PANDN::3}

{\fs20\b PANDN}\tab{\b Flags affected}\par\par
None.
{\page}

${\footnote PANDN,Exceptions}
K{\footnote PANDN,PANDN;PANDN,Exceptions}
#{\footnote PANDN::4}

{\fs20\b PANDN}\tab{\b Exceptions}\par\par
Protected Mode Exceptions
\par 
\par #GP(0) If a memory operand effective address is outside the CS, DS, ES, FS or GS segment limit.
\par #SS(0) If a memory operand effective address is outside the SS segment limit.
\par #UD If EM in CR0 is set.
\par #NM If TS in CR0 is set.
\par #MF If there is a pending FPU exception.
\par #PF(fault-code) If a page fault occurs.
\par #AC(0) If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.
\par 
\par Real-Address Mode Exceptions
\par 
\par #GP If any part of the operand lies outside of the effective address space from 0 to FFFFH.
\par #UD If EM in CR0 is set.
\par #NM If TS in CR0 is set.
\par #MF If there is a pending FPU exception.
\par 
\par Virtual-8086 Mode Exceptions
\par 
\par #GP If any part of the operand lies outside of the effective address space from 0 to FFFFH.
\par #UD If EM in CR0 is set.
\par #NM If TS in CR0 is set.
\par #MF If there is a pending FPU exception.
\par #PF(fault-code) If a page fault occurs.
\par #AC(0) If alignment checking is enabled and an unaligned memory reference is made.
{\page}

${\footnote PANDN,Opcode}
K{\footnote PANDN,PANDN;PANDN,Opcode}
#{\footnote PANDN::5}

{\fs20\b PANDN}\tab{\b Opcode}\par\par
0F DF /r PANDN mm, mm/m64 AND quadword from mm/m64 to NOT quadword in mm.
{\page}

${\footnote PCMPGTB,Description}
K{\footnote PCMPGTB,PCMPGTB;PCMPGTD,PCMPGTD;PCMPGTW,PCMPGTW;PCMPGTB,Description;PCMPGTD,Description;PCMPGTW,Description}
#{\footnote PCMPGTB::1}
#{\footnote PCMPGTD::1}
#{\footnote PCMPGTW::1}

{\fs20\b PCMPGTB/PCMPGTD/PCMPGTW}\tab{\b Description}\par\par
PCMPGTB/PCMPGTW/PCMPGTD: Packed Compare for Greater Than
\par 
\par Compare the individual signed data elements (bytes, words, or doublewords) in the destination operand (first operand) to the corresponding signed data elements in the source operand (second operand). If a data element in the destination operand is greater than its corresponding data element in the source operand, the data element in the destination operand is set to all ones; otherwise, it is set to all zeros. The destination operand must be an MMX register; the source operand may be either an MMX register or a 64-bit memory location.
\par The PCMPGTB instruction compares the signed bytes in the destination operand to the corresponding signed bytes in the source operand, with the bytes in the destination operand being set according to the results.
\par The PCMPGTW instruction compares the signed words in the destination operand to the corresponding signed words in the source operand, with the words in the destination operand being set according to the results.
\par The PCMPGTD instruction compares the signed doublewords in the destination operand to the corresponding signed doublewords in the source operand, with the doublewords in the destination operand being set according to the results.
{\page}

${\footnote PCMPGTB,Operation}
K{\footnote PCMPGTB,PCMPGTB;PCMPGTD,PCMPGTD;PCMPGTW,PCMPGTW;PCMPGTB,Operation;PCMPGTD,Operation;PCMPGTW,Operation}
#{\footnote PCMPGTB::2}
#{\footnote PCMPGTD::2}
#{\footnote PCMPGTW::2}

{\fs20\b PCMPGTB/PCMPGTD/PCMPGTW}\tab{\b Operation}\par\par
IF instruction is PCMPGTB
\par THEN
\par IF DEST(7..0) > SRC(7..0)
\par THEN DEST(7 0) <- FFH;
\par ELSE DEST(7..0) <- 0;
\par * Continue comparison of second through seventh bytes in DEST and SRC *
\par IF DEST(63..56) > SRC(63..56)
\par THEN DEST(63..56) <- FFH;
\par ELSE DEST(63..56) <- 0;
\par ELSE IF instruction is PCMPGTW
\par THEN
\par IF DEST(15..0) > SRC(15..0)
\par THEN DEST(15..0) <- FFFFH;
\par ELSE DEST(15..0) <-0;
\par * Continue comparison of second and third bytes in DEST and SRC *
\par IF DEST(63..48) > SRC(63..48)
\par THEN DEST(63..48) <- FFFFH;
\par ELSE DEST(63..48) <- 0;
\par ELSE \{ (* instruction is PCMPGTD *)
\par IF DEST(31..0) > SRC(31..0)
\par THEN DEST(31..0) <- FFFFFFFFH;
\par ELSE DEST(31..0) <- 0;
\par IF DEST(63..32) > SRC(63..32)
\par THEN DEST(63..32) <- FFFFFFFFH;
\par ELSE DEST(63..32) <- 0;
\par FI;
{\page}

${\footnote PCMPGTB,Flags affected}
K{\footnote PCMPGTB,PCMPGTB;PCMPGTD,PCMPGTD;PCMPGTW,PCMPGTW;PCMPGTB,Flags affected;PCMPGTD,Flags affected;PCMPGTW,Flags affected}
#{\footnote PCMPGTB::3}
#{\footnote PCMPGTD::3}
#{\footnote PCMPGTW::3}

{\fs20\b PCMPGTB/PCMPGTD/PCMPGTW}\tab{\b Flags affected}\par\par
None.
{\page}

${\footnote PCMPGTB,Exceptions}
K{\footnote PCMPGTB,PCMPGTB;PCMPGTD,PCMPGTD;PCMPGTW,PCMPGTW;PCMPGTB,Exceptions;PCMPGTD,Exceptions;PCMPGTW,Exceptions}
#{\footnote PCMPGTB::4}
#{\footnote PCMPGTD::4}
#{\footnote PCMPGTW::4}

{\fs20\b PCMPGTB/PCMPGTD/PCMPGTW}\tab{\b Exceptions}\par\par
Protected Mode Exceptions
\par 
\par #GP(0) If a memory operand effective address is outside the CS, DS, ES, FS or GS segment limit.
\par #SS(0) If a memory operand effective address is outside the SS segment limit.
\par #UD If EM in CR0 is set.
\par #NM If TS in CR0 is set.
\par #MF If there is a pending FPU exception.
\par #PF(fault-code) If a page fault occurs.
\par #AC(0) If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.
\par 
\par Real-Address Mode Exceptions
\par 
\par #GP If any part of the operand lies outside of the effective address space from 0 to FFFFH.
\par #UD If EM in CR0 is set.
\par #NM If TS in CR0 is set.
\par #MF If there is a pending FPU exception.
\par 
\par Virtual-8086 Mode Exceptions
\par 
\par #GP If any part of the operand lies outside of the effective address space from 0 to FFFFH.
\par #UD If EM in CR0 is set.
\par #NM If TS in CR0 is set.
\par #MF If there is a pending FPU exception.
\par #PF(fault-code) If a page fault occurs.
\par #AC(0) If alignment checking is enabled and an unaligned memory reference is made.
{\page}

${\footnote PCMPGTB,Opcode}
K{\footnote PCMPGTB,PCMPGTB;PCMPGTD,PCMPGTD;PCMPGTW,PCMPGTW;PCMPGTB,Opcode;PCMPGTD,Opcode;PCMPGTW,Opcode}
#{\footnote PCMPGTB::5}
#{\footnote PCMPGTD::5}
#{\footnote PCMPGTW::5}

{\fs20\b PCMPGTB/PCMPGTD/PCMPGTW}\tab{\b Opcode}\par\par
0F 64 /r PCMPGTB mm, mm/m64 Compare packed bytes in mm with packed bytes in mm/m64 for greater value.
\par 0F 65 /r PCMPGTW mm, mm/m64 Compare packed words in mm with packed words in mm/m64 for greater value.
\par 0F 66 /r PCMPGTD mm, mm/m64 Compare packed doublewords in mm with packed doublewords in mm/m64 for greater value.
{\page}

${\footnote PMADDWD,Description}
K{\footnote PMADDWD,PMADDWD;PMADDWD,Description}
#{\footnote PMADDWD::1}

{\fs20\b PMADDWD}\tab{\b Description}\par\par
PMADDWD: Packed Multiply and Add
\par 
\par Multiplies the individual signed words of the destination operand by the corresponding signed words of the source operand, producing four signed, doubleword results. The two doubleword results from the multiplication of the high-order words are added together and stored in the upper doubleword of the destination operand; the two doubleword results from the multiplication of the low-order words are added together and stored in the lower doubleword of the destination operand. The destination operand must be an MMX register; the source operand may be either an MMX register or a 64-bit memory location.
\par The PMADDWD instruction wraps around to 80000000H only when all four words of both the source and destination operands are 8000H.
{\page}

${\footnote PMADDWD,Operation}
K{\footnote PMADDWD,PMADDWD;PMADDWD,Operation}
#{\footnote PMADDWD::2}

{\fs20\b PMADDWD}\tab{\b Operation}\par\par
DEST(31..0) <- (DEST(15..0) * SRC(15..0)) + (DEST(31..16) * SRC(31..16));
\par DEST(63..32) <- (DEST(47..32) * SRC(47..32)) + (DEST(63..48) * SRC(63..48));
{\page}

${\footnote PMADDWD,Flags affected}
K{\footnote PMADDWD,PMADDWD;PMADDWD,Flags affected}
#{\footnote PMADDWD::3}

{\fs20\b PMADDWD}\tab{\b Flags affected}\par\par
None.
{\page}

${\footnote PMADDWD,Exceptions}
K{\footnote PMADDWD,PMADDWD;PMADDWD,Exceptions}
#{\footnote PMADDWD::4}

{\fs20\b PMADDWD}\tab{\b Exceptions}\par\par
Protected Mode Exceptions
\par 
\par #GP(0) If a memory operand effective address is outside the CS, DS, ES, FS or GS segment limit.
\par #SS(0) If a memory operand effective address is outside the SS segment limit.
\par #UD If EM in CR0 is set.
\par #NM If TS in CR0 is set.
\par #MF If there is a pending FPU exception.
\par #PF(fault-code) If a page fault occurs.
\par #AC(0) If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.
\par 
\par Real-Address Mode Exceptions
\par 
\par #GP If any part of the operand lies outside of the effective address space from 0 to FFFFH.
\par #UD If EM in CR0 is set.
\par #NM If TS in CR0 is set.
\par #MF If there is a pending FPU exception.
\par 
\par Virtual-8086 Mode Exceptions
\par 
\par #GP If any part of the operand lies outside of the effective address space from 0 to FFFFH.
\par #UD If EM in CR0 is set.
\par #NM If TS in CR0 is set.
\par #MF If there is a pending FPU exception.
\par #PF(fault-code) If a page fault occurs.
\par #AC(0) If alignment checking is enabled and an unaligned memory reference is made.
{\page}

${\footnote PMADDWD,Opcode}
K{\footnote PMADDWD,PMADDWD;PMADDWD,Opcode}
#{\footnote PMADDWD::5}

{\fs20\b PMADDWD}\tab{\b Opcode}\par\par
0F F5 /r PMADDWD mm, mm/m64 Multiply the packed words in mm by the packed words in mm/m64. Add the 32-bit pairs of results and store in mm as doubleword
{\page}

${\footnote PMULHW,Description}
K{\footnote PMULHW,PMULHW;PMULHW,Description}
#{\footnote PMULHW::1}

{\fs20\b PMULHW}\tab{\b Description}\par\par
PMULHW: Packed Multiply High
\par 
\par Multiplies the four signed words of the source operand (second operand) by the four signed words of the destination operand (first operand), producing four signed, doubleword, intermediate results. The high-order word of each intermediate result is then written to its corresponding word location in the destination operand. The destination operand must be an MMX register; the source operand may be either an MMX register or a 64-bit memory location.
{\page}

${\footnote PMULHW,Operation}
K{\footnote PMULHW,PMULHW;PMULHW,Operation}
#{\footnote PMULHW::2}

{\fs20\b PMULHW}\tab{\b Operation}\par\par
DEST(15..0) <- HighOrderWord(DEST(15..0) * SRC(15..0));
\par DEST(31..16) <- HighOrderWord(DEST(31..16) * SRC(31..16));
\par DEST(47..32) <- HighOrderWord(DEST(47..32) * SRC(47..32));
\par DEST(63..48) <- HighOrderWord(DEST(63..48) * SRC(63..48));
{\page}

${\footnote PMULHW,Flags affected}
K{\footnote PMULHW,PMULHW;PMULHW,Flags affected}
#{\footnote PMULHW::3}

{\fs20\b PMULHW}\tab{\b Flags affected}\par\par
None.
{\page}

${\footnote PMULHW,Exceptions}
K{\footnote PMULHW,PMULHW;PMULHW,Exceptions}
#{\footnote PMULHW::4}

{\fs20\b PMULHW}\tab{\b Exceptions}\par\par
Protected Mode Exceptions
\par 
\par #GP(0) If a memory operand effective address is outside the CS, DS, ES, FS or GS segment limit.
\par #SS(0) If a memory operand effective address is outside the SS segment limit.
\par #UD If EM in CR0 is set.
\par #NM If TS in CR0 is set.
\par #MF If there is a pending FPU exception.
\par #PF(fault-code) If a page fault occurs.
\par #AC(0) If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.
\par 
\par Real-Address Mode Exceptions
\par 
\par #GP If any part of the operand lies outside of the effective address space from 0 to FFFFH.
\par #UD If EM in CR0 is set.
\par #NM If TS in CR0 is set.
\par #MF If there is a pending FPU exception.
\par 
\par Virtual-8086 Mode Exceptions
\par 
\par #GP If any part of the operand lies outside of the effective address space from 0 to FFFFH.
\par #UD If EM in CR0 is set.
\par #NM If TS in CR0 is set.
\par #MF If there is a pending FPU exception.
\par #PF(fault-code) If a page fault occurs.
\par #AC(0) If alignment checking is enabled and an unaligned memory reference is made.
{\page}

${\footnote PMULHW,Opcode}
K{\footnote PMULHW,PMULHW;PMULHW,Opcode}
#{\footnote PMULHW::5}

{\fs20\b PMULHW}\tab{\b Opcode}\par\par
0F E5 /r PMULHW mm, mm/m64 Multiply the signed packed words in mm by the signed packed words in mm/m64, then store the high-order word of each doubleword result in mm.
{\page}

${\footnote PMULLW,Description}
K{\footnote PMULLW,PMULLW;PMULLW,Description}
#{\footnote PMULLW::1}

{\fs20\b PMULLW}\tab{\b Description}\par\par
PMULLW: Packed Multiply Low
\par 
\par Multiplies the four signed or unsigned words of the source operand (second operand) with the four signed or unsigned words of the destination operand (first operand), producing four double-word, intermediate results. The low-order word of each intermediate result is then written to its corresponding word location in the destination operand. The destination operand must be an MMX register; the source operand may be either an MMX register or a 64-bit memory location.
{\page}

${\footnote PMULLW,Operation}
K{\footnote PMULLW,PMULLW;PMULLW,Operation}
#{\footnote PMULLW::2}

{\fs20\b PMULLW}\tab{\b Operation}\par\par
DEST(15..0) <- LowOrderWord(DEST(15..0) * SRC(15..0));
\par DEST(31..16) <- LowOrderWord(DEST(31..16) * SRC(31..16));
\par DEST(47..32) <- LowOrderWord(DEST(47..32) * SRC(47..32));
\par DEST(63..48) <- LowOrderWord(DEST(63..48) * SRC(63..48));
{\page}

${\footnote PMULLW,Flags affected}
K{\footnote PMULLW,PMULLW;PMULLW,Flags affected}
#{\footnote PMULLW::3}

{\fs20\b PMULLW}\tab{\b Flags affected}\par\par
None.
{\page}

${\footnote PMULLW,Exceptions}
K{\footnote PMULLW,PMULLW;PMULLW,Exceptions}
#{\footnote PMULLW::4}

{\fs20\b PMULLW}\tab{\b Exceptions}\par\par
Protected Mode Exceptions
\par 
\par #GP(0) If a memory operand effective address is outside the CS, DS, ES, FS or GS segment limit.
\par #SS(0) If a memory operand effective address is outside the SS segment limit.
\par #UD If EM in CR0 is set.
\par #NM If TS in CR0 is set.
\par #MF If there is a pending FPU exception.
\par #PF(fault-code) If a page fault occurs.
\par #AC(0) If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.
\par 
\par Real-Address Mode Exceptions
\par 
\par #GP If any part of the operand lies outside of the effective address space from 0 to FFFFH.
\par #UD If EM in CR0 is set.
\par #NM If TS in CR0 is set.
\par #MF If there is a pending FPU exception.
\par 
\par Virtual-8086 Mode Exceptions
\par 
\par #GP If any part of the operand lies outside of the effective address space from 0 to FFFFH.
\par #UD If EM in CR0 is set.
\par #NM If TS in CR0 is set.
\par #MF If there is a pending FPU exception.
\par #PF(fault-code) If a page fault occurs.
\par #AC(0) If alignment checking is enabled and an unaligned memory reference is made.
{\page}

${\footnote PMULLW,Opcode}
K{\footnote PMULLW,PMULLW;PMULLW,Opcode}
#{\footnote PMULLW::5}

{\fs20\b PMULLW}\tab{\b Opcode}\par\par
0F D5 /r PMULLW mm, mm/m64 Multiply the packed words in mm with the packed words in mm/m64, then store the low-order word of each doubleword result in mm.
{\page}

${\footnote POP,Description}
K{\footnote POP,POP;POP,Description}
#{\footnote POP::1}

{\fs20\b POP}\tab{\b Description}\par\par
POP: Pop a Value from the Stack
\par 
\par Loads the value from the top of the stack to the location specified with the destination operand and then increments the stack pointer. The destination operand can be a general-purpose register, memory location, or segment register.
\par The address-size attribute of the stack segment determines the stack pointer size (16 bits or 32 bits--the source address size), and the operand-size attribute of the current code segment determines the amount the stack pointer is incremented (2 bytes or 4 bytes). For example, if these address- and operand-size attributes are 32, the 32-bit ESP register (stack pointer) is incremented by 4 and, if they are 16, the 16-bit SP register is incremented by 2. (The B flag in the stack segment's segment descriptor determines the stack's address-size attribute, and the D flag in the current code segment's segment descriptor, along with prefixes, determines the operand-size attribute and also the address-size attribute of the destination operand.)
\par If the destination operand is one of the segment registers DS, ES, FS, GS, or SS, the value loaded into the register must be a valid segment selector. In protected mode, popping a segment selector into a segment register automatically causes the descriptor information associated with that segment selector to be loaded into the hidden (shadow) part of the segment register and causes the selector and the descriptor information to be validated (see the "Operation" section).
\par A null value (0000-0003) may be popped into the DS, ES, FS, or GS register without causing a general protection fault. However, any subsequent attempt to reference a segment whose corresponding segment register is loaded with a null value causes a general protection exception (#GP). In this situation, no memory reference occurs and the saved value of the segment register is null. The POP instruction cannot pop a value into the CS register. To load the CS register from the stack, use the RET instruction.
\par If the ESP register is used as a base register for addressing a destination operand in memory, the POP instruction computes the effective address of the operand after it increments the ESP register.
\par The POP ESP instruction increments the stack pointer (ESP) before data at the old top of stack is written into the destination.
\par A POP SS instruction inhibits all interrupts, including the NMI interrupt, until after execution of the next instruction. This action allows sequential execution of POP SS and MOV ESP, EBP instructions without the danger of having an invalid stack during an interrupt 1 . However, use of the LSS instruction is the preferred method of loading the SS and ESP registers.
{\page}

${\footnote POP,Operation}
K{\footnote POP,POP;POP,Operation}
#{\footnote POP::2}

{\fs20\b POP}\tab{\b Operation}\par\par
IF StackAddrSize = 32
\par THEN
\par IF OperandSize = 32
\par THEN
\par DEST <- SS:ESP; (* copy a doubleword *)
\par ESP <- ESP + 4;
\par ELSE (* OperandSize = 16*)
\par DEST <- SS:ESP; (* copy a word *)
\par ESP <- ESP + 2;
\par FI;
\par ELSE (* StackAddrSize = 16* )
\par IF OperandSize = 16
\par THEN
\par DEST <- SS:SP; (* copy a word *)
\par SP <- SP + 2;
\par ELSE (* OperandSize = 32 *)
\par DEST <- SS:SP; (* copy a doubleword *)
\par SP <- SP + 4;
\par FI;
\par FI;
\par 
\par Loading a segment register while in protected mode results in special checks and actions, as described in the following listing. These checks are performed on the segment selector and the segment descriptor it points to.
\par 
\par IF SS is loaded;
\par THEN
\par IF segment selector is null
\par THEN #GP(0);
\par FI;
\par IF segment selector index is outside descriptor table limits
\par OR segment selector's RPL != CPL
\par OR segment is not a writable data segment
\par OR DPL != CPL
\par THEN #GP(selector);
\par FI;
\par IF segment not marked present
\par THEN #SS(selector);
\par ELSE
\par SS <- segment selector;
\par SS <- segment descriptor;
\par FI;
\par FI;
\par IF DS, ES, FS or GS is loaded with non-null selector;
\par THEN
\par IF segment selector index is outside descriptor table limits
\par OR segment is not a data or readable code segment
\par OR ((segment is a data or nonconforming code segment)
\par AND (both RPL and CPL > DPL))
\par THEN #GP(selector);
\par IF segment not marked present
\par THEN #NP(selector);
\par ELSE
\par SegmentRegister <- segment selector;
\par SegmentRegister <- segment descriptor;
\par FI;
\par FI;
\par IF DS, ES, FS or GS is loaded with a null selector;
\par THEN
\par SegmentRegister <- segment selector;
\par SegmentRegister <- segment descriptor;
\par FI;
\par 
\par NOTE: in a sequence of instructions that individually delay interrupts past the following instruction, only the first instruction in the sequence is guaranteed to delay the interrupt, but subsequent interrupt-delaying instructions may not delay the interrupt. Thus, in the following instruction sequence:
\par 
\par STI
\par POP SS
\par POP ESP
\par 
\par interrupts may be recognized before the POP ESP executes, because STI also delays interrupts for one instruction.
{\page}

${\footnote POP,Flags affected}
K{\footnote POP,POP;POP,Flags affected}
#{\footnote POP::3}

{\fs20\b POP}\tab{\b Flags affected}\par\par
None.
{\page}

${\footnote POP,Exceptions}
K{\footnote POP,POP;POP,Exceptions}
#{\footnote POP::4}

{\fs20\b POP}\tab{\b Exceptions}\par\par
Protected Mode Exceptions
\par 
\par #GP(0) If attempt is made to load SS register with null segment selector. If the destination operand is in a nonwritable segment. If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit. If the DS, ES, FS, or GS register is used to access memory and it contains a null segment selector.
\par #GP(selector) If segment selector index is outside descriptor table limits. If the SS register is being loaded and the segment selector's RPL and the segment descriptor's DPL are not equal to the CPL. If the SS register is being loaded and the segment pointed to is a nonwritable data segment. If the DS, ES, FS, or GS register is being loaded and the segment pointed to is not a data or readable code segment. If the DS, ES, FS, or GS register is being loaded and the segment pointed to is a data or nonconforming code segment, but both the RPL and the CPL are greater than the DPL.
\par #SS(0) If the current top of stack is not within the stack segment. If a memory operand effective address is outside the SS segment limit.
\par #SS(selector) If the SS register is being loaded and the segment pointed to is marked not present.
\par #NP If the DS, ES, FS, or GS register is being loaded and the segment pointed to is marked not present.
\par #PF(fault-code) If a page fault occurs.
\par #AC(0) If an unaligned memory reference is made while the current privilege level is 3 and alignment checking is enabled.
\par 
\par Real-Address Mode Exceptions
\par 
\par #GP If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.
\par 
\par Virtual-8086 Mode Exceptions
\par 
\par #GP(0) If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.
\par #PF(fault-code) If a page fault occurs.
\par #AC(0) If an unaligned memory reference is made while alignment checking is enabled.
{\page}

${\footnote POP,Opcode}
K{\footnote POP,POP;POP,Opcode}
#{\footnote POP::5}

{\fs20\b POP}\tab{\b Opcode}\par\par
8F /0 POP m16 Pop top of stack into m16; increment stack pointer
\par 8F /0 POP m32 Pop top of stack into m32; increment stack pointer
\par 58+ rw POP r16 Pop top of stack into r16; increment stack pointer
\par 58+ rd POP r32 Pop top of stack into r32; increment stack pointer
\par 1F POP DS Pop top of stack into DS; increment stack pointer
\par 07 POP ES Pop top of stack into ES; increment stack pointer
\par 17 POP SS Pop top of stack into SS; increment stack pointer
\par 0F A1 POP FS Pop top of stack into FS; increment stack pointer
\par 0F A9 POP GS Pop top of stack into GS; increment stack pointer
{\page}

${\footnote POPA,Description}
K{\footnote POPA,POPA;POPAD,POPAD;POPA,Description;POPAD,Description}
#{\footnote POPA::1}
#{\footnote POPAD::1}

{\fs20\b POPA/POPAD}\tab{\b Description}\par\par
POPA/POPAD: Pop All General-Purpose Registers
\par 
\par Pops doublewords (POPAD) or words (POPA) from the stack into the general-purpose registers. The registers are loaded in the following order: EDI, ESI, EBP, EBX, EDX, ECX, and EAX (if the operand-size attribute is 32) and DI, SI, BP, BX, DX, CX, and AX (if the operand-size attribute is 16). (These instructions reverse the operation of the PUSHA/PUSHAD instructions.) The value on the stack for the ESP or SP register is ignored. Instead, the ESP or SP register is incremented after each register is loaded.
\par The POPA (pop all) and POPAD (pop all double) mnemonics reference the same opcode. The POPA instruction is intended for use when the operand-size attribute is 16 and the POPAD instruction for when the operand-size attribute is 32. Some assemblers may force the operand size to 16 when POPA is used and to 32 when POPAD is used (using the operand-size override prefix [66H] if necessary). Others may treat these mnemonics as synonyms (POPA/POPAD) and use the current setting of the operand-size attribute to determine the size of values to be popped from the stack, regardless of the mnemonic used. (The D flag in the current code segment's segment descriptor determines the operand-size attribute.)
{\page}

${\footnote POPA,Operation}
K{\footnote POPA,POPA;POPAD,POPAD;POPA,Operation;POPAD,Operation}
#{\footnote POPA::2}
#{\footnote POPAD::2}

{\fs20\b POPA/POPAD}\tab{\b Operation}\par\par
IF OperandSize = 32 (* instruction = POPAD *)
\par THEN
\par EDI <- Pop();
\par ESI <- Pop();
\par EBP <- Pop();
\par increment ESP by 4 (* skip next 4 bytes of stack *)
\par EBX <- Pop();
\par EDX <- Pop();
\par ECX <- Pop();
\par EAX <- Pop();
\par ELSE (* OperandSize = 16, instruction = POPA *)
\par DI <- Pop();
\par SI <- Pop();
\par BP <- Pop();
\par increment ESP by 2 (* skip next 2 bytes of stack *)
\par BX <- Pop();
\par DX <- Pop();
\par CX <- Pop();
\par AX <- Pop();
\par FI;
{\page}

${\footnote POPA,Flags affected}
K{\footnote POPA,POPA;POPAD,POPAD;POPA,Flags affected;POPAD,Flags affected}
#{\footnote POPA::3}
#{\footnote POPAD::3}

{\fs20\b POPA/POPAD}\tab{\b Flags affected}\par\par
None.
{\page}

${\footnote POPA,Exceptions}
K{\footnote POPA,POPA;POPAD,POPAD;POPA,Exceptions;POPAD,Exceptions}
#{\footnote POPA::4}
#{\footnote POPAD::4}

{\fs20\b POPA/POPAD}\tab{\b Exceptions}\par\par
Protected Mode Exceptions
\par 
\par #SS(0) If the starting or ending stack address is not within the stack segment.
\par #PF(fault-code) If a page fault occurs.
\par #AC(0) If an unaligned memory reference is made while the current privilege level is 3 and alignment checking is enabled.
\par 
\par Real-Address Mode Exceptions
\par 
\par #SS If the starting or ending stack address is not within the stack segment.
\par 
\par Virtual-8086 Mode Exceptions
\par 
\par #SS(0) If the starting or ending stack address is not within the stack segment.
\par #PF(fault-code) If a page fault occurs.
\par #AC(0) If an unaligned memory reference is made while alignment checking is enabled.
{\page}

${\footnote POPA,Opcode}
K{\footnote POPA,POPA;POPAD,POPAD;POPA,Opcode;POPAD,Opcode}
#{\footnote POPA::5}
#{\footnote POPAD::5}

{\fs20\b POPA/POPAD}\tab{\b Opcode}\par\par
61 POPA Pop DI, SI, BP, BX, DX, CX, and AX
\par 61 POPAD Pop EDI, ESI, EBP, EBX, EDX, ECX, and EAX
{\page}

${\footnote POPF,Description}
K{\footnote POPF,POPF;POPFD,POPFD;POPF,Description;POPFD,Description}
#{\footnote POPF::1}
#{\footnote POPFD::1}

{\fs20\b POPF/POPFD}\tab{\b Description}\par\par
POPF/POPFD: Pop Stack into EFLAGS Register
\par 
\par Pops a doubleword (POPFD) from the top of the stack (if the current operand-size attribute is 32) and stores the value in the EFLAGS register or pops a word from the top of the stack (if the operand-size attribute is 16) and stores it in the lower 16 bits of the EFLAGS register (that is, the FLAGS register). (These instructions reverse the operation of the PUSHF/PUSHFD instructions.)
\par The POPF (pop flags) and POPFD (pop flags double) mnemonics reference the same opcode. The POPF instruction is intended for use when the operand-size attribute is 16 and the POPFD instruction for when the operand-size attribute is 32. Some assemblers may force the operand size to 16 when POPF is used and to 32 when POPFD is used. Others may treat these mnemonics as synonyms (POPF/POPFD) and use the current setting of the operand-size attribute to determine the size of values to be popped from the stack, regardless of the mnemonic used.
\par The effect of the POPF/POPFD instructions on the EFLAGS register changes slightly, depending on the mode of operation of the processor. When the processor is operating in protected mode at privilege level 0 (or in real-address mode, which is equivalent to privilege level 0), all the non-reserved flags in the EFLAGS register except the VIP, VIF, and VM flags can be modified. The VIP and VIF flags are cleared, and the VM flag is unaffected.
\par When operating in protected mode, with a privilege level greater than 0, but less than or equal to IOPL, all the flags can be modified except the IOPL field and the VIP, VIF, and VM flags. Here, the IOPL flags are unaffected, the VIP and VIF flags are cleared, and the VM flag is unaffected. The interrupt flag (IF) is altered only when executing at a level at least as privileged as the IOPL. If a POPF/POPFD instruction is executed with insufficient privilege, an exception does not occur, but the privileged bits do not change.
\par When operating in virtual-8086 mode, the I/O privilege level (IOPL) must be equal to 3 to use POPF/POPFD instructions and the VM, RF, IOPL, VIP, and VIF flags are unaffected. If the IOPL is less than 3, the POPF/POPFD instructions cause a general-protection exception (#GP).
{\page}

${\footnote POPF,Operation}
K{\footnote POPF,POPF;POPFD,POPFD;POPF,Operation;POPFD,Operation}
#{\footnote POPF::2}
#{\footnote POPFD::2}

{\fs20\b POPF/POPFD}\tab{\b Operation}\par\par
IF VM=0 (* Not in Virtual-8086 Mode *)
\par THEN IF CPL=0
\par THEN
\par IF OperandSize = 32;
\par THEN
\par EFLAGS <- Pop();
\par (* All non-reserved flags except VIP, VIF, and VM can be modified; *)
\par (* VIP and VIF are cleared; VM is unaffected*)
\par ELSE (* OperandSize = 16 *)
\par EFLAGS[15:0] <- Pop(); (* All non-reserved flags can be modified; *)
\par FI;
\par ELSE (* CPL > 0 *)
\par IF OperandSize = 32;
\par THEN
\par EFLAGS <- Pop()
\par (* All non-reserved bits except IOPL, VIP, and VIF can be modified; *)
\par (* IOPL is unaffected; VIP and VIF are cleared; VM is unaffected *)
\par ELSE (* OperandSize = 16 *)
\par EFLAGS[15:0] <- Pop();
\par (* All non-reserved bits except IOPL can be modified *)
\par (* IOPL is unaffected *)
\par FI;
\par FI;
\par ELSE (* In Virtual-8086 Mode *)
\par IF IOPL=3
\par THEN IF OperandSize=32
\par THEN
\par EFLAGS <- Pop()
\par (* All non-reserved bits except VM, RF, IOPL, VIP, and VIF *)
\par (* can be modified; VM, RF, IOPL, VIP, and VIF are unaffected *)
\par ELSE
\par EFLAGS[15:0] <- Pop()
\par (* All non-reserved bits except IOPL can be modified *)
\par (* IOPL is unaffected *)
\par FI;
\par ELSE (* IOPL < 3 *)
\par #GP(0); (* trap to virtual-8086 monitor *)
\par FI;
\par FI;
\par FI;
{\page}

${\footnote POPF,Flags affected}
K{\footnote POPF,POPF;POPFD,POPFD;POPF,Flags affected;POPFD,Flags affected}
#{\footnote POPF::3}
#{\footnote POPFD::3}

{\fs20\b POPF/POPFD}\tab{\b Flags affected}\par\par
All flags except the reserved bits and the VM bit.
{\page}

${\footnote POPF,Exceptions}
K{\footnote POPF,POPF;POPFD,POPFD;POPF,Exceptions;POPFD,Exceptions}
#{\footnote POPF::4}
#{\footnote POPFD::4}

{\fs20\b POPF/POPFD}\tab{\b Exceptions}\par\par
Protected Mode Exceptions
\par 
\par #SS(0) If the top of stack is not within the stack segment.
\par #PF(fault-code) If a page fault occurs.
\par #AC(0) If an unaligned memory reference is made while the current privilege level is 3 and alignment checking is enabled.
\par 
\par Real-Address Mode Exceptions
\par 
\par #SS If the top of stack is not within the stack segment.
\par 
\par Virtual-8086 Mode Exceptions
\par 
\par #GP(0) If the I/O privilege level is less than 3. If an attempt is made to execute the POPF/POPFD instruction with an operand-size override prefix.
\par #SS(0) If the top of stack is not within the stack segment.
\par #PF(fault-code) If a page fault occurs.
\par #AC(0) If an unaligned memory reference is made while alignment checking is enabled.
{\page}

${\footnote POPF,Opcode}
K{\footnote POPF,POPF;POPFD,POPFD;POPF,Opcode;POPFD,Opcode}
#{\footnote POPF::5}
#{\footnote POPFD::5}

{\fs20\b POPF/POPFD}\tab{\b Opcode}\par\par
9D POPF Pop top of stack into lower 16 bits of EFLAGS
\par 9D POPFD Pop top of stack into EFLAGS
{\page}

${\footnote POR,Description}
K{\footnote POR,POR;POR,Description}
#{\footnote POR::1}

{\fs20\b POR}\tab{\b Description}\par\par
POR: Bitwise Logical OR
\par 
\par Performs a bitwise logical OR operation on the quadword source (second) and destination (first) operands and stores the result in the destination operand location. The source operand can be an MMX register or a quadword memory location; the destination operand must be an MMX register. Each bit of the result is made 0 if the corresponding bits of both operands are 0; otherwise the bit is set to 1.
{\page}

${\footnote POR,Operation}
K{\footnote POR,POR;POR,Operation}
#{\footnote POR::2}

{\fs20\b POR}\tab{\b Operation}\par\par
DEST <- DEST OR SRC;
{\page}

${\footnote POR,Flags affected}
K{\footnote POR,POR;POR,Flags affected}
#{\footnote POR::3}

{\fs20\b POR}\tab{\b Flags affected}\par\par
None.
{\page}

${\footnote POR,Exceptions}
K{\footnote POR,POR;POR,Exceptions}
#{\footnote POR::4}

{\fs20\b POR}\tab{\b Exceptions}\par\par
Protected Mode Exceptions
\par 
\par #GP(0) If a memory operand effective address is outside the CS, DS, ES, FS or GS segment limit.
\par #SS(0) If a memory operand effective address is outside the SS segment limit.
\par #UD If EM in CR0 is set.
\par #NM If TS in CR0 is set.
\par #MF If there is a pending FPU exception.
\par #PF(fault-code) If a page fault occurs.
\par #AC(0) If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.
\par 
\par Real-Address Mode Exceptions
\par 
\par #GP If any part of the operand lies outside of the effective address space from 0 to FFFFH.
\par #UD If EM in CR0 is set.
\par #NM If TS in CR0 is set.
\par #MF If there is a pending FPU exception.
\par 
\par Virtual-8086 Mode Exceptions
\par 
\par #GP If any part of the operand lies outside of the effective address space from 0 to FFFFH.
\par #UD If EM in CR0 is set.
\par #NM If TS in CR0 is set.
\par #MF If there is a pending FPU exception.
\par #PF(fault-code) If a page fault occurs.
\par #AC(0) If alignment checking is enabled and an unaligned memory reference is made.
{\page}

${\footnote POR,Opcode}
K{\footnote POR,POR;POR,Opcode}
#{\footnote POR::5}

{\fs20\b POR}\tab{\b Opcode}\par\par
0F EB /r POR mm, mm/m64 OR quadword from mm/m64 to quadword in mm.
{\page}

${\footnote PSLLD,Description}
K{\footnote PSLLD,PSLLD;PSLLQ,PSLLQ;PSLLW,PSLLW;PSLLD,Description;PSLLQ,Description;PSLLW,Description}
#{\footnote PSLLD::1}
#{\footnote PSLLQ::1}
#{\footnote PSLLW::1}

{\fs20\b PSLLD/PSLLQ/PSLLW}\tab{\b Description}\par\par
PSLLW/PSLLD/PSLLQ: Packed Shift Left Logical
\par 
\par Shifts the bits in the data elements (words, doublewords, or quadword) in the destination operand (first operand) to the left by the number of bits specified in the unsigned count operand (second operand). The result of the shift operation is written to the destination operand. As the bits in the data elements are shifted left, the empty low-order bits are cleared (set to zero). If the value specified by the count operand is greater than 15 (for words), 31 (for doublewords), or 63 (for a quadword), then the destination operand is set to all zeros. The destination operand must be an MMX register; the count operand can be either an MMX register, a 64-bit memory location, or an 8-bit immediate.
\par The PSLLW instruction shifts each of the four words of the destination operand to the left by the number of bits specified in the count operand; the PSLLD instruction shifts each of the two doublewords of the destination operand; and the PSLLQ instruction shifts the 64-bit quadword in the destination operand. As the individual data elements are shifted left, the empty low-order bit positions are filled with zeros.
{\page}

${\footnote PSLLD,Operation}
K{\footnote PSLLD,PSLLD;PSLLQ,PSLLQ;PSLLW,PSLLW;PSLLD,Operation;PSLLQ,Operation;PSLLW,Operation}
#{\footnote PSLLD::2}
#{\footnote PSLLQ::2}
#{\footnote PSLLW::2}

{\fs20\b PSLLD/PSLLQ/PSLLW}\tab{\b Operation}\par\par
IF instruction is PSLLW
\par THEN
\par DEST(15..0) <- DEST(15..0) << COUNT;
\par DEST(31..16) <- DEST(31..16) << COUNT;
\par DEST(47..32) <- DEST(47..32) << COUNT;
\par DEST(63..48) <- DEST(63..48) << COUNT;
\par ELSE IF instruction is PSLLD
\par THEN \{
\par DEST(31..0) <- DEST(31..0) << COUNT;
\par DEST(63..32) <- DEST(63..32) << COUNT;
\par ELSE (* instruction is PSLLQ *)
\par DEST <- DEST << COUNT;
\par FI;
{\page}

${\footnote PSLLD,Flags affected}
K{\footnote PSLLD,PSLLD;PSLLQ,PSLLQ;PSLLW,PSLLW;PSLLD,Flags affected;PSLLQ,Flags affected;PSLLW,Flags affected}
#{\footnote PSLLD::3}
#{\footnote PSLLQ::3}
#{\footnote PSLLW::3}

{\fs20\b PSLLD/PSLLQ/PSLLW}\tab{\b Flags affected}\par\par
None.
{\page}

${\footnote PSLLD,Exceptions}
K{\footnote PSLLD,PSLLD;PSLLQ,PSLLQ;PSLLW,PSLLW;PSLLD,Exceptions;PSLLQ,Exceptions;PSLLW,Exceptions}
#{\footnote PSLLD::4}
#{\footnote PSLLQ::4}
#{\footnote PSLLW::4}

{\fs20\b PSLLD/PSLLQ/PSLLW}\tab{\b Exceptions}\par\par
Protected Mode Exceptions
\par 
\par #GP(0) If a memory operand effective address is outside the CS, DS, ES, FS or GS segment limit.
\par #SS(0) If a memory operand effective address is outside the SS segment limit.
\par #UD If EM in CR0 is set.
\par #NM If TS in CR0 is set.
\par #MF If there is a pending FPU exception.
\par #PF(fault-code) If a page fault occurs.
\par #AC(0) If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.
\par 
\par Real-Address Mode Exceptions
\par 
\par #GP If any part of the operand lies outside of the effective address space from 0 to FFFFH.
\par #UD If EM in CR0 is set.
\par #NM If TS in CR0 is set.
\par #MF If there is a pending FPU exception.
\par 
\par Virtual-8086 Mode Exceptions
\par 
\par #GP If any part of the operand lies outside of the effective address space from 0 to FFFFH.
\par #UD If EM in CR0 is set.
\par #NM If TS in CR0 is set.
\par #MF If there is a pending FPU exception.
\par #PF(fault-code) If a page fault occurs.
\par #AC(0) If alignment checking is enabled and an unaligned memory reference is made.
{\page}

${\footnote PSLLD,Opcode}
K{\footnote PSLLD,PSLLD;PSLLQ,PSLLQ;PSLLW,PSLLW;PSLLD,Opcode;PSLLQ,Opcode;PSLLW,Opcode}
#{\footnote PSLLD::5}
#{\footnote PSLLQ::5}
#{\footnote PSLLW::5}

{\fs20\b PSLLD/PSLLQ/PSLLW}\tab{\b Opcode}\par\par
0F F1 /r PSLLW mm, mm/m64 Shift words in mm left by amount specified in mm/m64, while shifting in zeros.
\par 0F 71 /6, ib PSLLW mm, imm8 Shift words in mm left by imm8, while shifting in zeros.
\par 0F F2 /r PSLLD mm, mm/m64 Shift doublewords in mm left by amount specified in mm/m64, while shifting in zeros.
\par 0F 72 /6 ib PSLLD mm, imm8 Shift doublewords in mm by imm8, while shifting in zeros.
\par 0F F3 /r PSLLQ mm, mm/m64 Shift mm left by amount specified in mm/m64, while shifting in zeros.
\par 0F 73 /6 ib PSLLQ mm, imm8 Shift mm left by Imm8, while shifting in zeros.
{\page}

${\footnote PSRAD,Description}
K{\footnote PSRAD,PSRAD;PSRAW,PSRAW;PSRAD,Description;PSRAW,Description}
#{\footnote PSRAD::1}
#{\footnote PSRAW::1}

{\fs20\b PSRAD/PSRAW}\tab{\b Description}\par\par
PSRAW/PSRAD: Packed Shift Right Arithmetic
\par 
\par Shifts the bits in the data elements (words or doublewords) in the destination operand (first operand) to the right by the amount of bits specified in the unsigned count operand (second operand). The result of the shift operation is written to the destination operand. The empty high-order bits of each element are filled with the initial value of the sign bit of the data element. If the value specified by the count operand is greater than 15 (for words) or 31 (for doublewords), each destination data element is filled with the initial value of the sign bit of the element. The destination operand must be an MMX register; the count operand (source operand) can be either an MMX register, a 64-bit memory location, or an 8-bit immediate.
\par The PSRAW instruction shifts each of the four words in the destination operand to the right by the number of bits specified in the count operand; the PSRAD instruction shifts each of the two doublewords in the destination operand. As the individual data elements are shifted right, the empty high-order bit positions are filled with the sign value.
{\page}

${\footnote PSRAD,Operation}
K{\footnote PSRAD,PSRAD;PSRAW,PSRAW;PSRAD,Operation;PSRAW,Operation}
#{\footnote PSRAD::2}
#{\footnote PSRAW::2}

{\fs20\b PSRAD/PSRAW}\tab{\b Operation}\par\par
IF instruction is PSRAW
\par THEN
\par DEST(15..0) <- SignExtend (DEST(15..0) >> COUNT);
\par DEST(31..16) <- SignExtend (DEST(31..16) >> COUNT);
\par DEST(47..32) <- SignExtend (DEST(47..32) >> COUNT);
\par DEST(63..48) <- SignExtend (DEST(63..48) >> COUNT);
\par ELSE \{ (*instruction is PSRAD *)
\par DEST(31..0) <- SignExtend (DEST(31..0) >> COUNT);
\par DEST(63..32) <- SignExtend (DEST(63..32) >> COUNT);
\par FI;
{\page}

${\footnote PSRAD,Flags affected}
K{\footnote PSRAD,PSRAD;PSRAW,PSRAW;PSRAD,Flags affected;PSRAW,Flags affected}
#{\footnote PSRAD::3}
#{\footnote PSRAW::3}

{\fs20\b PSRAD/PSRAW}\tab{\b Flags affected}\par\par
None.
{\page}

${\footnote PSRAD,Exceptions}
K{\footnote PSRAD,PSRAD;PSRAW,PSRAW;PSRAD,Exceptions;PSRAW,Exceptions}
#{\footnote PSRAD::4}
#{\footnote PSRAW::4}

{\fs20\b PSRAD/PSRAW}\tab{\b Exceptions}\par\par
Protected Mode Exceptions
\par 
\par #GP(0) If a memory operand effective address is outside the CS, DS, ES, FS or GS segment limit.
\par #SS(0) If a memory operand effective address is outside the SS segment limit.
\par #UD If EM in CR0 is set.
\par #NM If TS in CR0 is set.
\par #MF If there is a pending FPU exception.
\par #PF(fault-code) If a page fault occurs.
\par #AC(0) If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.
\par 
\par Real-Address Mode Exceptions
\par 
\par #GP If any part of the operand lies outside of the effective address space from 0 to FFFFH.
\par #UD If EM in CR0 is set.
\par #NM If TS in CR0 is set.
\par #MF If there is a pending FPU exception.
\par 
\par Virtual-8086 Mode Exceptions
\par 
\par #GP If any part of the operand lies outside of the effective address space from 0 to FFFFH.
\par #UD If EM in CR0 is set.
\par #NM If TS in CR0 is set.
\par #MF If there is a pending FPU exception.
\par #PF(fault-code) If a page fault occurs.
\par #AC(0) If alignment checking is enabled and an unaligned memory reference is made.
{\page}

${\footnote PSRAD,Opcode}
K{\footnote PSRAD,PSRAD;PSRAW,PSRAW;PSRAD,Opcode;PSRAW,Opcode}
#{\footnote PSRAD::5}
#{\footnote PSRAW::5}

{\fs20\b PSRAD/PSRAW}\tab{\b Opcode}\par\par
0F E1 /r PSRAW mm, mm/m64 Shift words in mm right by amount specified in mm/m64 while shifting in sign bits.
\par 0F 71 /4 ib PSRAW mm, imm8 Shift words in mm right by imm8 while shifting in sign bits
\par 0F E2 /r PSRAD mm, mm/m64 Shift doublewords in mm right by amount specified in mm/m64 while shifting in sign bits.
\par 0F 72 /4 ib PSRAD mm, imm8 Shift doublewords in mm right by imm8 while shifting in sign bits.
{\page}

${\footnote PSRLD,Description}
K{\footnote PSRLD,PSRLD;PSRLQ,PSRLQ;PSRLW,PSRLW;PSRLD,Description;PSRLQ,Description;PSRLW,Description}
#{\footnote PSRLD::1}
#{\footnote PSRLQ::1}
#{\footnote PSRLW::1}

{\fs20\b PSRLD/PSRLQ/PSRLW}\tab{\b Description}\par\par
PSRLW/PSRLD/PSRLQ: Packed Shift Right Logical
\par 
\par Shifts the bits in the data elements (words, doublewords, or quadword) in the destination operand (first operand) to the right by the number of bits specified in the unsigned count operand (second operand). The result of the shift operation is written to the destination operand. As the bits in the data elements are shifted right, the empty high-order bits are cleared (set to zero). If the value specified by the count operand is greater than 15 (for words), 31 (for doublewords), or 63 (for a quadword), then the destination operand is set to all zeros. The destination operand must be an MMX register; the count operand can be either an MMX register, a 64-bit memory location, or an 8-bit immediate.
\par The PSRLW instruction shifts each of the four words of the destination operand to the right by the number of bits specified in the count operand; the PSRLD instruction shifts each of the two doublewords of the destination operand; and the PSRLQ instruction shifts the 64-bit quadword in the destination operand. As the individual data elements are shifted right, the empty high-order bit positions are filled with zeros.
{\page}

${\footnote PSRLD,Operation}
K{\footnote PSRLD,PSRLD;PSRLQ,PSRLQ;PSRLW,PSRLW;PSRLD,Operation;PSRLQ,Operation;PSRLW,Operation}
#{\footnote PSRLD::2}
#{\footnote PSRLQ::2}
#{\footnote PSRLW::2}

{\fs20\b PSRLD/PSRLQ/PSRLW}\tab{\b Operation}\par\par
IF instruction is PSRLW
\par THEN \{
\par DEST(15..0) <- DEST(15..0) >> COUNT;
\par DEST(31..16) <- DEST(31..16) >> COUNT;
\par DEST(47..32) <- DEST(47..32) >> COUNT;
\par DEST(63..48) <- DEST(63..48) >> COUNT;
\par ELSE IF instruction is PSRLD
\par THEN \{
\par DEST(31..0) <- DEST(31..0) >> COUNT;
\par DEST(63..32) <- DEST(63..32) >> COUNT;
\par ELSE (* instruction is PSRLQ *)
\par DEST <- DEST >> COUNT;
\par FI;
{\page}

${\footnote PSRLD,Flags affected}
K{\footnote PSRLD,PSRLD;PSRLQ,PSRLQ;PSRLW,PSRLW;PSRLD,Flags affected;PSRLQ,Flags affected;PSRLW,Flags affected}
#{\footnote PSRLD::3}
#{\footnote PSRLQ::3}
#{\footnote PSRLW::3}

{\fs20\b PSRLD/PSRLQ/PSRLW}\tab{\b Flags affected}\par\par
None.
{\page}

${\footnote PSRLD,Exceptions}
K{\footnote PSRLD,PSRLD;PSRLQ,PSRLQ;PSRLW,PSRLW;PSRLD,Exceptions;PSRLQ,Exceptions;PSRLW,Exceptions}
#{\footnote PSRLD::4}
#{\footnote PSRLQ::4}
#{\footnote PSRLW::4}

{\fs20\b PSRLD/PSRLQ/PSRLW}\tab{\b Exceptions}\par\par
Protected Mode Exceptions
\par 
\par #GP(0) If a memory operand effective address is outside the CS, DS, ES, FS or GS segment limit.
\par #SS(0) If a memory operand effective address is outside the SS segment limit.
\par #UD If EM in CR0 is set.
\par #NM If TS in CR0 is set.
\par #MF If there is a pending FPU exception.
\par #PF(fault-code) If a page fault occurs.
\par #AC(0) If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.
\par 
\par Real-Address Mode Exceptions
\par 
\par #GP If any part of the operand lies outside of the effective address space from 0 to FFFFH.
\par #UD If EM in CR0 is set.
\par #NM If TS in CR0 is set.
\par #MF If there is a pending FPU exception.
\par 
\par Virtual-8086 Mode Exceptions
\par 
\par #GP If any part of the operand lies outside of the effective address space from 0 to FFFFH.
\par #UD If EM in CR0 is set.
\par #NM If TS in CR0 is set.
\par #MF If there is a pending FPU exception.
\par #PF(fault-code) If a page fault occurs.
\par #AC(0) If alignment checking is enabled and an unaligned memory reference is made.
{\page}

${\footnote PSRLD,Opcode}
K{\footnote PSRLD,PSRLD;PSRLQ,PSRLQ;PSRLW,PSRLW;PSRLD,Opcode;PSRLQ,Opcode;PSRLW,Opcode}
#{\footnote PSRLD::5}
#{\footnote PSRLQ::5}
#{\footnote PSRLW::5}

{\fs20\b PSRLD/PSRLQ/PSRLW}\tab{\b Opcode}\par\par
0F D1 /r PSRLW mm, mm/m64 Shift words in mm right by amount specified in mm/m64 while shifting in zeros.
\par 0F 71 /2 ib PSRLW mm, imm8 Shift words in mm right by imm8.
\par 0F D2 /r PSRLD mm, mm/m64 Shift doublewords in mm right by amount specified in mm/m64 while shifting in zeros.
\par 0F 72 /2 ib PSRLD mm, imm8 Shift doublewords in mm right by imm8.
\par 0F D3 /r PSRLQ mm, mm/m64 Shift mm right by amount specified in mm/m64 while shifting in zeros.
\par 0F 73 /2 ib PSRLQ mm, imm8 Shift mm right by imm8 while shifting in zeros.
{\page}

${\footnote PSUBB,Description}
K{\footnote PSUBB,PSUBB;PSUBD,PSUBD;PSUBW,PSUBW;PSUBB,Description;PSUBD,Description;PSUBW,Description}
#{\footnote PSUBB::1}
#{\footnote PSUBD::1}
#{\footnote PSUBW::1}

{\fs20\b PSUBB/PSUBD/PSUBW}\tab{\b Description}\par\par
PSUBB/PSUBW/PSUBD: Packed Subtract
\par 
\par Subtracts the individual data elements (bytes, words, or doublewords) of the source operand (second operand) from the individual data elements of the destination operand (first operand). If the result of a subtraction exceeds the range for the specified data type (overflows), the result is wrapped around, meaning that the result is truncated so that only the lower (least significant) bits of the result are returned (that is, the carry is ignored). The destination operand must be an MMX register; the source operand can be either an MMX register or a quadword memory location. The PSUBB instruction subtracts the bytes of the source operand from the bytes of the destination operand and stores the results to the destination operand. When an individual result is too large to be represented in 8 bits, the lower 8 bits of the result are written to the destination operand and therefore the result wraps around.
\par The PSUBW instruction subtracts the words of the source operand from the words of the destination operand and stores the results to the destination operand. When an individual result is too large to be represented in 16 bits, the lower 16 bits of the result are written to the destination operand and therefore the result wraps around.
\par The PSUBD instruction subtracts the doublewords of the source operand from the doublewords of the destination operand and stores the results to the destination operand. When an individual result is too large to be represented in 32 bits, the lower 32 bits of the result are written to the destination operand and therefore the result wraps around. Note that like the integer SUB instruction, the PSUBB, PSUBW, and PSUBD instructions can operate on either unsigned or signed (two's complement notation) packed integers. Unlike the integer instructions, none of the MMX instructions affect the EFLAGS register. With MMX instructions, there are no carry or overflow flags to indicate when overflow has occurred, so the software must control the range of values or else use the "with saturation" MMX instructions.
{\page}

${\footnote PSUBB,Operation}
K{\footnote PSUBB,PSUBB;PSUBD,PSUBD;PSUBW,PSUBW;PSUBB,Operation;PSUBD,Operation;PSUBW,Operation}
#{\footnote PSUBB::2}
#{\footnote PSUBD::2}
#{\footnote PSUBW::2}

{\fs20\b PSUBB/PSUBD/PSUBW}\tab{\b Operation}\par\par
IF instruction is PSUBB
\par THEN
\par DEST(7..0) <- DEST(7..0) - SRC(7..0);
\par DEST(15..8) <- DEST(15..8) - SRC(15..8);
\par DEST(23..16) <- DEST(23..16) - SRC(23..16);
\par DEST(31..24) <- DEST(31..24) - SRC(31..24);
\par DEST(39..32) <- DEST(39..32) - SRC(39..32);
\par DEST(47..40) <- DEST(47..40) - SRC(47..40);
\par DEST(55..48) <- DEST(55..48) - SRC(55..48);
\par DEST(63..56) <- DEST(63..56) - SRC(63..56);
\par ELSEIF instruction is PSUBW
\par THEN
\par DEST(15..0) <- DEST(15..0) - SRC(15..0);
\par DEST(31..16) <- DEST(31..16) - SRC(31..16);
\par DEST(47..32) <- DEST(47..32) - SRC(47..32);
\par DEST(63..48) <- DEST(63..48) - SRC(63..48);
\par ELSE \{ (* instruction is PSUBD *)
\par DEST(31..0) <- DEST(31..0) - SRC(31..0);
\par DEST(63..32) <- DEST(63..32) - SRC(63..32);
\par FI;
{\page}

${\footnote PSUBB,Flags affected}
K{\footnote PSUBB,PSUBB;PSUBD,PSUBD;PSUBW,PSUBW;PSUBB,Flags affected;PSUBD,Flags affected;PSUBW,Flags affected}
#{\footnote PSUBB::3}
#{\footnote PSUBD::3}
#{\footnote PSUBW::3}

{\fs20\b PSUBB/PSUBD/PSUBW}\tab{\b Flags affected}\par\par
None.
{\page}

${\footnote PSUBB,Exceptions}
K{\footnote PSUBB,PSUBB;PSUBD,PSUBD;PSUBW,PSUBW;PSUBB,Exceptions;PSUBD,Exceptions;PSUBW,Exceptions}
#{\footnote PSUBB::4}
#{\footnote PSUBD::4}
#{\footnote PSUBW::4}

{\fs20\b PSUBB/PSUBD/PSUBW}\tab{\b Exceptions}\par\par
Protected Mode Exceptions
\par 
\par #GP(0) If a memory operand effective address is outside the CS, DS, ES, FS or GS segment limit.
\par #SS(0) If a memory operand effective address is outside the SS segment limit.
\par #UD If EM in CR0 is set.
\par #NM If TS in CR0 is set.
\par #MF If there is a pending FPU exception.
\par #PF(fault-code) If a page fault occurs.
\par #AC(0) If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.
\par 
\par Real-Address Mode Exceptions
\par 
\par #GP If any part of the operand lies outside of the effective address space from 0 to FFFFH.
\par #UD If EM in CR0 is set.
\par #NM If TS in CR0 is set.
\par #MF If there is a pending FPU exception.
\par 
\par Virtual-8086 Mode Exceptions
\par 
\par #GP If any part of the operand lies outside of the effective address space from 0 to FFFFH.
\par #UD If EM in CR0 is set.
\par #NM If TS in CR0 is set.
\par #MF If there is a pending FPU exception.
\par #PF(fault-code) If a page fault occurs.
\par #AC(0) If alignment checking is enabled and an unaligned memory reference is made.
{\page}

${\footnote PSUBB,Opcode}
K{\footnote PSUBB,PSUBB;PSUBD,PSUBD;PSUBW,PSUBW;PSUBB,Opcode;PSUBD,Opcode;PSUBW,Opcode}
#{\footnote PSUBB::5}
#{\footnote PSUBD::5}
#{\footnote PSUBW::5}

{\fs20\b PSUBB/PSUBD/PSUBW}\tab{\b Opcode}\par\par
0F F8 /r PSUBB mm, mm/m64 Subtract packed bytes in mm/m64 from packed bytes in mm.
\par 0F F9 /r PSUBW mm, mm/m64 Subtract packed words in mm/m64 from packed words in mm.
\par 0F FA /r PSUBD mm, mm/m64 Subtract packed doublewords in mm/m64 from packed doublewords in mm.
{\page}

${\footnote PSUBSB,Description}
K{\footnote PSUBSB,PSUBSB;PSUBSW,PSUBSW;PSUBSB,Description;PSUBSW,Description}
#{\footnote PSUBSB::1}
#{\footnote PSUBSW::1}

{\fs20\b PSUBSB/PSUBSW}\tab{\b Description}\par\par
PSUBSB/PSUBSW: Packed Subtract with Saturation
\par 
\par Subtracts the individual signed data elements (bytes or words) of the source operand (second operand) from the individual signed data elements of the destination operand (first operand). If the result of a subtraction exceeds the range for the specified data type, the result is saturated. The destination operand must be an MMX register; the source operand can be either an MMX register or a quadword memory location.
\par The PSUBSB instruction subtracts the signed bytes of the source operand from the signed bytes of the destination operand and stores the results to the destination operand. When an individual result is beyond the range of a signed byte (that is, greater than 7FH or less than 80H), the saturated byte value of 7FH or 80H, respectively, is written to the destination operand.
\par The PSUBSW instruction subtracts the signed words of the source operand from the signed words of the destination operand and stores the results to the destination operand. When an individual result is beyond the range of a signed word (that is, greater than 7FFFH or less than 8000H), the saturated word value of 7FFFH or 8000H, respectively, is written to the destination operand.
{\page}

${\footnote PSUBSB,Operation}
K{\footnote PSUBSB,PSUBSB;PSUBSW,PSUBSW;PSUBSB,Operation;PSUBSW,Operation}
#{\footnote PSUBSB::2}
#{\footnote PSUBSW::2}

{\fs20\b PSUBSB/PSUBSW}\tab{\b Operation}\par\par
IF instruction is PSUBSB
\par THEN
\par DEST(7..0) <- SaturateToSignedByte(DEST(7..0) - SRC (7..0));
\par DEST(15..8) <- SaturateToSignedByte(DEST(15..8) - SRC(15..8));
\par DEST(23..16) <- SaturateToSignedByte(DEST(23..16) - SRC(23..16));
\par DEST(31..24) <- SaturateToSignedByte(DEST(31..24) - SRC(31..24));
\par DEST(39..32) <- SaturateToSignedByte(DEST(39..32) - SRC(39..32));
\par DEST(47..40) <- SaturateToSignedByte(DEST(47..40) - SRC(47..40));
\par DEST(55..48) <- SaturateToSignedByte(DEST(55..48) - SRC(55..48));
\par DEST(63..56) <- SaturateToSignedByte(DEST(63..56) - SRC(63..56));
\par ELSE (* instruction is PSUBSW *)
\par DEST(15..0) <- SaturateToSignedWord(DEST(15..0) - SRC(15..0));
\par DEST(31..16) <- SaturateToSignedWord(DEST(31..16) - SRC(31..16));
\par DEST(47..32) <- SaturateToSignedWord(DEST(47..32) - SRC(47..32));
\par DEST(63..48) <- SaturateToSignedWord(DEST(63..48) - SRC(63..48));
\par FI;
{\page}

${\footnote PSUBSB,Flags affected}
K{\footnote PSUBSB,PSUBSB;PSUBSW,PSUBSW;PSUBSB,Flags affected;PSUBSW,Flags affected}
#{\footnote PSUBSB::3}
#{\footnote PSUBSW::3}

{\fs20\b PSUBSB/PSUBSW}\tab{\b Flags affected}\par\par
None.
{\page}

${\footnote PSUBSB,Exceptions}
K{\footnote PSUBSB,PSUBSB;PSUBSW,PSUBSW;PSUBSB,Exceptions;PSUBSW,Exceptions}
#{\footnote PSUBSB::4}
#{\footnote PSUBSW::4}

{\fs20\b PSUBSB/PSUBSW}\tab{\b Exceptions}\par\par
Protected Mode Exceptions
\par 
\par #GP(0) If a memory operand effective address is outside the CS, DS, ES, FS or GS segment limit.
\par #SS(0) If a memory operand effective address is outside the SS segment limit.
\par #UD If EM in CR0 is set.
\par #NM If TS in CR0 is set.
\par #MF If there is a pending FPU exception.
\par #PF(fault-code) If a page fault occurs.
\par #AC(0) If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.
\par 
\par Real-Address Mode Exceptions
\par 
\par #GP If any part of the operand lies outside of the effective address space from 0 to FFFFH.
\par #UD If EM in CR0 is set.
\par #NM If TS in CR0 is set.
\par #MF If there is a pending FPU exception.
\par 
\par Virtual-8086 Mode Exceptions
\par 
\par #GP If any part of the operand lies outside of the effective address space from 0 to FFFFH.
\par #UD If EM in CR0 is set.
\par #NM If TS in CR0 is set.
\par #MF If there is a pending FPU exception.
\par #PF(fault-code) If a page fault occurs.
\par #AC(0) If alignment checking is enabled and an unaligned memory reference is made.
{\page}

${\footnote PSUBSB,Opcode}
K{\footnote PSUBSB,PSUBSB;PSUBSW,PSUBSW;PSUBSB,Opcode;PSUBSW,Opcode}
#{\footnote PSUBSB::5}
#{\footnote PSUBSW::5}

{\fs20\b PSUBSB/PSUBSW}\tab{\b Opcode}\par\par
0F E8 /r PSUBSB mm, mm/m64 Subtract signed packed bytes in mm/m64 from signed packed bytes in mm and saturate.
\par 0F E9 /r PSUBSW mm, mm/m64 Subtract signed packed words in mm/m64 from signed packed words in mm and saturate.
{\page}

${\footnote PSUBUSB,Description}
K{\footnote PSUBUSB,PSUBUSB;PSUBUSW,PSUBUSW;PSUBUSB,Description;PSUBUSW,Description}
#{\footnote PSUBUSB::1}
#{\footnote PSUBUSW::1}

{\fs20\b PSUBUSB/PSUBUSW}\tab{\b Description}\par\par
PSUBUSB/PSUBUSW: Packed Subtract Unsigned with Saturation
\par 
\par Subtracts the individual unsigned data elements (bytes or words) of the source operand (second operand) from the individual unsigned data elements of the destination operand (first operand). If the result of an individual subtraction exceeds the range for the specified unsigned data type, the result is saturated. The destination operand musts be an MMX register; the source operand can be either an MMX register or a quadword memory location.
\par The PSUBUSB instruction subtracts the unsigned bytes of the source operand from the unsigned bytes of the destination operand and stores the results to the destination operand. When an individual result is less than zero (a negative value), the saturated unsigned byte value of 00H is written to the destination operand.
\par The PSUBUSW instruction subtracts the unsigned words of the source operand from the unsigned words of the destination operand and stores the results to the destination operand. When an individual result is less than zero (a negative value), the saturated unsigned word value of 0000H is written to the destination operand.
{\page}

${\footnote PSUBUSB,Operation}
K{\footnote PSUBUSB,PSUBUSB;PSUBUSW,PSUBUSW;PSUBUSB,Operation;PSUBUSW,Operation}
#{\footnote PSUBUSB::2}
#{\footnote PSUBUSW::2}

{\fs20\b PSUBUSB/PSUBUSW}\tab{\b Operation}\par\par
IF instruction is PSUBUSB
\par THEN
\par DEST(7..0) <- SaturateToUnsignedByte (DEST(7..0 - SRC (7..0) );
\par DEST(15..8) <- SaturateToUnsignedByte ( DEST(15..8) - SRC(15..8) );
\par DEST(23..16) <- SaturateToUnsignedByte (DEST(23..16) - SRC(23..16) );
\par DEST(31..24) <- SaturateToUnsignedByte (DEST(31..24) - SRC(31..24) );
\par DEST(39..32) <- SaturateToUnsignedByte (DEST(39..32) - SRC(39..32) );
\par DEST(47..40) <- SaturateToUnsignedByte (DEST(47..40) - SRC(47..40) );
\par DEST(55..48) <- SaturateToUnsignedByte (DEST(55..48) - SRC(55..48) );
\par DEST(63..56) <- SaturateToUnsignedByte (DEST(63..56) - SRC(63..56) );
\par ELSE \{ (* instruction is PSUBUSW *)
\par DEST(15..0) <- SaturateToUnsignedWord (DEST(15..0) - SRC(15..0) );
\par DEST(31..16) <- SaturateToUnsignedWord (DEST(31..16) - SRC(31..16) );
\par DEST(47..32) <- SaturateToUnsignedWord (DEST(47..32) - SRC(47..32) );
\par DEST(63..48) <- SaturateToUnsignedWord (DEST(63..48) - SRC(63..48) );
\par FI;
{\page}

${\footnote PSUBUSB,Flags affected}
K{\footnote PSUBUSB,PSUBUSB;PSUBUSW,PSUBUSW;PSUBUSB,Flags affected;PSUBUSW,Flags affected}
#{\footnote PSUBUSB::3}
#{\footnote PSUBUSW::3}

{\fs20\b PSUBUSB/PSUBUSW}\tab{\b Flags affected}\par\par
None.
{\page}

${\footnote PSUBUSB,Exceptions}
K{\footnote PSUBUSB,PSUBUSB;PSUBUSW,PSUBUSW;PSUBUSB,Exceptions;PSUBUSW,Exceptions}
#{\footnote PSUBUSB::4}
#{\footnote PSUBUSW::4}

{\fs20\b PSUBUSB/PSUBUSW}\tab{\b Exceptions}\par\par
Protected Mode Exceptions
\par 
\par #GP(0) If a memory operand effective address is outside the CS, DS, ES, FS or GS segment limit.
\par #SS(0) If a memory operand effective address is outside the SS segment limit.
\par #UD If EM in CR0 is set.
\par #NM If TS in CR0 is set.
\par #MF If there is a pending FPU exception.
\par #PF(fault-code) If a page fault occurs.
\par #AC(0) If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.
\par 
\par Real-Address Mode Exceptions
\par 
\par #GP If any part of the operand lies outside of the effective address space from 0 to FFFFH.
\par #UD If EM in CR0 is set.
\par #NM If TS in CR0 is set.
\par #MF If there is a pending FPU exception.
\par 
\par Virtual-8086 Mode Exceptions
\par 
\par #GP If any part of the operand lies outside of the effective address space from 0 to FFFFH.
\par #UD If EM in CR0 is set.
\par #NM If TS in CR0 is set.
\par #MF If there is a pending FPU exception.
\par #PF(fault-code) If a page fault occurs.
\par #AC(0) If alignment checking is enabled and an unaligned memory reference is made.
{\page}

${\footnote PSUBUSB,Opcode}
K{\footnote PSUBUSB,PSUBUSB;PSUBUSW,PSUBUSW;PSUBUSB,Opcode;PSUBUSW,Opcode}
#{\footnote PSUBUSB::5}
#{\footnote PSUBUSW::5}

{\fs20\b PSUBUSB/PSUBUSW}\tab{\b Opcode}\par\par
0F D8 /r PSUBUSB mm, mm/m64 Subtract unsigned packed bytes in mm/m64 from unsigned packed bytes in mm and saturate.
\par 0F D9 /r PSUBUSW mm, mm/m64 Subtract unsigned packed words in mm/m64 from unsigned packed words in mm and saturate.
{\page}

${\footnote PUNPCKHBW,Description}
K{\footnote PUNPCKHBW,PUNPCKHBW;PUNPCKHDQ,PUNPCKHDQ;PUNPCKHWD,PUNPCKHWD;PUNPCKHBW,Description;PUNPCKHDQ,Description;PUNPCKHWD,Description}
#{\footnote PUNPCKHBW::1}
#{\footnote PUNPCKHDQ::1}
#{\footnote PUNPCKHWD::1}

{\fs20\b PUNPCKHBW/PUNPCKHDQ/PUNPCKHWD}\tab{\b Description}\par\par
PUNPCKHBW/PUNPCKHWD/PUNPCKHDQ: Unpack High Packed Data
\par 
\par Unpacks and interleaves the high-order data elements (bytes, words, or doublewords) of the destination operand (first operand) and source operand (second operand) into the destination operand. The low-order data elements are ignored. The destination operand must be an MMX register; the source operand may be either an MMX register or a 64-bit memory location. When the source data comes from a memory operand, the full 64-bit operand is accessed from memory, but the instruction uses only the high-order 32 bits.
\par The PUNPCKHBW instruction interleaves the four high-order bytes of the source operand and the four high-order bytes of the destination operand and writes them to the destination operand.
\par The PUNPCKHWD instruction interleaves the two high-order words of the source operand and the two high-order words of the destination operand and writes them to the destination operand.
\par The PUNPCKHDQ instruction interleaves the high-order doubleword of the source operand and the high-order doubleword of the destination operand and writes them to the destination operand.
\par If the source operand is all zeros, the result (stored in the destination operand) contains zero extensions of the high-order data elements from the original value in the destination operand. With the PUNPCKHBW instruction the high-order bytes are zero extended (that is, unpacked into unsigned words), and with the PUNPCKHWD instruction, the high-order words are zero extended (unpacked into unsigned doublewords).
{\page}

${\footnote PUNPCKHBW,Operation}
K{\footnote PUNPCKHBW,PUNPCKHBW;PUNPCKHDQ,PUNPCKHDQ;PUNPCKHWD,PUNPCKHWD;PUNPCKHBW,Operation;PUNPCKHDQ,Operation;PUNPCKHWD,Operation}
#{\footnote PUNPCKHBW::2}
#{\footnote PUNPCKHDQ::2}
#{\footnote PUNPCKHWD::2}

{\fs20\b PUNPCKHBW/PUNPCKHDQ/PUNPCKHWD}\tab{\b Operation}\par\par
IF instruction is PUNPCKHBW
\par THEN
\par DEST(7..0) <- DEST(39..32);
\par DEST(15..8) <- SRC(39..32);
\par DEST(23..16) <- DEST(47..40);
\par DEST(31..24) <- SRC(47..40);
\par DEST(39..32) <- DEST(55..48);
\par DEST(47..40) <- SRC(55..48);
\par DEST(55..48) <- DEST(63..56);
\par DEST(63..56) <- SRC(63..56);
\par ELSE IF instruction is PUNPCKHW
\par THEN
\par DEST(15..0) <- DEST(47..32);
\par DEST(31..16) <- SRC(47..32);
\par DEST(47..32) <- DEST(63..48);
\par DEST(63..48) <- SRC(63..48);
\par ELSE (* instruction is PUNPCKHDQ *)
\par DEST(31..0) <- DEST(63..32)
\par DEST(63..32) <- SRC(63..32);
\par FI;
{\page}

${\footnote PUNPCKHBW,Flags affected}
K{\footnote PUNPCKHBW,PUNPCKHBW;PUNPCKHDQ,PUNPCKHDQ;PUNPCKHWD,PUNPCKHWD;PUNPCKHBW,Flags affected;PUNPCKHDQ,Flags affected;PUNPCKHWD,Flags affected}
#{\footnote PUNPCKHBW::3}
#{\footnote PUNPCKHDQ::3}
#{\footnote PUNPCKHWD::3}

{\fs20\b PUNPCKHBW/PUNPCKHDQ/PUNPCKHWD}\tab{\b Flags affected}\par\par
None.
{\page}

${\footnote PUNPCKHBW,Exceptions}
K{\footnote PUNPCKHBW,PUNPCKHBW;PUNPCKHDQ,PUNPCKHDQ;PUNPCKHWD,PUNPCKHWD;PUNPCKHBW,Exceptions;PUNPCKHDQ,Exceptions;PUNPCKHWD,Exceptions}
#{\footnote PUNPCKHBW::4}
#{\footnote PUNPCKHDQ::4}
#{\footnote PUNPCKHWD::4}

{\fs20\b PUNPCKHBW/PUNPCKHDQ/PUNPCKHWD}\tab{\b Exceptions}\par\par
Protected Mode Exceptions
\par 
\par #GP(0) If a memory operand effective address is outside the CS, DS, ES, FS or GS segment limit.
\par #SS(0) If a memory operand effective address is outside the SS segment limit.
\par #UD If EM in CR0 is set.
\par #NM If TS in CR0 is set.
\par #MF If there is a pending FPU exception.
\par #PF(fault-code) If a page fault occurs.
\par #AC(0) If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.
\par 
\par Real-Address Mode Exceptions
\par 
\par #GP If any part of the operand lies outside of the effective address space from 0 to FFFFH.
\par #UD If EM in CR0 is set.
\par #NM If TS in CR0 is set.
\par #MF If there is a pending FPU exception.
\par 
\par Virtual-8086 Mode Exceptions
\par 
\par #GP If any part of the operand lies outside of the effective address space from 0 to FFFFH.
\par #UD If EM in CR0 is set.
\par #NM If TS in CR0 is set.
\par #MF If there is a pending FPU exception.
\par #PF(fault-code) If a page fault occurs.
\par #AC(0) If alignment checking is enabled and an unaligned memory reference is made.
{\page}

${\footnote PUNPCKHBW,Opcode}
K{\footnote PUNPCKHBW,PUNPCKHBW;PUNPCKHDQ,PUNPCKHDQ;PUNPCKHWD,PUNPCKHWD;PUNPCKHBW,Opcode;PUNPCKHDQ,Opcode;PUNPCKHWD,Opcode}
#{\footnote PUNPCKHBW::5}
#{\footnote PUNPCKHDQ::5}
#{\footnote PUNPCKHWD::5}

{\fs20\b PUNPCKHBW/PUNPCKHDQ/PUNPCKHWD}\tab{\b Opcode}\par\par
0F 68 /r PUNPCKHBW mm, mm/m64 Interleave high-order bytes from mm and mm/m64 into mm.
\par 0F 69 /r PUNPCKHWD mm, mm/m64 Interleave high-order words from mm and mm/m64 into mm.
\par 0F 6A /r PUNPCKHDQ mm, mm/m64 Interleave high-order doublewords from mm and mm/m64 into mm.
{\page}

${\footnote PUNPCKLBW,Description}
K{\footnote PUNPCKLBW,PUNPCKLBW;PUNPCKLDQ,PUNPCKLDQ;PUNPCKLWD,PUNPCKLWD;PUNPCKLBW,Description;PUNPCKLDQ,Description;PUNPCKLWD,Description}
#{\footnote PUNPCKLBW::1}
#{\footnote PUNPCKLDQ::1}
#{\footnote PUNPCKLWD::1}

{\fs20\b PUNPCKLBW/PUNPCKLDQ/PUNPCKLWD}\tab{\b Description}\par\par
PUNPCKLBW/PUNPCKLWD/PUNPCKLDQ: Unpack Low Packed Data
\par 
\par Unpacks and interleaves the low-order data elements (bytes, words, or doublewords) of the destination and source operands into the destination operand. The destination operand must be an MMX register; the source operand may be either an MMX register or a memory location. When source data comes from an MMX register, the upper 32 bits of the register are ignored. When the source data comes from a memory, only 32-bits are accessed from memory.
\par The PUNPCKLBW instruction interleaves the four low-order bytes of the source operand and the four low-order bytes of the destination operand and writes them to the destination operand.
\par The PUNPCKLWD instruction interleaves the two low-order words of the source operand and the two low-order words of the destination operand and writes them to the destination operand.
\par The PUNPCKLDQ instruction interleaves the low-order doubleword of the source operand and the low-order doubleword of the destination operand and writes them to the destination operand.
\par If the source operand is all zeros, the result (stored in the destination operand) contains zero extensions of the high-order data elements from the original value in the destination operand. With the PUNPCKLBW instruction the low-order bytes are zero extended (that is, unpacked into unsigned words), and with the PUNPCKLWD instruction, the low-order words are zero extended (unpacked into unsigned doublewords).
{\page}

${\footnote PUNPCKLBW,Operation}
K{\footnote PUNPCKLBW,PUNPCKLBW;PUNPCKLDQ,PUNPCKLDQ;PUNPCKLWD,PUNPCKLWD;PUNPCKLBW,Operation;PUNPCKLDQ,Operation;PUNPCKLWD,Operation}
#{\footnote PUNPCKLBW::2}
#{\footnote PUNPCKLDQ::2}
#{\footnote PUNPCKLWD::2}

{\fs20\b PUNPCKLBW/PUNPCKLDQ/PUNPCKLWD}\tab{\b Operation}\par\par
IF instruction is PUNPCKLBW
\par THEN
\par DEST(63..56) <- SRC(31..24);
\par DEST(55..48) <- DEST(31..24);
\par DEST(47..40) <- SRC(23..16);
\par DEST(39..32) <- DEST(23..16);
\par DEST(31..24) <- SRC(15..8);
\par DEST(23..16) <- DEST(15..8);
\par DEST(15..8) <- SRC(7..0);
\par DEST(7..0) <- DEST(7..0);
\par ELSE IF instruction is PUNPCKLWD
\par THEN
\par DEST(63..48) <- SRC(31..16);
\par DEST(47..32) <- DEST(31..16);
\par DEST(31..16) <- SRC(15..0);
\par DEST(15..0) <- DEST(15..0);
\par ELSE (* instruction is PUNPCKLDQ *)
\par DEST(63..32) <- SRC(31..0);
\par DEST(31..0) <- DEST(31..0);
\par FI;
{\page}

${\footnote PUNPCKLBW,Flags affected}
K{\footnote PUNPCKLBW,PUNPCKLBW;PUNPCKLDQ,PUNPCKLDQ;PUNPCKLWD,PUNPCKLWD;PUNPCKLBW,Flags affected;PUNPCKLDQ,Flags affected;PUNPCKLWD,Flags affected}
#{\footnote PUNPCKLBW::3}
#{\footnote PUNPCKLDQ::3}
#{\footnote PUNPCKLWD::3}

{\fs20\b PUNPCKLBW/PUNPCKLDQ/PUNPCKLWD}\tab{\b Flags affected}\par\par
None.
{\page}

${\footnote PUNPCKLBW,Exceptions}
K{\footnote PUNPCKLBW,PUNPCKLBW;PUNPCKLDQ,PUNPCKLDQ;PUNPCKLWD,PUNPCKLWD;PUNPCKLBW,Exceptions;PUNPCKLDQ,Exceptions;PUNPCKLWD,Exceptions}
#{\footnote PUNPCKLBW::4}
#{\footnote PUNPCKLDQ::4}
#{\footnote PUNPCKLWD::4}

{\fs20\b PUNPCKLBW/PUNPCKLDQ/PUNPCKLWD}\tab{\b Exceptions}\par\par
Protected Mode Exceptions
\par 
\par #GP(0) If a memory operand effective address is outside the CS, DS, ES, FS or GS segment limit.
\par #SS(0) If a memory operand effective address is outside the SS segment limit.
\par #UD If EM in CR0 is set.
\par #NM If TS in CR0 is set.
\par #MF If there is a pending FPU exception.
\par #PF(fault-code) If a page fault occurs.
\par #AC(0) If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.
\par 
\par Real-Address Mode Exceptions
\par 
\par #GP If any part of the operand lies outside of the effective address space from 0 to FFFFH.
\par #UD If EM in CR0 is set.
\par #NM If TS in CR0 is set.
\par #MF If there is a pending FPU exception.
\par 
\par Virtual-8086 Mode Exceptions
\par 
\par #GP If any part of the operand lies outside of the effective address space from 0 to FFFFH.
\par #UD If EM in CR0 is set.
\par #NM If TS in CR0 is set.
\par #MF If there is a pending FPU exception.
\par #PF(fault-code) If a page fault occurs.
\par #AC(0) If alignment checking is enabled and an unaligned memory reference is made.
{\page}

${\footnote PUNPCKLBW,Opcode}
K{\footnote PUNPCKLBW,PUNPCKLBW;PUNPCKLDQ,PUNPCKLDQ;PUNPCKLWD,PUNPCKLWD;PUNPCKLBW,Opcode;PUNPCKLDQ,Opcode;PUNPCKLWD,Opcode}
#{\footnote PUNPCKLBW::5}
#{\footnote PUNPCKLDQ::5}
#{\footnote PUNPCKLWD::5}

{\fs20\b PUNPCKLBW/PUNPCKLDQ/PUNPCKLWD}\tab{\b Opcode}\par\par
0F 60 /r PUNPCKLBW mm, mm/m32 Interleave low-order bytes from mm and mm/m64 into mm.
\par 0F 61 /r PUNPCKLWD mm, mm/m32 Interleave low-order words from mm and mm/m64 into mm.
\par 0F 62 /r PUNPCKLDQ mm, mm/m32 Interleave low-order doublewords from mm and mm/m64 into mm.
{\page}

${\footnote PUSH,Description}
K{\footnote PUSH,PUSH;PUSH,Description}
#{\footnote PUSH::1}

{\fs20\b PUSH}\tab{\b Description}\par\par
PUSH: Push Word or Doubleword Onto the Stack
\par 
\par Decrements the stack pointer and then stores the source operand on the top of the stack. The address-size attribute of the stack segment determines the stack pointer size (16 bits or 32 bits), and the operand-size attribute of the current code segment determines the amount the stack pointer is decremented (2 bytes or 4 bytes). For example, if these address- and operand-size attributes are 32, the 32-bit ESP register (stack pointer) is decremented by 4 and, if they are 16, the 16-bit SP register is decremented by 2.(The B flag in the stack segment's segment descriptor determines the stack's address-size attribute, and the D flag in the current code segment's segment descriptor, along with prefixes, determines the operand-size attribute and also the address-size attribute of the source operand.) Pushing a 16-bit operand when the stack address-size attribute is 32 can result in a misaligned the stack pointer (that is, the stack pointer is not aligned on a doubleword boundary).
\par The PUSH ESP instruction pushes the value of the ESP register as it existed before the instruction was executed. Thus, if a PUSH instruction uses a memory operand in which the ESP register is used as a base register for computing the operand address, the effective address of the operand is computed before the ESP register is decremented. In the real-address mode, if the ESP or SP register is 1 when the PUSH instruction is executed, the processor shuts down due to a lack of stack space. No exception is generated to indicate this condition.
\par 
\par Intel Architecture Compatibility
\par 
\par For Intel Architecture processors from the Intel 286 on, the PUSH ESP instruction pushes the value of the ESP register as it existed before the instruction was executed. (This is also true in the real-address and virtual-8086 modes.) For the Intel 8086 processor, the PUSH SP instruction pushes the new value of the SP register (that is the value after it has been decremented by 2).
{\page}

${\footnote PUSH,Operation}
K{\footnote PUSH,PUSH;PUSH,Operation}
#{\footnote PUSH::2}

{\fs20\b PUSH}\tab{\b Operation}\par\par
IF StackAddrSize = 32
\par THEN
\par IF OperandSize = 32
\par THEN
\par ESP <- ESP - 4;
\par SS:ESP <- SRC; (* push doubleword *)
\par ELSE (* OperandSize = 16*)
\par ESP <- ESP - 2;
\par SS:ESP <- SRC; (* push word *)
\par FI;
\par ELSE (* StackAddrSize = 16*)
\par IF OperandSize = 16
\par THEN
\par SP <- SP - 2;
\par SS:SP <- SRC; (* push word *)
\par ELSE (* OperandSize = 32*)
\par SP <- SP - 4;
\par SS:SP <- SRC; (* push doubleword *)
\par FI;
\par FI;
{\page}

${\footnote PUSH,Flags affected}
K{\footnote PUSH,PUSH;PUSH,Flags affected}
#{\footnote PUSH::3}

{\fs20\b PUSH}\tab{\b Flags affected}\par\par
None.
{\page}

${\footnote PUSH,Exceptions}
K{\footnote PUSH,PUSH;PUSH,Exceptions}
#{\footnote PUSH::4}

{\fs20\b PUSH}\tab{\b Exceptions}\par\par
Protected Mode Exceptions
\par 
\par #GP(0) If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit. If the DS, ES, FS, or GS register is used to access memory and it contains a null segment selector.
\par #SS(0) If a memory operand effective address is outside the SS segment limit.
\par #PF(fault-code) If a page fault occurs.
\par #AC(0) If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.
\par 
\par Real-Address Mode Exceptions
\par 
\par #GP If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.
\par #SS If a memory operand effective address is outside the SS segment limit. If the new value of the SP or ESP register is outside the stack segment limit.
\par 
\par Virtual-8086 Mode Exceptions
\par 
\par #GP(0) If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.
\par #SS(0) If a memory operand effective address is outside the SS segment limit.
\par #PF(fault-code) If a page fault occurs.
\par #AC(0) If alignment checking is enabled and an unaligned memory reference is made.
{\page}

${\footnote PUSH,Opcode}
K{\footnote PUSH,PUSH;PUSH,Opcode}
#{\footnote PUSH::5}

{\fs20\b PUSH}\tab{\b Opcode}\par\par
FF /6 PUSH r/m16 Push r/m16
\par FF /6 PUSH r/m32 Push r/m32
\par 50+ rw PUSH r16 Push r16
\par 50+ rd PUSH r32 Push r32
\par 6A PUSH imm8 Push imm8
\par 68 PUSH imm16 Push imm16
\par 68 PUSH imm32 Push imm32
\par 0E PUSH CS Push CS
\par 16 PUSH SS Push SS
\par 1E PUSH DS Push DS
\par 06 PUSH ES Push ES
\par 0F A0 PUSH FS Push FS
\par 0F A8 PUSH GS Push GS
{\page}

${\footnote PUSHA,Description}
K{\footnote PUSHA,PUSHA;PUSHAD,PUSHAD;PUSHA,Description;PUSHAD,Description}
#{\footnote PUSHA::1}
#{\footnote PUSHAD::1}

{\fs20\b PUSHA/PUSHAD}\tab{\b Description}\par\par
PUSHA/PUSHAD: Push All General-Purpose Registers
\par 
\par Pushes the contents of the general-purpose registers onto the stack. The registers are stored on the stack in the following order: EAX, ECX, EDX, EBX, EBP, ESP (original value), EBP, ESI, and EDI (if the current operand-size attribute is 32) and AX, CX, DX, BX, SP (original value), BP, SI, and DI (if the operand-size attribute is 16). (These instructions perform the reverse operation of the POPA/POPAD instructions.) The value pushed for the ESP or SP register is its value before prior to pushing the first register (see the "Operation" section).
\par The PUSHA (push all) and PUSHAD (push all double) mnemonics reference the same opcode. The PUSHA instruction is intended for use when the operand-size attribute is 16 and the PUSHAD instruction for when the operand-size attribute is 32. Some assemblers may force the operand size to 16 when PUSHA is used and to 32 when PUSHAD is used. Others may treat these mnemonics as synonyms (PUSHA/PUSHAD) and use the current setting of the operand-size attribute to determine the size of values to be pushed from the stack, regardless of the mnemonic used.
\par In the real-address mode, if the ESP or SP register is 1, 3, or 5 when the PUSHA/PUSHAD instruction is executed, the processor shuts down due to a lack of stack space. No exception is generated to indicate this condition.
{\page}

${\footnote PUSHA,Operation}
K{\footnote PUSHA,PUSHA;PUSHAD,PUSHAD;PUSHA,Operation;PUSHAD,Operation}
#{\footnote PUSHA::2}
#{\footnote PUSHAD::2}

{\fs20\b PUSHA/PUSHAD}\tab{\b Operation}\par\par
IF OperandSize = 32 (* PUSHAD instruction *)
\par THEN
\par Temp <- (ESP);
\par Push(EAX);
\par Push(ECX);
\par Push(EDX);
\par Push(EBX);
\par Push(Temp);
\par Push(EBP);
\par Push(ESI);
\par Push(EDI);
\par ELSE (* OperandSize = 16, PUSHA instruction *)
\par Temp <- (SP);
\par Push(AX);
\par Push(CX);
\par Push(DX);
\par Push(BX);
\par Push(Temp);
\par Push(BP);
\par Push(SI);
\par Push(DI);
\par FI;
{\page}

${\footnote PUSHA,Flags affected}
K{\footnote PUSHA,PUSHA;PUSHAD,PUSHAD;PUSHA,Flags affected;PUSHAD,Flags affected}
#{\footnote PUSHA::3}
#{\footnote PUSHAD::3}

{\fs20\b PUSHA/PUSHAD}\tab{\b Flags affected}\par\par
None.
{\page}

${\footnote PUSHA,Exceptions}
K{\footnote PUSHA,PUSHA;PUSHAD,PUSHAD;PUSHA,Exceptions;PUSHAD,Exceptions}
#{\footnote PUSHA::4}
#{\footnote PUSHAD::4}

{\fs20\b PUSHA/PUSHAD}\tab{\b Exceptions}\par\par
Protected Mode Exceptions
\par 
\par #SS(0) If the starting or ending stack address is outside the stack segment limit.
\par #PF(fault-code) If a page fault occurs.
\par #AC(0) If an unaligned memory reference is made while the current privilege level is 3 and alignment checking is enabled.
\par 
\par Real-Address Mode Exceptions
\par 
\par #GP If the ESP or SP register contains 7, 9, 11, 13, or 15.
\par 
\par Virtual-8086 Mode Exceptions
\par 
\par #GP(0) If the ESP or SP register contains 7, 9, 11, 13, or 15.
\par #PF(fault-code) If a page fault occurs.
\par #AC(0) If an unaligned memory reference is made while alignment checking is enabled.
{\page}

${\footnote PUSHA,Opcode}
K{\footnote PUSHA,PUSHA;PUSHAD,PUSHAD;PUSHA,Opcode;PUSHAD,Opcode}
#{\footnote PUSHA::5}
#{\footnote PUSHAD::5}

{\fs20\b PUSHA/PUSHAD}\tab{\b Opcode}\par\par
60 PUSHA Push AX, CX, DX, BX, original SP, BP, SI, and DI
\par 60 PUSHAD Push EAX, ECX, EDX, EBX, original ESP, EBP, ESI, and EDI
{\page}

${\footnote PUSHF,Description}
K{\footnote PUSHF,PUSHF;PUSHFD,PUSHFD;PUSHF,Description;PUSHFD,Description}
#{\footnote PUSHF::1}
#{\footnote PUSHFD::1}

{\fs20\b PUSHF/PUSHFD}\tab{\b Description}\par\par
PUSHF/PUSHFD: Push EFLAGS Register onto the Stack
\par 
\par Decrements the stack pointer by 4 (if the current operand-size attribute is 32) and pushes the entire contents of the EFLAGS register onto the stack, or decrements the stack pointer by 2 (if the operand-size attribute is 16) and pushes the lower 16 bits of the EFLAGS register (that is, the FLAGS register) onto the stack. (These instructions reverse the operation of the POPF/POPFD instructions.) When copying the entire EFLAGS register to the stack, the VM and RF flags (bits 16 and 17) are not copied; instead, the values for these flags are cleared in the EFLAGS image stored on the stack.
\par The PUSHF (push flags) and PUSHFD (push flags double) mnemonics reference the same opcode. The PUSHF instruction is intended for use when the operand-size attribute is 16 and the PUSHFD instruction for when the operand-size attribute is 32. Some assemblers may force the operand size to 16 when PUSHF is used and to 32 when PUSHFD is used. Others may treat these mnemonics as synonyms (PUSHF/PUSHFD) and use the current setting of the operand-size attribute to determine the size of values to be pushed from the stack, regardless of the mnemonic used.
\par When in virtual-8086 mode and the I/O privilege level (IOPL) is less than 3, the PUSHF/PUSHFD instruction causes a general protection exception (#GP). In the real-address mode, if the ESP or SP register is 1, 3, or 5 when the PUSHA/PUSHAD instruction is executed, the processor shuts down due to a lack of stack space. No exception is generated to indicate this condition.
{\page}

${\footnote PUSHF,Operation}
K{\footnote PUSHF,PUSHF;PUSHFD,PUSHFD;PUSHF,Operation;PUSHFD,Operation}
#{\footnote PUSHF::2}
#{\footnote PUSHFD::2}

{\fs20\b PUSHF/PUSHFD}\tab{\b Operation}\par\par
IF (PE=0) OR (PE=1 AND ((VM=0) OR (VM=1 AND IOPL=3)))
\par (* Real-Address Mode, Protected mode, or Virtual-8086 mode with IOPL equal to 3 *)
\par THEN
\par IF OperandSize = 32
\par THEN
\par push(EFLAGS AND 00FCFFFFH);
\par (* VM and RF EFLAG bits are cleared in image stored on the stack*)
\par ELSE
\par push(EFLAGS); (* Lower 16 bits only *)
\par FI;
\par ELSE (* In Virtual-8086 Mode with IOPL less than 0 *)
\par #GP(0); (* Trap to virtual-8086 monitor *)
\par FI;
{\page}

${\footnote PUSHF,Flags affected}
K{\footnote PUSHF,PUSHF;PUSHFD,PUSHFD;PUSHF,Flags affected;PUSHFD,Flags affected}
#{\footnote PUSHF::3}
#{\footnote PUSHFD::3}

{\fs20\b PUSHF/PUSHFD}\tab{\b Flags affected}\par\par
None.
{\page}

${\footnote PUSHF,Exceptions}
K{\footnote PUSHF,PUSHF;PUSHFD,PUSHFD;PUSHF,Exceptions;PUSHFD,Exceptions}
#{\footnote PUSHF::4}
#{\footnote PUSHFD::4}

{\fs20\b PUSHF/PUSHFD}\tab{\b Exceptions}\par\par
Protected Mode Exceptions
\par 
\par #SS(0) If the new value of the ESP register is outside the stack segment boundary.
\par #PF(fault-code) If a page fault occurs.
\par #AC(0) If an unaligned memory reference is made while the current privilege level is 3 and alignment checking is enabled.
\par 
\par Real-Address Mode Exceptions
\par 
\par None.
\par 
\par Virtual-8086 Mode Exceptions
\par 
\par #GP(0) If the I/O privilege level is less than 3.
\par #PF(fault-code) If a page fault occurs.
\par #AC(0) If an unaligned memory reference is made while alignment checking is enabled.
{\page}

${\footnote PUSHF,Opcode}
K{\footnote PUSHF,PUSHF;PUSHFD,PUSHFD;PUSHF,Opcode;PUSHFD,Opcode}
#{\footnote PUSHF::5}
#{\footnote PUSHFD::5}

{\fs20\b PUSHF/PUSHFD}\tab{\b Opcode}\par\par
9C PUSHF Push lower 16 bits of EFLAGS
\par 9C PUSHFD Push EFLAGS
{\page}

${\footnote PXOR,Description}
K{\footnote PXOR,PXOR;PXOR,Description}
#{\footnote PXOR::1}

{\fs20\b PXOR}\tab{\b Description}\par\par
PXOR: Logical Exclusive OR
\par 
\par Performs a bitwise logical exclusive-OR (XOR) operation on the quadword source (second) and destination (first) operands and stores the result in the destination operand location. The source operand can be an MMX register or a quadword memory location; the destination operand must be an MMX register. Each bit of the result is 1 if the corresponding bits of the two operands are different; each bit is 0 if the corresponding bits of the operands are the same.
{\page}

${\footnote PXOR,Operation}
K{\footnote PXOR,PXOR;PXOR,Operation}
#{\footnote PXOR::2}

{\fs20\b PXOR}\tab{\b Operation}\par\par
DEST <- DEST XOR SRC;
{\page}

${\footnote PXOR,Flags affected}
K{\footnote PXOR,PXOR;PXOR,Flags affected}
#{\footnote PXOR::3}

{\fs20\b PXOR}\tab{\b Flags affected}\par\par
None.
{\page}

${\footnote PXOR,Exceptions}
K{\footnote PXOR,PXOR;PXOR,Exceptions}
#{\footnote PXOR::4}

{\fs20\b PXOR}\tab{\b Exceptions}\par\par
Protected Mode Exceptions
\par 
\par #GP(0) If a memory operand effective address is outside the CS, DS, ES, FS or GS segment limit.
\par #SS(0) If a memory operand effective address is outside the SS segment limit.
\par #UD If EM in CR0 is set.
\par #NM If TS in CR0 is set.
\par #MF If there is a pending FPU exception.
\par #PF(fault-code) If a page fault occurs.
\par #AC(0) If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.
\par 
\par Real-Address Mode Exceptions
\par 
\par #GP If any part of the operand lies outside of the effective address space from 0 to FFFFH.
\par #UD If EM in CR0 is set.
\par #NM If TS in CR0 is set.
\par #MF If there is a pending FPU exception.
\par 
\par Virtual-8086 Mode Exceptions
\par 
\par #GP If any part of the operand lies outside of the effective address space from 0 to FFFFH.
\par #UD If EM in CR0 is set.
\par #NM If TS in CR0 is set.
\par #MF If there is a pending FPU exception.
\par #PF(fault-code) If a page fault occurs.
\par #AC(0) If alignment checking is enabled and an unaligned memory reference is made.
{\page}

${\footnote PXOR,Opcode}
K{\footnote PXOR,PXOR;PXOR,Opcode}
#{\footnote PXOR::5}

{\fs20\b PXOR}\tab{\b Opcode}\par\par
0F EF /r PXOR mm, mm/m64 XOR quadword from mm/m64 to quadword in mm.
{\page}

${\footnote RCL,Description}
K{\footnote RCL,RCL;RCR,RCR;ROL,ROL;ROR,ROR;RCL,Description;RCR,Description;ROL,Description;ROR,Description}
#{\footnote RCL::1}
#{\footnote RCR::1}
#{\footnote ROL::1}
#{\footnote ROR::1}

{\fs20\b RCL/RCR/ROL/ROR}\tab{\b Description}\par\par
RCL/RCR/ROL/ROR: Rotate
\par 
\par Shifts (rotates) the bits of the first operand (destination operand) the number of bit positions specified in the second operand (count operand) and stores the result in the destination operand. The destination operand can be a register or a memory location; the count operand is an unsigned integer that can be an immediate or a value in the CL register. The processor restricts the count to a number between 0 and 31 by masking all the bits in the count operand except the 5 least-significant bits.
\par The rotate left (ROL) and rotate through carry left (RCL) instructions shift all the bits toward more-significant bit positions, except for the most-significant bit, which is rotated to the least-significant bit location. The rotate right (ROR) and rotate through carry right (RCR) instructions shift all the bits toward less significant bit positions, except for the least-significant bit, which is rotated to the most-significant bit location.
\par The RCL and RCR instructions include the CF flag in the rotation. The RCL instruction shifts the CF flag into the least-significant bit and shifts the most-significant bit into the CF flag. The RCR instruction shifts the CF flag into the most-significant bit and shifts the least-significant bit into the CF flag. For the ROL and ROR instructions, the original value of the CF flag is not a part of the result, but the CF flag receives a copy of the bit that was shifted from one end to the other.
\par The OF flag is defined only for the 1-bit rotates; it is undefined in all other cases (except that a zero-bit rotate does nothing, that is affects no flags). For left rotates, the OF flag is set to the exclusive OR of the CF bit (after the rotate) and the most-significant bit of the result. For right rotates, the OF flag is set to the exclusive OR of the two most-significant bits of the result.
\par 
\par Intel Architecture Compatibility
\par 
\par The 8086 does not mask the rotation count. However, all other Intel Architecture processors (starting with the Intel 286 processor) do mask the rotation count to 5 bits, resulting in a maximum count of 31. This masking is done in all operating modes (including the virtual-8086 mode) to reduce the maximum execution time of the instructions.
{\page}

${\footnote RCL,Operation}
K{\footnote RCL,RCL;RCR,RCR;ROL,ROL;ROR,ROR;RCL,Operation;RCR,Operation;ROL,Operation;ROR,Operation}
#{\footnote RCL::2}
#{\footnote RCR::2}
#{\footnote ROL::2}
#{\footnote ROR::2}

{\fs20\b RCL/RCR/ROL/ROR}\tab{\b Operation}\par\par
(* RCL and RCR instructions *)
\par 
\par SIZE <- OperandSize
\par CASE (determine count) OF
\par SIZE = 8: tempCOUNT <- (COUNT AND 1FH) MOD 9;
\par SIZE = 16: tempCOUNT <- (COUNT AND 1FH) MOD 17;
\par SIZE = 32: tempCOUNT <- COUNT AND 1FH;
\par ESAC;
\par 
\par (* RCL instruction operation *)
\par 
\par WHILE (tempCOUNT != 0)
\par DO
\par tempCF <- MSB(DEST);
\par DEST <- (DEST * 2) + CF;
\par CF <- tempCF;
\par tempCOUNT <- tempCOUNT - 1;
\par OD;
\par ELIHW;
\par IF COUNT = 1
\par THEN OF <- MSB(DEST) XOR CF;
\par ELSE OF is undefined;
\par FI;
\par 
\par (* RCR instruction operation *)
\par 
\par IF COUNT = 1
\par THEN OF <- MSB(DEST) XOR CF;
\par ELSE OF is undefined;
\par FI;
\par WHILE (tempCOUNT != 0)
\par DO
\par tempCF <- LSB(SRC);
\par DEST <- (DEST / 2) + (CF * 2 SIZE );
\par CF <- tempCF;
\par tempCOUNT <- tempCOUNT - 1;
\par OD;
\par 
\par (* ROL and ROR instructions *)
\par 
\par SIZE <- OperandSize
\par CASE (determine count) OF
\par SIZE = 8: tempCOUNT <- COUNT MOD 8;
\par SIZE = 16: tempCOUNT <- COUNT MOD 16;
\par SIZE = 32: tempCOUNT <- COUNT MOD 32;
\par ESAC;
\par 
\par (* ROL instruction operation *)
\par 
\par WHILE (tempCOUNT != 0)
\par DO
\par tempCF <- MSB(DEST);
\par DEST <- (DEST * 2) + tempCF;
\par tempCOUNT <- tempCOUNT - 1;
\par OD;
\par ELIHW;
\par CF <- LSB(DEST);
\par IF COUNT = 1
\par THEN OF <- MSB(DEST) XOR CF;
\par ELSE OF is undefined;
\par FI;
\par 
\par (* ROR instruction operation *)
\par 
\par WHILE (tempCOUNT != 0)
\par DO
\par tempCF <- LSB(SRC);
\par DEST <- (DEST / 2) + (tempCF * 2 SIZE );
\par tempCOUNT <- tempCOUNT - 1;
\par OD;
\par ELIHW;
\par CF <- MSB(DEST);
\par IF COUNT = 1
\par THEN OF <- MSB(DEST) XOR MSB - 1(DEST);
\par ELSE OF is undefined;
\par FI;
{\page}

${\footnote RCL,Flags affected}
K{\footnote RCL,RCL;RCR,RCR;ROL,ROL;ROR,ROR;RCL,Flags affected;RCR,Flags affected;ROL,Flags affected;ROR,Flags affected}
#{\footnote RCL::3}
#{\footnote RCR::3}
#{\footnote ROL::3}
#{\footnote ROR::3}

{\fs20\b RCL/RCR/ROL/ROR}\tab{\b Flags affected}\par\par
The CF flag contains the value of the bit shifted into it. The OF flag is affected only for single-bit rotates (see "Description"); it is undefined for multi-bit rotates. The SF, ZF, AF, and PF flags are not affected.
{\page}

${\footnote RCL,Exceptions}
K{\footnote RCL,RCL;RCR,RCR;ROL,ROL;ROR,ROR;RCL,Exceptions;RCR,Exceptions;ROL,Exceptions;ROR,Exceptions}
#{\footnote RCL::4}
#{\footnote RCR::4}
#{\footnote ROL::4}
#{\footnote ROR::4}

{\fs20\b RCL/RCR/ROL/ROR}\tab{\b Exceptions}\par\par
Protected Mode Exceptions
\par 
\par #GP(0) If the source operand is located in a nonwritable segment. If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit. If the DS, ES, FS, or GS register contains a null segment selector.
\par #SS(0) If a memory operand effective address is outside the SS segment limit.
\par #PF(fault-code) If a page fault occurs.
\par #AC(0) If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.
\par 
\par Real-Address Mode Exceptions
\par 
\par #GP If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.
\par #SS If a memory operand effective address is outside the SS segment limit.
\par 
\par Virtual-8086 Mode Exceptions
\par 
\par #GP(0) If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.
\par #SS(0) If a memory operand effective address is outside the SS segment limit.
\par #PF(fault-code) If a page fault occurs.
\par #AC(0) If alignment checking is enabled and an unaligned memory reference is made.
{\page}

${\footnote RCL,Opcode}
K{\footnote RCL,RCL;RCR,RCR;ROL,ROL;ROR,ROR;RCL,Opcode;RCR,Opcode;ROL,Opcode;ROR,Opcode}
#{\footnote RCL::5}
#{\footnote RCR::5}
#{\footnote ROL::5}
#{\footnote ROR::5}

{\fs20\b RCL/RCR/ROL/ROR}\tab{\b Opcode}\par\par
D0 /2 RCL r/m8,1 Rotate 9 bits (CF, r/m8) left once
\par D2 /2 RCL r/m8,CL Rotate 9 bits (CF, r/m8) left CL times
\par C0 /2 ib RCL r/m8,imm8 Rotate 9 bits (CF, r/m8) left imm8 times
\par D1 /2 RCL r/m16,1 Rotate 17 bits (CF, r/m16) left once
\par D3 /2 RCL r/m16,CL Rotate 17 bits (CF, r/m16) left CL times
\par C1 /2 ib RCL r/m16,imm8 Rotate 17 bits (CF, r/m16) left imm8 times
\par D1 /2 RCL r/m32,1 Rotate 33 bits (CF, r/m32) left once
\par D3 /2 RCL r/m32,CL Rotate 33 bits (CF, r/m32) left CL times
\par C1 /2 ib RCL r/m32,imm8 Rotate 33 bits (CF, r/m32) left imm8 times
\par D0 /3 RCR r/m8,1 Rotate 9 bits (CF, r/m8) right once
\par D2 /3 RCR r/m8,CL Rotate 9 bits (CF, r/m8) right CL times
\par C0 /3 ib RCR r/m8,imm8 Rotate 9 bits (CF, r/m8) right imm8 times
\par D1 /3 RCR r/m16,1 Rotate 17 bits (CF, r/m16) right once
\par D3 /3 RCR r/m16,CL Rotate 17 bits (CF, r/m16) right CL times
\par C1 /3 ib RCR r/m16,imm8 Rotate 17 bits (CF, r/m16) right imm8 times
\par D1 /3 RCR r/m32,1 Rotate 33 bits (CF, r/m32) right once
\par D3 /3 RCR r/m32,CL Rotate 33 bits (CF, r/m32) right CL times
\par C1 /3 ib RCR r/m32,imm8 Rotate 33 bits (CF, r/m32) right imm8 times
\par D0 /0 ROL r/m8,1 Rotate 8 bits r/m8 left once
\par D2 /0 ROL r/m8,CL Rotate 8 bits r/m8 left CL times
\par C0 /0 ib ROL r/m8,imm8 Rotate 8 bits r/m8 left imm8 times
\par D1 /0 ROL r/m16,1 Rotate 16 bits r/m16 left once
\par D3 /0 ROL r/m16,CL Rotate 16 bits r/m16 left CL times
\par C1 /0 ib ROL r/m16,imm8 Rotate 16 bits r/m16 left imm8 times
\par D1 /0 ROL r/m32,1 Rotate 32 bits r/m32 left once
\par D3 /0 ROL r/m32,CL Rotate 32 bits r/m32 left CL times
\par C1 /0 ib ROL r/m32,imm8 Rotate 32 bits r/m32 left imm8 times
\par D0 /1 ROR r/m8,1 Rotate 8 bits r/m8 right once
\par D2 /1 ROR r/m8,CL Rotate 8 bits r/m8 right CL times
\par C0 /1 ib ROR r/m8,imm8 Rotate 8 bits r/m16 right imm8 times
\par D1 /1 ROR r/m16,1 Rotate 16 bits r/m16 right once
\par D3 /1 ROR r/m16,CL Rotate 16 bits r/m16 right CL times
\par C1 /1 ib ROR r/m16,imm8 Rotate 16 bits r/m16 right imm8 times
\par D1 /1 ROR r/m32,1 Rotate 32 bits r/m32 right once
\par D3 /1 ROR r/m32,CL Rotate 32 bits r/m32 right CL times
\par C1 /1 ib ROR r/m32,imm8 Rotate 32 bits r/m32 right imm8 times
{\page}

${\footnote RDMSR,Description}
K{\footnote RDMSR,RDMSR;RDMSR,Description}
#{\footnote RDMSR::1}

{\fs20\b RDMSR}\tab{\b Description}\par\par
RDMSR: Read from Model Specific Register
\par 
\par Loads the contents of a 64-bit model specific register (MSR) specified in the ECX register into registers EDX:EAX. The EDX register is loaded with the high-order 32 bits of the MSR and the EAX register is loaded with the low-order 32 bits. If less than 64 bits are implemented in the MSR being read, the values returned to EDX:EAX in unimplemented bit locations are undefined. This instruction must be executed at privilege level 0 or in real-address mode; otherwise, a general protection exception #GP(0) will be generated. Specifying a reserved or unimplemented MSR address in ECX will also cause a general protection exception.
\par The MSRs control functions for testability, execution tracing, performance-monitoring and machine check errors. The CPUID instruction should be used to determine whether MSRs are supported (EDX[5]=1) before using this instruction.
\par 
\par Intel Architecture Compatibility
\par 
\par The MSRs and the ability to read them with the RDMSR instruction were introduced into the Intel Architecture with the Pentium processor. Execution of this instruction by an Intel Architecture processor earlier than the Pentium processor results in an invalid opcode exception #UD.
{\page}

${\footnote RDMSR,Operation}
K{\footnote RDMSR,RDMSR;RDMSR,Operation}
#{\footnote RDMSR::2}

{\fs20\b RDMSR}\tab{\b Operation}\par\par
EDX:EAX <- MSR[ECX];
{\page}

${\footnote RDMSR,Flags affected}
K{\footnote RDMSR,RDMSR;RDMSR,Flags affected}
#{\footnote RDMSR::3}

{\fs20\b RDMSR}\tab{\b Flags affected}\par\par
None.
{\page}

${\footnote RDMSR,Exceptions}
K{\footnote RDMSR,RDMSR;RDMSR,Exceptions}
#{\footnote RDMSR::4}

{\fs20\b RDMSR}\tab{\b Exceptions}\par\par
Protected Mode Exceptions
\par 
\par #GP(0) If the current privilege level is not 0. If the value in ECX specifies a reserved or unimplemented MSR address.
\par 
\par Real-Address Mode Exceptions
\par 
\par #GP If the value in ECX specifies a reserved or unimplemented MSR address.
\par 
\par Virtual-8086 Mode Exceptions
\par 
\par #GP(0) The RDMSR instruction is not recognized in virtual-8086 mode.
{\page}

${\footnote RDMSR,Opcode}
K{\footnote RDMSR,RDMSR;RDMSR,Opcode}
#{\footnote RDMSR::5}

{\fs20\b RDMSR}\tab{\b Opcode}\par\par
0F 32 RDMSR Load MSR specified by ECX into EDX:EAX
{\page}

${\footnote RDPMC,Description}
K{\footnote RDPMC,RDPMC;RDPMC,Description}
#{\footnote RDPMC::1}

{\fs20\b RDPMC}\tab{\b Description}\par\par
RDPMC: Read Performance-Monitoring Counters
\par 
\par Loads the contents of the 40-bit performance-monitoring counter specified in the ECX register into registers EDX:EAX. The EDX register is loaded with the high-order 8 bits of the counter and the EAX register is loaded with the low-order 32 bits. The Pentium Pro processor has two performance-monitoring counters (0 and 1), which are specified by placing 0000H or 0001H, respectively, in the ECX register.
\par The RDPMC instruction allows application code running at a privilege level of 1, 2, or 3 to read the performance-monitoring counters if the PCE flag in the CR4 register is set. This instruction is provided to allow performance monitoring by application code without incurring the overhead of a call to an operating-system procedure. The performance-monitoring counters are event counters that can be programmed to count events such as the number of instructions decoded, number of interrupts received, or number of cache loads.
\par The RDPMC instruction does not serialize instruction execution. That is, it does not imply that all the events caused by the preceding instructions have been completed or that events caused by subsequent instructions have not begun. If an exact event count is desired, software must use a serializing instruction (such as the CPUID instruction) before and/or after the execution of the RDPCM instruction.
\par The RDPMC instruction can execute in 16-bit addressing mode or virtual-8086 mode; however, the full contents of the ECX register are used to determine the counter to access and a full 40-bit result is returned (the low-order 32 bits in the EAX register and the high-order 9 bits in the EDX register).
\par 
\par Intel Architecture Compatibility
\par 
\par The RDPMC instruction was introduced into the Intel Architecture in the Pentium Pro processor and the Pentium processor with MMX technology. The other Pentium processors have performance-monitoring counters, but they must be read with the RDMSR instruction.
{\page}

${\footnote RDPMC,Operation}
K{\footnote RDPMC,RDPMC;RDPMC,Operation}
#{\footnote RDPMC::2}

{\fs20\b RDPMC}\tab{\b Operation}\par\par
IF (ECX = 0 OR 1) AND ((CR4.PCE = 1) OR ((CR4.PCE = 0) AND (CPL=0)))
\par THEN
\par EDX:EAX <- PMC[ECX];
\par ELSE (* ECX is not 0 or 1 and/or CR4.PCE is 0 and CPL is 1, 2, or 3 *)
\par #GP(0); FI;
{\page}

${\footnote RDPMC,Flags affected}
K{\footnote RDPMC,RDPMC;RDPMC,Flags affected}
#{\footnote RDPMC::3}

{\fs20\b RDPMC}\tab{\b Flags affected}\par\par
None.
{\page}

${\footnote RDPMC,Exceptions}
K{\footnote RDPMC,RDPMC;RDPMC,Exceptions}
#{\footnote RDPMC::4}

{\fs20\b RDPMC}\tab{\b Exceptions}\par\par
Protected Mode Exceptions
\par 
\par #GP(0) If the current privilege level is not 0 and the PCE flag in the CR4 register is clear. If the value in the ECX register is not 0 or 1.
\par 
\par Real-Address Mode Exceptions
\par 
\par #GP If the PCE flag in the CR4 register is clear. If the value in the ECX register is not 0 or 1.
\par 
\par Virtual-8086 Mode Exceptions
\par 
\par #GP(0) If the PCE flag in the CR4 register is clear. If the value in the ECX register is not 0 or 1.
{\page}

${\footnote RDPMC,Opcode}
K{\footnote RDPMC,RDPMC;RDPMC,Opcode}
#{\footnote RDPMC::5}

{\fs20\b RDPMC}\tab{\b Opcode}\par\par
0F 33 RDPMC Read performance-monitoring counter specified by ECX into EDX:EAX
{\page}

${\footnote RDTSC,Description}
K{\footnote RDTSC,RDTSC;RDTSC,Description}
#{\footnote RDTSC::1}

{\fs20\b RDTSC}\tab{\b Description}\par\par
RDTSC: Read Time-Stamp Counter
\par 
\par Loads the current value of the processor's time-stamp counter into the EDX:EAX registers. The time-stamp counter is contained in a 64-bit MSR. The high-order 32 bits of the MSR are loaded into the EDX register, and the low-order 32 bits are loaded into the EAX register. The processor increments the time-stamp counter MSR every clock cycle and resets it to 0 whenever the processor is reset.
\par The time stamp disable (TSD) flag in register CR4 restricts the use of the RDTSC instruction. When the TSD flag is clear, the RDTSC instruction can be executed at any privilege level; when the flag is set, the instruction can only be executed at privilege level 0. The time-stamp counter can also be read with the RDMSR instruction, when executing at privilege level 0. The RDTSC instruction is not a serializing instruction. Thus, it does not necessarily wait until all previous instructions have been executed before reading the counter. Similarly, subsequent instructions may begin execution before the read operation is performed.
\par This instruction was introduced into the Intel Architecture in the Pentium processor.
{\page}

${\footnote RDTSC,Operation}
K{\footnote RDTSC,RDTSC;RDTSC,Operation}
#{\footnote RDTSC::2}

{\fs20\b RDTSC}\tab{\b Operation}\par\par
IF (CR4.TSD = 0) OR ((CR4.TSD = 1) AND (CPL=0))
\par THEN
\par EDX:EAX <- TimeStampCounter;
\par ELSE (* CR4 is 1 and CPL is 1, 2, or 3 *)
\par #GP(0)
\par FI;
{\page}

${\footnote RDTSC,Flags affected}
K{\footnote RDTSC,RDTSC;RDTSC,Flags affected}
#{\footnote RDTSC::3}

{\fs20\b RDTSC}\tab{\b Flags affected}\par\par
None.
{\page}

${\footnote RDTSC,Exceptions}
K{\footnote RDTSC,RDTSC;RDTSC,Exceptions}
#{\footnote RDTSC::4}

{\fs20\b RDTSC}\tab{\b Exceptions}\par\par
Protected Mode Exceptions
\par 
\par #GP(0) If the TSD flag in register CR4 is set and the CPL is greater than 0.
\par 
\par Real-Address Mode Exceptions
\par 
\par #GP If the TSD flag in register CR4 is set.
\par 
\par Virtual-8086 Mode Exceptions
\par 
\par #GP(0) If the TSD flag in register CR4 is set.
{\page}

${\footnote RDTSC,Opcode}
K{\footnote RDTSC,RDTSC;RDTSC,Opcode}
#{\footnote RDTSC::5}

{\fs20\b RDTSC}\tab{\b Opcode}\par\par
0F 31 RDTSC Read time-stamp counter into EDX:EAX
{\page}

${\footnote REP,Description}
K{\footnote REP,REP;REPE,REPE;REPZ,REPZ;REPNE,REPNE;REPNZ,REPNZ;REP,Description;REPE,Description;REPZ,Description;REPNE,Description;REPNZ,Description}
#{\footnote REP::1}
#{\footnote REPE::1}
#{\footnote REPZ::1}
#{\footnote REPNE::1}
#{\footnote REPNZ::1}

{\fs20\b REP/REPE/REPZ/REPNE/REPNZ}\tab{\b Description}\par\par
REP/REPE/REPZ/REPNE/REPNZ: Repeat String Operation Prefix
\par 
\par Repeats a string instruction the number of times specified in the count register ((E)CX) or until the indicated condition of the ZF flag is no longer met. The REP (repeat), REPE (repeat while equal), REPNE (repeat while not equal), REPZ (repeat while zero), and REPNZ (repeat while not zero) mnemonics are prefixes that can be added to one of the string instructions. The REP prefix can be added to the INS, OUTS, MOVS, LODS, and STOS instructions, and the REPE, REPNE, REPZ, and REPNZ prefixes can be added to the CMPS and SCAS instructions. (The REPZ and REPNZ prefixes are synonymous forms of the REPE and REPNE prefixes, respectively.)
\par The behavior of the REP prefix is undefined when used with non-string instructions. The REP prefixes apply only to one string instruction at a time. To repeat a block of instructions, use the LOOP instruction or another looping construct.
\par All of these repeat prefixes cause the associated instruction to be repeated until the count in register (E)CX is decremented to 0 (see the following table). (If the current address-size attribute is 32, register ECX is used as a counter, and if the address-size attribute is 16, the CX register is used.) The REPE, REPNE, REPZ, and REPNZ prefixes also check the state of the ZF flag after each iteration and terminate the repeat loop if the ZF flag is not in the specified state. When both termination conditions are tested, the cause of a repeat termination can be determined either by testing the (E)CX register with a JECXZ instruction or by testing the ZF flag with a JZ, JNZ, and JNE instruction.
\par 
\par Repeat Conditions
\par -----------------
\par Repeat Prefix Termination Condition 1 Termination Condition 2
\par      REP               ECX=0                    None
\par   REPE/REPZ            ECX=0                    ZF=0
\par  REPNE/REPNZ           ECX=0                    ZF=1
\par 
\par When the REPE/REPZ and REPNE/REPNZ prefixes are used, the ZF flag does not require initialization because both the CMPS and SCAS instructions affect the ZF flag according to the results of the comparisons they make.
\par A repeating string operation can be suspended by an exception or interrupt. When this happens, the state of the registers is preserved to allow the string operation to be resumed upon a return from the exception or interrupt handler. The source and destination registers point to the next string elements to be operated on, the EIP register points to the string instruction, and the ECX register has the value it held following the last successful iteration of the instruction. This mechanism allows long string operations to proceed without affecting the interrupt response time of the system.
\par When a fault occurs during the execution of a CMPS or SCAS instruction that is prefixed with REPE or REPNE, the EFLAGS value is restored to the state prior to the execution of the instruction. Since the SCAS and CMPS instructions do not use EFLAGS as an input, the processor can resume the instruction after the page fault handler. Use the REP INS and REP OUTS instructions with caution. Not all I/O ports can handle the rate at which these instructions execute. A REP STOS instruction is the fastest way to initialize a large block of memory.
{\page}

${\footnote REP,Operation}
K{\footnote REP,REP;REPE,REPE;REPZ,REPZ;REPNE,REPNE;REPNZ,REPNZ;REP,Operation;REPE,Operation;REPZ,Operation;REPNE,Operation;REPNZ,Operation}
#{\footnote REP::2}
#{\footnote REPE::2}
#{\footnote REPZ::2}
#{\footnote REPNE::2}
#{\footnote REPNZ::2}

{\fs20\b REP/REPE/REPZ/REPNE/REPNZ}\tab{\b Operation}\par\par
IF AddressSize = 16
\par THEN
\par use CX for CountReg;
\par ELSE (* AddressSize = 32 *)
\par use ECX for CountReg;
\par FI;
\par WHILE CountReg != 0
\par DO
\par service pending interrupts (if any);
\par execute associated string instruction;
\par CountReg <- CountReg - 1;
\par IF CountReg = 0
\par THEN exit WHILE loop
\par FI;
\par IF (repeat prefix is REPZ or REPE) AND (ZF=0)
\par OR (repeat prefix is REPNZ or REPNE) AND (ZF=1)
\par THEN exit WHILE loop
\par FI;
\par OD;
{\page}

${\footnote REP,Flags affected}
K{\footnote REP,REP;REPE,REPE;REPZ,REPZ;REPNE,REPNE;REPNZ,REPNZ;REP,Flags affected;REPE,Flags affected;REPZ,Flags affected;REPNE,Flags affected;REPNZ,Flags affected}
#{\footnote REP::3}
#{\footnote REPE::3}
#{\footnote REPZ::3}
#{\footnote REPNE::3}
#{\footnote REPNZ::3}

{\fs20\b REP/REPE/REPZ/REPNE/REPNZ}\tab{\b Flags affected}\par\par
None; however, the CMPS and SCAS instructions do set the status flags in the EFLAGS register.
{\page}

${\footnote REP,Exceptions}
K{\footnote REP,REP;REPE,REPE;REPZ,REPZ;REPNE,REPNE;REPNZ,REPNZ;REP,Exceptions;REPE,Exceptions;REPZ,Exceptions;REPNE,Exceptions;REPNZ,Exceptions}
#{\footnote REP::4}
#{\footnote REPE::4}
#{\footnote REPZ::4}
#{\footnote REPNE::4}
#{\footnote REPNZ::4}

{\fs20\b REP/REPE/REPZ/REPNE/REPNZ}\tab{\b Exceptions}\par\par
(All Operating Modes)
\par None; however, exceptions can be generated by the instruction a repeat prefix is associated with.
{\page}

${\footnote REP,Opcode}
K{\footnote REP,REP;REPE,REPE;REPZ,REPZ;REPNE,REPNE;REPNZ,REPNZ;REP,Opcode;REPE,Opcode;REPZ,Opcode;REPNE,Opcode;REPNZ,Opcode}
#{\footnote REP::5}
#{\footnote REPE::5}
#{\footnote REPZ::5}
#{\footnote REPNE::5}
#{\footnote REPNZ::5}

{\fs20\b REP/REPE/REPZ/REPNE/REPNZ}\tab{\b Opcode}\par\par
F3 6C REP INS r/m8, DX Input (E)CX bytes from port DX into ES:[(E)DI]
\par F3 6D REP INS r/m16,DX Input (E)CX words from port DX into ES:[(E)DI]
\par F3 6D REP INS r/m32,DX Input (E)CX doublewords from port DX into ES:[(E)DI]
\par F3 A4 REP MOVS m8,m8 Move (E)CX bytes from DS:[(E)SI] to ES:[(E)DI]
\par F3 A5 REP MOVS m16,m16 Move (E)CX words from DS:[(E)SI] to ES:[(E)DI]
\par F3 A5 REP MOVS m32,m32 Move (E)CX doublewords from DS:[(E)SI] to ES:[(E)DI]
\par F3 6E REP OUTS DX, r/m8 Output (E)CX bytes from DS:[(E)SI] to port DX
\par F3 6F REP OUTS DX, r/m16 Output (E)CX words from DS:[(E)SI] to port DX
\par F3 6F REP OUTS DX, r/m32 Output (E)CX doublewords from DS:[(E)SI] to port DX
\par F3 AC REP LODS AL Load (E)CX bytes from DS:[(E)SI] to AL
\par F3 AD REP LODS AX Load (E)CX words from DS:[(E)SI] to AX
\par F3 AD REP LODS EAX Load (E)CX doublewords from DS:[(E)SI] to EAX
\par F3 AA REP STOS m8 Fill (E)CX bytes at ES:[(E)DI] with AL
\par F3 AB REP STOS m16 Fill (E)CX words at ES:[(E)DI] with AX
\par F3 AB REP STOS m32 Fill (E)CX doublewords at ES:[(E)DI] with EAX
\par F3 A6 REPE CMPS m8,m8 Find nonmatching bytes in ES:[(E)DI] and DS:[(E)SI]
\par F3 A7 REPE CMPS m16,m16 Find nonmatching words in ES:[(E)DI] and DS:[(E)SI]
\par F3 A7 REPE CMPS m32,m32 Find nonmatching doublewords in ES:[(E)DI] and DS:[(E)SI]
\par F3 AE REPE SCAS m8 Find non-AL byte starting at ES:[(E)DI]
\par F3 AF REPE SCAS m16 Find non-AX word starting at ES:[(E)DI]
\par F3 AF REPE SCAS m32 Find non-EAX doubleword starting at ES:[(E)DI]
\par F2 A6 REPNE CMPS m8,m8 Find matching bytes in ES:[(E)DI] and DS:[(E)SI]
\par F2 A7 REPNE CMPS m16,m16 Find matching words in ES:[(E)DI] and DS:[(E)SI]
\par F2 A7 REPNE CMPS m32,m32 Find matching doublewords in ES:[(E)DI] and DS:[(E)SI]
\par F2 AE REPNE SCAS m8 Find AL, starting at ES:[(E)DI]
\par F2 AF REPNE SCAS m16 Find AX, starting at ES:[(E)DI]
\par F2 AF REPNE SCAS m32 Find EAX, starting at ES:[(E)DI]
{\page}

${\footnote RETF,Description}
K{\footnote RETF,RETF;RETN,RETN;RET,RET;RETF,Description;RETN,Description;RET,Description}
#{\footnote RETF::1}
#{\footnote RETN::1}
#{\footnote RET::1}

{\fs20\b RETF/RETN/RET}\tab{\b Description}\par\par
RET: Return from Procedure
\par 
\par Transfers program control to a return address located on the top of the stack. The address is usually placed on the stack by a CALL instruction, and the return is made to the instruction that follows the CALL instruction.
\par The optional source operand specifies the number of stack bytes to be released after the return address is popped; the default is none. This operand can be used to release parameters from the stack that were passed to the called procedure and are no longer needed. It must be used when the CALL instruction used to switch to a new procedure uses a call gate with a non-zero word count to access the new procedure. Here, the source operand for the RET instruction must specify the same number of bytes as is specified in the word count field of the call gate.
\par The RET instruction can be used to execute three different types of returns:
\par 
\par - Near return--A return to a calling procedure within the current code segment (the segment currently pointed to by the CS register), sometimes referred to as an intrasegment return.
\par - Far return--A return to a calling procedure located in a different segment than the current code segment, sometimes referred to as an intersegment return.
\par - Inter-privilege-level far return--A far return to a different privilege level than that of the currently executing program or procedure. The inter-privilege-level return type can only be executed in protected mode.
\par 
\par When executing a near return, the processor pops the return instruction pointer (offset) from the top of the stack into the EIP register and begins program execution at the new instruction pointer. The CS register is unchanged.
\par When executing a far return, the processor pops the return instruction pointer from the top of the stack into the EIP register, then pops the segment selector from the top of the stack into the CS register. The processor then begins program execution in the new code segment at the new instruction pointer.
\par The mechanics of an inter-privilege-level far return are similar to an intersegment return, except that the processor examines the privilege levels and access rights of the code and stack segments being returned to determine if the control transfer is allowed to be made. The DS, ES, FS, and GS segment registers are cleared by the RET instruction during an inter-privilege-level return if they refer to segments that are not allowed to be accessed at the new privilege level. Since a stack switch also occurs on an inter-privilege level return, the ESP and SS registers are loaded from the stack.
\par If parameters are passed to the called procedure during an inter-privilege level call, the optional source operand must be used with the RET instruction to release the parameters on the return. Here, the parameters are released both from the called procedure's stack and the calling procedure's stack (that is, the stack being returned to).
{\page}

${\footnote RETF,Operation}
K{\footnote RETF,RETF;RETN,RETN;RET,RET;RETF,Operation;RETN,Operation;RET,Operation}
#{\footnote RETF::2}
#{\footnote RETN::2}
#{\footnote RET::2}

{\fs20\b RETF/RETN/RET}\tab{\b Operation}\par\par
(* Near return *)
\par 
\par IF instruction = near return
\par THEN;
\par IF OperandSize = 32
\par THEN
\par IF top 12 bytes of stack not within stack limits THEN #SS(0); FI;
\par EIP <- Pop();
\par ELSE (* OperandSize = 16 *)
\par IF top 6 bytes of stack not within stack limits
\par THEN #SS(0)
\par FI;
\par tempEIP <- Pop();
\par tempEIP <- tempEIP AND 0000FFFFH;
\par IF tempEIP not within code segment limits THEN #GP(0); FI;
\par EIP <- tempEIP;
\par FI;
\par IF instruction has immediate operand
\par THEN IF StackAddressSize=32
\par THEN
\par ESP <- ESP + SRC; (* release parameters from stack *)
\par ELSE (* StackAddressSize=16 *)
\par SP <- SP + SRC; (* release parameters from stack *)
\par FI;
\par FI;
\par 
\par (* Real-address mode or virtual-8086 mode *)
\par 
\par IF ((PE = 0) OR (PE = 1 AND VM = 1)) AND instruction = far return
\par THEN;
\par IF OperandSize = 32
\par THEN
\par IF top 12 bytes of stack not within stack limits THEN #SS(0); FI;
\par EIP <- Pop();
\par CS <- Pop(); (* 32-bit pop, high-order 16-bits discarded *)
\par ELSE (* OperandSize = 16 *)
\par IF top 6 bytes of stack not within stack limits THEN #SS(0); FI;
\par tempEIP <- Pop();
\par tempEIP <- tempEIP AND 0000FFFFH;
\par IF tempEIP not within code segment limits THEN #GP(0); FI;
\par EIP <- tempEIP;
\par CS <- Pop(); (* 16-bit pop *)
\par FI;
\par IF instruction has immediate operand
\par THEN
\par SP <- SP + (SRC AND FFFFH); (* release parameters from stack *)
\par FI;
\par FI;
\par 
\par (* Protected mode, not virtual-8086 mode *)
\par 
\par IF (PE = 1 AND VM = 0) AND instruction = far RET
\par THEN
\par IF OperandSize = 32
\par THEN
\par IF second doubleword on stack is not within stack limits THEN #SS(0); FI;
\par ELSE (* OperandSize = 16 *)
\par IF second word on stack is not within stack limits THEN #SS(0); FI;
\par FI;
\par IF return code segment selector is null THEN GP(0); FI;
\par IF return code segment selector addrsses descriptor beyond diescriptor table limit
\par THEN GP(selector; FI;
\par Obtain descriptor to which return code segment selector points from descriptor table
\par IF return code segment descriptor is not a code segment THEN #GP(selector); FI;
\par if return code segment selector RPL < CPL THEN #GP(selector); FI;
\par IF return code segment descriptor is conforming
\par AND return code segment DPL > return code segment selector RPL
\par THEN #GP(selector); FI;
\par IF return code segment descriptor is not present THEN #NP(selector); FI:
\par IF return code segment selector RPL > CPL
\par THEN GOTO RETURN-OUTER-PRIVILEGE-LEVEL;
\par ELSE GOTO RETURN-TO-SAME-PRIVILEGE-LEVEL
\par FI;
\par END;FI;
\par 
\par RETURN-SAME-PRIVILEGE-LEVEL:
\par 
\par IF the return instruction pointer is not within ther return code segment limit
\par THEN #GP(0);
\par FI;
\par IF OperandSize=32
\par THEN
\par EIP <- Pop();
\par CS <- Pop(); (* 32-bit pop, high-order 16-bits discarded *)
\par ESP <- ESP + SRC; (* release parameters from stack *)
\par ELSE (* OperandSize=16 *)
\par EIP <- Pop();
\par EIP <- EIP AND 0000FFFFH;
\par CS <- Pop(); (* 16-bit pop *)
\par ESP <- ESP + SRC; (* release parameters from stack *)
\par FI;
\par 
\par RETURN-OUTER-PRIVILEGE-LEVEL:
\par 
\par IF top (16 + SRC) bytes of stack are not within stack limits (OperandSize=32)
\par OR top (8 + SRC) bytes of stack are not within stack limits (OperandSize=16)
\par THEN #SS(0); FI;
\par FI;
\par Read return segment selector;
\par IF stack segment selector is null THEN #GP(0); FI;
\par IF return stack segment selector index is not within its descriptor table limits
\par THEN #GP(selector); FI;
\par Read segment descriptor pointed to by return segment selector;
\par IF stack segment selector RPL != RPL of the return code segment selector
\par OR stack segment is not a writable data segment
\par OR stack segment descriptor DPL != RPL of the return code segment selector
\par THEN #GP(selector); FI;
\par IF stack segment not present THEN #SS(StackSegmentSelector); FI;
\par IF the return instruction pointer is not within the return code segment limit THEN #GP(0); FI:
\par CPL <- ReturnCodeSegmentSelector(RPL);
\par IF OperandSize=32
\par THEN
\par EIP <- Pop();
\par CS <- Pop(); (* 32-bit pop, high-order 16-bits discarded *)
\par (* segment descriptor information also loaded *)
\par CS(RPL) <- CPL;
\par ESP <- ESP + SRC; (* release parameters from called procedure's stack *)
\par tempESP <- Pop();
\par tempSS <- Pop(); (* 32-bit pop, high-order 16-bits discarded *)
\par (* segment descriptor information also loaded *)
\par ESP <- tempESP;
\par SS <- tempSS;
\par ELSE (* OperandSize=16 *)
\par EIP <- Pop();
\par EIP <- EIP AND 0000FFFFH;
\par CS <- Pop(); (* 16-bit pop; segment descriptor information also loaded *)
\par CS(RPL) <- CPL;
\par ESP <- ESP + SRC; (* release parameters from called procedure's stack *)
\par tempESP <- Pop();
\par tempSS <- Pop(); (* 16-bit pop; segment descriptor information also loaded *)
\par (* segment descriptor information also loaded *)
\par ESP <- tempESP;
\par SS <- tempSS;
\par FI;
\par FOR each of segment register (ES, FS, GS, and DS)
\par DO;
\par IF segment register points to data or non-conforming code segment
\par AND CPL > segment descriptor DPL; (* DPL in hidden part of segment register *)
\par THEN (* segment register invalid *)
\par SegmentSelector <- 0; (* null segment selector *)
\par FI;
\par OD;
\par For each of ES, FS, GS, and DS
\par DO
\par IF segment selector index is not within descriptor table limits
\par OR segment descriptor indicates the segment is not a data or
\par readable code segment
\par OR if the segment is a data or non-conforming code segment and the segment
\par descriptor's DPL < CPL or RPL of code segment's segment selector
\par THEN
\par segment selector register <- null selector;
\par OD;
\par ESP <- ESP + SRC; (* release parameters from calling procedure's stack *)
{\page}

${\footnote RETF,Flags affected}
K{\footnote RETF,RETF;RETN,RETN;RET,RET;RETF,Flags affected;RETN,Flags affected;RET,Flags affected}
#{\footnote RETF::3}
#{\footnote RETN::3}
#{\footnote RET::3}

{\fs20\b RETF/RETN/RET}\tab{\b Flags affected}\par\par
None.
{\page}

${\footnote RETF,Exceptions}
K{\footnote RETF,RETF;RETN,RETN;RET,RET;RETF,Exceptions;RETN,Exceptions;RET,Exceptions}
#{\footnote RETF::4}
#{\footnote RETN::4}
#{\footnote RET::4}

{\fs20\b RETF/RETN/RET}\tab{\b Exceptions}\par\par
Protected Mode Exceptions
\par 
\par #GP(0) If the return code or stack segment selector null. If the return instruction pointer is not within the return code segment limit.
\par #GP(selector) If the RPL of the return code segment selector is less then the CPL. If the return code or stack segment selector index is not within its descriptor table limits. If the return code segment descriptor does not indicate a code segment. If the return code segment is non-conforming and the segment selector's DPL is not equal to the RPL of the code segment's segment selector If the return code segment is conforming and the segment selector's DPL greater than the RPL of the code segment's segment selector. If the stack segment is not a writable data segment. If the stack segment selector RPL is not equal to the RPL of the return code segment selector. If the stack segment descriptor DPL is not equal to the RPL of the return code segment selector.
\par #SS(0) If the top bytes of stack are not within stack limits. If the return stack segment is not present.
\par #NP(selector) If the return code segment is not present.
\par #PF(fault-code) If a page fault occurs.
\par #AC(0) If an unaligned memory access occurs when the CPL is 3 and alignment checking is enabled.
\par 
\par Real-Address Mode Exceptions
\par 
\par #GP If the return instruction pointer is not within the return code segment limit
\par #SS If the top bytes of stack are not within stack limits.
\par 
\par Virtual-8086 Mode Exceptions
\par 
\par #GP(0) If the return instruction pointer is not within the return code segment limit
\par #SS(0) If the top bytes of stack are not within stack limits.
\par #PF(fault-code) If a page fault occurs.
\par #AC(0) If an unaligned memory access occurs when alignment checking is enabled.
{\page}

${\footnote RETF,Opcode}
K{\footnote RETF,RETF;RETN,RETN;RET,RET;RETF,Opcode;RETN,Opcode;RET,Opcode}
#{\footnote RETF::5}
#{\footnote RETN::5}
#{\footnote RET::5}

{\fs20\b RETF/RETN/RET}\tab{\b Opcode}\par\par
C3 RET Near return to calling procedure
\par CB RET Far return to calling procedure
\par C2 iw RET imm16 Near return to calling procedure and pop imm16 bytes from stack
\par CA iw RET imm16 Far return to calling procedure and pop imm16 bytes from stack
{\page}

${\footnote RSM,Description}
K{\footnote RSM,RSM;RSM,Description}
#{\footnote RSM::1}

{\fs20\b RSM}\tab{\b Description}\par\par
RSM: Resume from System Management Mode
\par 
\par Returns program control from system management mode (SMM) to the application program or operating-system procedure that was interrupted when the processor received an SSM interrupt. The processor's state is restored from the dump created upon entering SMM. If the processor detects invalid state information during state restoration, it enters the shutdown state. The following invalid information can cause a shutdown:
\par 
\par - Any reserved bit of CR4 is set to 1.
\par - Any illegal combination of bits in CR0, such as (PG=1 and PE=0) or (NW=1 and CD=0).
\par - (Intel Pentium (r) and Intel486(tm) processors only.) The value stored in the state dump base field is not a 32-KByte aligned address.
\par The contents of the model-specific registers are not affected by a return from SMM.
{\page}

${\footnote RSM,Operation}
K{\footnote RSM,RSM;RSM,Operation}
#{\footnote RSM::2}

{\fs20\b RSM}\tab{\b Operation}\par\par
ReturnFromSSM;
\par ProcessorState <- Restore(SSMDump);
{\page}

${\footnote RSM,Flags affected}
K{\footnote RSM,RSM;RSM,Flags affected}
#{\footnote RSM::3}

{\fs20\b RSM}\tab{\b Flags affected}\par\par
All.
{\page}

${\footnote RSM,Exceptions}
K{\footnote RSM,RSM;RSM,Exceptions}
#{\footnote RSM::4}

{\fs20\b RSM}\tab{\b Exceptions}\par\par
Protected Mode Exceptions
\par 
\par #UD If an attempt is made to execute this instruction when the processor is not in SMM.
\par 
\par Real-Address Mode Exceptions
\par 
\par #UD If an attempt is made to execute this instruction when the processor is not in SMM.
\par 
\par Virtual-8086 Mode Exceptions
\par 
\par #UD If an attempt is made to execute this instruction when the processor is not in SMM.
{\page}

${\footnote RSM,Opcode}
K{\footnote RSM,RSM;RSM,Opcode}
#{\footnote RSM::5}

{\fs20\b RSM}\tab{\b Opcode}\par\par
0F AA RSM Resume operation of interrupted program
{\page}

${\footnote SAHF,Description}
K{\footnote SAHF,SAHF;SAHF,Description}
#{\footnote SAHF::1}

{\fs20\b SAHF}\tab{\b Description}\par\par
SAHF: Store AH into Flags
\par 
\par Loads the SF, ZF, AF, PF, and CF flags of the EFLAGS register with values from the corresponding bits in the AH register (bits 7, 6, 4, 2, and 0, respectively). Bits 1, 3, and 5 of register AH are ignored; the corresponding reserved bits (1, 3, and 5) in the EFLAGS register remain as shown in the "Operation" section.
{\page}

${\footnote SAHF,Operation}
K{\footnote SAHF,SAHF;SAHF,Operation}
#{\footnote SAHF::2}

{\fs20\b SAHF}\tab{\b Operation}\par\par
EFLAGS(SF:ZF:0:AF:0:PF:1:CF) <- AH;
{\page}

${\footnote SAHF,Flags affected}
K{\footnote SAHF,SAHF;SAHF,Flags affected}
#{\footnote SAHF::3}

{\fs20\b SAHF}\tab{\b Flags affected}\par\par
The SF, ZF, AF, PF, and CF flags are loaded with values from the AH register. Bits 1, 3, and 5 of the EFLAGS register are unaffected, with the values remaining 1, 0, and 0, respectively.
{\page}

${\footnote SAHF,Exceptions}
K{\footnote SAHF,SAHF;SAHF,Exceptions}
#{\footnote SAHF::4}

{\fs20\b SAHF}\tab{\b Exceptions}\par\par
(All Operating Modes)
\par None.
{\page}

${\footnote SAHF,Opcode}
K{\footnote SAHF,SAHF;SAHF,Opcode}
#{\footnote SAHF::5}

{\fs20\b SAHF}\tab{\b Opcode}\par\par
9E SAHF 2 Loads SF, ZF, AF, PF, and CF from AH into EFLAGS register
{\page}

${\footnote SAL,Description}
K{\footnote SAL,SAL;SAR,SAR;SHL,SHL;SHR,SHR;SAL,Description;SAR,Description;SHL,Description;SHR,Description}
#{\footnote SAL::1}
#{\footnote SAR::1}
#{\footnote SHL::1}
#{\footnote SHR::1}

{\fs20\b SAL/SAR/SHL/SHR}\tab{\b Description}\par\par
SAL/SAR/SHL/SHR: Shift
\par 
\par Shifts the bits in the first operand (destination operand) to the left or right by the number of bits specified in the second operand (count operand). Bits shifted beyond the destination operand boundary are first shifted into the CF flag, then discarded. At the end of the shift operation, the CF flag contains the last bit shifted out of the destination operand. The destination operand can be a register or a memory location. The count operand can be an immediate value or register CL. The count is masked to 5 bits, which limits the count range to 0 to 31. A special opcode encoding is provided for a count of 1.
\par The shift arithmetic left (SAL) and shift logical left (SHL) instructions perform the same operation; they shift the bits in the destination operand to the left (toward more significant bit locations). For each shift count, the most significant bit of the destination operand is shifted into the CF flag, and the least significant bit is cleared.
\par The shift arithmetic right (SAR) and shift logical right (SHR) instructions shift the bits of the destination operand to the right (toward less significant bit locations). For each shift count, the least significant bit of the destination operand is shifted into the CF flag, and the most significant bit is either set or cleared depending on the instruction type. The SHR instruction clears the most significant bit; the SAR instruction sets or clears the most significant bit to correspond to the sign (most significant bit) of the original value in the destination operand. In effect, the SAR instruction fills the empty bit position's shifted value with the sign of the unshifted value.
\par The SAR and SHR instructions can be used to perform signed or unsigned division, respectively, of the destination operand by powers of 2. For example, using the SAR instruction to shift a signed integer 1 bit to the right divides the value by 2. Using the SAR instruction to perform a division operation does not produce the same result as the IDIV instruction. The quotient from the IDIV instruction is rounded toward zero, whereas the "quotient" of the SAR instruction is rounded toward negative infinity. This difference is apparent only for negative numbers. For example, when the IDIV instruction is used to divide -9 by 4, the result is -2 with a remainder of -1. If the SAR instruction is used to shift -9 right by two bits, the result is -3 and the "remainder" is +3; however, the SAR instruction stores only the most significant bit of the remainder (in the CF flag).
\par The OF flag is affected only on 1-bit shifts. For left shifts, the OF flag is cleared to 0 if the most-significant bit of the result is the same as the CF flag (that is, the top two bits of the original operand were the same); otherwise, it is set to 1. For the SAR instruction, the OF flag is cleared for all 1-bit shifts. For the SHR instruction, the OF flag is set to the most-significant bit of the original operand.
\par 
\par Intel Architecture Compatibility
\par 
\par The 8086 does not mask the shift count. However, all other Intel Architecture processors (starting with the Intel 286 processor) do mask the shift count to 5 bits, resulting in a maximum count of 31. This masking is done in all operating modes (including the virtual-8086 mode) to reduce the maximum execution time of the instructions.
{\page}

${\footnote SAL,Operation}
K{\footnote SAL,SAL;SAR,SAR;SHL,SHL;SHR,SHR;SAL,Operation;SAR,Operation;SHL,Operation;SHR,Operation}
#{\footnote SAL::2}
#{\footnote SAR::2}
#{\footnote SHL::2}
#{\footnote SHR::2}

{\fs20\b SAL/SAR/SHL/SHR}\tab{\b Operation}\par\par
tempCOUNT <- (COUNT AND 1FH);
\par tempDEST <- DEST;
\par WHILE (tempCOUNT != 0)
\par DO
\par IF instruction is SAL or SHL
\par THEN
\par CF <- MSB(DEST);
\par ELSE (* instruction is SAR or SHR *)
\par CF <- LSB(DEST);
\par FI;
\par IF instruction is SAL or SHL
\par THEN
\par DEST <- DEST * 2;
\par ELSE
\par IF instruction is SAR
\par THEN
\par DEST <- DEST / 2 (*Signed divide, rounding toward negative infinity*);
\par ELSE (* instruction is SHR *)
\par DEST <- DEST / 2 ; (* Unsigned divide *);
\par FI;
\par FI;
\par tempCOUNT <- tempCOUNT - 1;
\par OD;
\par (* Determine overflow for the various instructions *)
\par IF COUNT = 1
\par THEN
\par IF instruction is SAL or SHL
\par THEN
\par OF <- MSB(DEST) XOR CF;
\par ELSE
\par IF instruction is SAR
\par THEN
\par OF <- 0;
\par ELSE (* instruction is SHR *)
\par OF <- MSB(tempDEST);
\par FI;
\par FI;
\par ELSE IF COUNT = 0
\par THEN
\par All flags remain unchanged;
\par ELSE (* COUNT neither 1 or 0 *)
\par OF <- undefined;
\par FI;
\par FI;
{\page}

${\footnote SAL,Flags affected}
K{\footnote SAL,SAL;SAR,SAR;SHL,SHL;SHR,SHR;SAL,Flags affected;SAR,Flags affected;SHL,Flags affected;SHR,Flags affected}
#{\footnote SAL::3}
#{\footnote SAR::3}
#{\footnote SHL::3}
#{\footnote SHR::3}

{\fs20\b SAL/SAR/SHL/SHR}\tab{\b Flags affected}\par\par
The CF flag contains the value of the last bit shifted out of the destination operand; it is undefined for SHL and SHR instructions where the count is greater than or equal to the size (in bits) of the destination operand. The OF flag is affected only for 1-bit shifts (see "Description"); otherwise, it is undefined. The SF, ZF, and PF flags are set according to the result. If the count is 0, the flags are not affected. For a non-zero count, the AF flag is undefined.
{\page}

${\footnote SAL,Exceptions}
K{\footnote SAL,SAL;SAR,SAR;SHL,SHL;SHR,SHR;SAL,Exceptions;SAR,Exceptions;SHL,Exceptions;SHR,Exceptions}
#{\footnote SAL::4}
#{\footnote SAR::4}
#{\footnote SHL::4}
#{\footnote SHR::4}

{\fs20\b SAL/SAR/SHL/SHR}\tab{\b Exceptions}\par\par
Protected Mode Exceptions
\par 
\par #GP(0) If the destination is located in a nonwritable segment. If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit. If the DS, ES, FS, or GS register contains a null segment selector.
\par #SS(0) If a memory operand effective address is outside the SS segment limit.
\par #PF(fault-code) If a page fault occurs.
\par #AC(0) If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.
\par 
\par Real-Address Mode Exceptions
\par 
\par #GP If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.
\par #SS If a memory operand effective address is outside the SS segment limit.
\par 
\par Virtual-8086 Mode Exceptions
\par 
\par #GP(0) If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.
\par #SS(0) If a memory operand effective address is outside the SS segment limit.
\par #PF(fault-code) If a page fault occurs.
\par #AC(0) If alignment checking is enabled and an unaligned memory reference is made.
{\page}

${\footnote SAL,Opcode}
K{\footnote SAL,SAL;SAR,SAR;SHL,SHL;SHR,SHR;SAL,Opcode;SAR,Opcode;SHL,Opcode;SHR,Opcode}
#{\footnote SAL::5}
#{\footnote SAR::5}
#{\footnote SHL::5}
#{\footnote SHR::5}

{\fs20\b SAL/SAR/SHL/SHR}\tab{\b Opcode}\par\par
NOTE:
\par * Not the same form of division as IDIV; rounding is toward negative infinity.
\par 
\par D0 /4 SAL r/m8,1 Multiply r/m8 by 2, once
\par D2 /4 SAL r/m8,CL Multiply r/m8 by 2, CL times
\par C0 /4 ib SAL r/m8,imm8 Multiply r/m8 by 2, imm8 times
\par D1 /4 SAL r/m16,1 Multiply r/m16 by 2, once
\par D3 /4 SAL r/m16,CL Multiply r/m16 by 2, CL times
\par C1 /4 ib SAL r/m16,imm8 Multiply r/m16 by 2, imm8 times
\par D1 /4 SAL r/m32,1 Multiply r/m32 by 2, once
\par D3 /4 SAL r/m32,CL Multiply r/m32 by 2, CL times
\par C1 /4 ib SAL r/m32,imm8 Multiply r/m32 by 2, imm8 times
\par D0 /7 SAR r/m8,1 Signed divide* r/m8 by 2, once
\par D2 /7 SAR r/m8,CL Signed divide* r/m8 by 2, CL times
\par C0 /7 ib SAR r/m8,imm8 Signed divide* r/m8 by 2, imm8 times
\par D1 /7 SAR r/m16,1 Signed divide* r/m16 by 2, once
\par D3 /7 SAR r/m16,CL Signed divide* r/m16 by 2, CL times
\par C1 /7 ib SAR r/m16,imm8 Signed divide* r/m16 by 2, imm8 times
\par D1 /7 SAR r/m32,1 Signed divide* r/m32 by 2, once
\par D3 /7 SAR r/m32,CL Signed divide* r/m32 by 2, CL times
\par C1 /7 ib SAR r/m32,imm8 Signed divide* r/m32 by 2, imm8 times
\par D0 /4 SHL r/m8,1 Multiply r/m8 by 2, once
\par D2 /4 SHL r/m8,CL Multiply r/m8 by 2, CL times
\par C0 /4 ib SHL r/m8,imm8 Multiply r/m8 by 2, imm8 times
\par D1 /4 SHL r/m16,1 Multiply r/m16 by 2, once
\par D3 /4 SHL r/m16,CL Multiply r/m16 by 2, CL times
\par C1 /4 ib SHL r/m16,imm8 Multiply r/m16 by 2, imm8 times
\par D1 /4 SHL r/m32,1 Multiply r/m32 by 2, once
\par D3 /4 SHL r/m32,CL Multiply r/m32 by 2, CL times
\par C1 /4 ib SHL r/m32,imm8 Multiply r/m32 by 2, imm8 times
\par D0 /5 SHR r/m8,1 Unsigned divide r/m8 by 2, once
\par D2 /5 SHR r/m8,CL Unsigned divide r/m8 by 2, CL times
\par C0 /5 ib SHR r/m8,imm8 Unsigned divide r/m8 by 2, imm8 times
\par D1 /5 SHR r/m16,1 Unsigned divide r/m16 by 2, once
\par D3 /5 SHR r/m16,CL Unsigned divide r/m16 by 2, CL times
\par C1 /5 ib SHR r/m16,imm8 Unsigned divide r/m16 by 2, imm8 times
\par D1 /5 SHR r/m32,1 Unsigned divide r/m32 by 2, once
\par D3 /5 SHR r/m32,CL Unsigned divide r/m32 by 2, CL times
\par C1 /5 ib SHR r/m32,imm8 Unsigned divide r/m32 by 2, imm8 times
{\page}

${\footnote SBB,Description}
K{\footnote SBB,SBB;SBB,Description}
#{\footnote SBB::1}

{\fs20\b SBB}\tab{\b Description}\par\par
SBB: Integer Subtraction with Borrow
\par 
\par Adds the source operand (second operand) and the carry (CF) flag, and subtracts the result from the destination operand (first operand). The result of the subtraction is stored in the destination operand. The destination operand can be a register or a memory location; the source operand can be an immediate, a register, or a memory location. (However, two memory operands cannot be used in one instruction.) The state of the CF flag represents a borrow from a previous subtraction. When an immediate value is used as an operand, it is sign-extended to the length of the destination operand format.
\par The SBB instruction does not distinguish between signed or unsigned operands. Instead, the processor evaluates the result for both data types and sets the OF and CF flags to indicate a borrow in the signed or unsigned result, respectively. The SF flag indicates the sign of the signed result. The SBB instruction is usually executed as part of a multibyte or multiword subtraction in which a SUB instruction is followed by a SBB instruction.
{\page}

${\footnote SBB,Operation}
K{\footnote SBB,SBB;SBB,Operation}
#{\footnote SBB::2}

{\fs20\b SBB}\tab{\b Operation}\par\par
DEST <- DEST - (SRC + CF);
{\page}

${\footnote SBB,Flags affected}
K{\footnote SBB,SBB;SBB,Flags affected}
#{\footnote SBB::3}

{\fs20\b SBB}\tab{\b Flags affected}\par\par
The OF, SF, ZF, AF, PF, and CF flags are set according to the result.
{\page}

${\footnote SBB,Exceptions}
K{\footnote SBB,SBB;SBB,Exceptions}
#{\footnote SBB::4}

{\fs20\b SBB}\tab{\b Exceptions}\par\par
Protected Mode Exceptions
\par 
\par #GP(0) If the destination is located in a nonwritable segment. If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit. If the DS, ES, FS, or GS register contains a null segment selector.
\par #SS(0) If a memory operand effective address is outside the SS segment limit.
\par #PF(fault-code) If a page fault occurs.
\par #AC(0) If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.
\par 
\par Real-Address Mode Exceptions
\par 
\par #GP If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.
\par #SS If a memory operand effective address is outside the SS segment limit.
\par 
\par Virtual-8086 Mode Exceptions
\par 
\par #GP(0) If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.
\par #SS(0) If a memory operand effective address is outside the SS segment limit.
\par #PF(fault-code) If a page fault occurs.
\par #AC(0) If alignment checking is enabled and an unaligned memory reference is made.
{\page}

${\footnote SBB,Opcode}
K{\footnote SBB,SBB;SBB,Opcode}
#{\footnote SBB::5}

{\fs20\b SBB}\tab{\b Opcode}\par\par
1C ib SBB AL, imm8 Subtract with borrow imm8 from AL
\par 1D iw SBB AX, imm16 Subtract with borrow imm16 from AX
\par 1D id SBB EAX, imm32 Subtract with borrow imm32 from EAX
\par 80 /3 ib SBB r/m8,imm8 Subtract with borrow imm8 from r/m8
\par 81 /3 iw SBB r/m16,imm16 Subtract with borrow imm16 from r/m16
\par 81 /3 id SBB r/m32,imm32 Subtract with borrow imm32 from r/m32
\par 83 /3 ib SBB r/m16,imm8 Subtract with borrow sign-extended imm8 from r/m16
\par 83 /3 ib SBB r/m32,imm8 Subtract with borrow sign-extended imm8 from r/m32
\par 18 / r SBB r/m8,r8 Subtract with borrow r8 from r/m8
\par 19 / r SBB r/m16,r16 Subtract with borrow r16 from r/m16
\par 19 / r SBB r/m32,r32 Subtract with borrow r32 from r/m32
\par 1A / r SBB r8,r/m8 Subtract with borrow r/m8 from r8
\par 1B / r SBB r16,r/m16 Subtract with borrow r/m16 from r16
\par 1B / r SBB r32,r/m32 Subtract with borrow r/m32 from r32
{\page}

${\footnote SCAS,Description}
K{\footnote SCAS,SCAS;SCASB,SCASB;SCASD,SCASD;SCASW,SCASW;SCAS,Description;SCASB,Description;SCASD,Description;SCASW,Description}
#{\footnote SCAS::1}
#{\footnote SCASB::1}
#{\footnote SCASD::1}
#{\footnote SCASW::1}

{\fs20\b SCAS/SCASB/SCASD/SCASW}\tab{\b Description}\par\par
SCAS/SCASB/SCASW/SCASD: Scan String
\par 
\par Compares the byte, word, or double word specified with the memory operand with the value in the AL, AX, or EAX register, and sets the status flags in the EFLAGS register according to the results. The memory operand address is read from either the ES:EDI or the ES:DI registers (depending on the address-size attribute of the instruction, 32 or 16, respectively). The ES segment cannot be overridden with a segment override prefix. At the assembly-code level, two forms of this instruction are allowed: the "explicit-operands" form and the "no-operands" form. The explicit-operand form (specified with the SCAS mnemonic) allows the memory operand to be specified explicitly. Here, the memory operand should be a symbol that indicates the size and location of the operand value. The register operand is then automatically selected to match the size of the memory operand (the AL register for byte comparisons, AX for word comparisons, and EAX for doubleword comparisons). This explicit-operand form is provided to allow documentation; however, note that the documentation provided by this form can be misleading. That is, the memory operand symbol must specify the correct type (size) of the operand (byte, word, or doubleword), but it does not have to specify the correct location. The location is always specified by the ES:(E)DI registers, which must be loaded correctly before the compare string instruction is executed.
\par The no-operands form provides "short forms" of the byte, word, and doubleword versions of the SCAS instructions. Here also ES:(E)DI is assumed to be the memory operand and the AL, AX, or EAX register is assumed to be the register operand. The size of the two operands is selected with the mnemonic: SCASB (byte comparison), SCASW (word comparison), or SCASD (doubleword comparison).
\par After the comparison, the (E)DI register is incremented or decremented automatically according to the setting of the DF flag in the EFLAGS register. (If the DF flag is 0, the (E)DI register is incremented; if the DF flag is 1, the (E)DI register is decremented.) The (E)DI register is incremented or decremented by 1 for byte operations, by 2 for word operations, or by 4 for double-word operations.
\par The SCAS, SCASB, SCASW, and SCASD instructions can be preceded by the REP prefix for block comparisons of ECX bytes, words, or doublewords. More often, however, these instructions will be used in a LOOP construct that takes some action based on the setting of the status flags before the next comparison is made.
{\page}

${\footnote SCAS,Operation}
K{\footnote SCAS,SCAS;SCASB,SCASB;SCASD,SCASD;SCASW,SCASW;SCAS,Operation;SCASB,Operation;SCASD,Operation;SCASW,Operation}
#{\footnote SCAS::2}
#{\footnote SCASB::2}
#{\footnote SCASD::2}
#{\footnote SCASW::2}

{\fs20\b SCAS/SCASB/SCASD/SCASW}\tab{\b Operation}\par\par
IF (byte cmparison)
\par THEN
\par temp <- AL - SRC;
\par SetStatusFlags(temp);
\par THEN IF DF = 0
\par THEN (E)DI <- (E)DI + 1;
\par ELSE (E)DI <- (E)DI - 1;
\par FI;
\par ELSE IF (word comparison)
\par THEN
\par temp <- AX - SRC;
\par SetStatusFlags(temp)
\par THEN IF DF = 0
\par THEN (E)DI <- (E)DI + 2;
\par ELSE (E)DI <- (E)DI - 2;
\par FI;
\par ELSE (* doubleword comparison *)
\par temp <- EAX - SRC;
\par SetStatusFlags(temp)
\par THEN IF DF = 0
\par THEN (E)DI <- (E)DI + 4;
\par ELSE (E)DI <- (E)DI - 4;
\par FI;
\par FI;
\par FI;
{\page}

${\footnote SCAS,Flags affected}
K{\footnote SCAS,SCAS;SCASB,SCASB;SCASD,SCASD;SCASW,SCASW;SCAS,Flags affected;SCASB,Flags affected;SCASD,Flags affected;SCASW,Flags affected}
#{\footnote SCAS::3}
#{\footnote SCASB::3}
#{\footnote SCASD::3}
#{\footnote SCASW::3}

{\fs20\b SCAS/SCASB/SCASD/SCASW}\tab{\b Flags affected}\par\par
The OF, SF, ZF, AF, PF, and CF flags are set according to the temporary result of the comparison.
{\page}

${\footnote SCAS,Exceptions}
K{\footnote SCAS,SCAS;SCASB,SCASB;SCASD,SCASD;SCASW,SCASW;SCAS,Exceptions;SCASB,Exceptions;SCASD,Exceptions;SCASW,Exceptions}
#{\footnote SCAS::4}
#{\footnote SCASB::4}
#{\footnote SCASD::4}
#{\footnote SCASW::4}

{\fs20\b SCAS/SCASB/SCASD/SCASW}\tab{\b Exceptions}\par\par
Protected Mode Exceptions
\par 
\par #GP(0) If a memory operand effective address is outside the limit of the ES segment. If the ES register contains a null segment selector. If an illegal memory operand effective address in the ES segment is given.
\par #PF(fault-code) If a page fault occurs.
\par #AC(0) If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.
\par 
\par Real-Address Mode Exceptions
\par 
\par #GP If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.
\par #SS If a memory operand effective address is outside the SS segment limit.
\par 
\par Virtual-8086 Mode Exceptions
\par 
\par #GP(0) If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.
\par #SS(0) If a memory operand effective address is outside the SS segment limit.
\par #PF(fault-code) If a page fault occurs.
\par #AC(0) If alignment checking is enabled and an unaligned memory reference is made.
{\page}

${\footnote SCAS,Opcode}
K{\footnote SCAS,SCAS;SCASB,SCASB;SCASD,SCASD;SCASW,SCASW;SCAS,Opcode;SCASB,Opcode;SCASD,Opcode;SCASW,Opcode}
#{\footnote SCAS::5}
#{\footnote SCASB::5}
#{\footnote SCASD::5}
#{\footnote SCASW::5}

{\fs20\b SCAS/SCASB/SCASD/SCASW}\tab{\b Opcode}\par\par
AE SCAS m8 Compare AL with byte at ES:(E)DI and set status flags
\par AF SCAS m16 Compare AX with word at ES:(E)DI and set status flags
\par AF SCAS m32 Compare EAX with doubleword at ES(E)DI and set status flags
\par AE SCASB Compare AL with byte at ES:(E)DI and set status flags
\par AF SCASW Compare AX with word at ES:(E)DI and set status flags
\par AF SCASD Compare EAX with doubleword at ES:(E)DI and set status flags
{\page}

${\footnote SET,Description}
K{\footnote SET,SET;SETA,SETA;SETAE,SETAE;SETB,SETB;SETBE,SETBE;SETC,SETC;SETE,SETE;SETG,SETG;SETGE,SETGE;SETL,SETL;SETLE,SETLE;SETNA,SETNA;SETNAE,SETNAE;SETNB,SETNB;SETNBE,SETNBE;SETNC,SETNC;SETNE,SETNE;SETNG,SETNG;SETNGE,SETNGE;SETNL,SETNL;SETNLE,SETNLE;SETNO,SETNO;SETNP,SETNP;SETNS,SETNS;SETNZ,SETNZ;SETO,SETO;SETP,SETP;SETPE,SETPE;SETPO,SETPO;SETS,SETS;SETZ,SETZ;SET,Description;SETA,Description;SETAE,Description;SETB,Description;SETBE,Description;SETC,Description;SETE,Description;SETG,Description;SETGE,Description;SETL,Description;SETLE,Description;SETNA,Description;SETNAE,Description;SETNB,Description;SETNBE,Description;SETNC,Description;SETNE,Description;SETNG,Description;SETNGE,Description;SETNL,Description;SETNLE,Description;SETNO,Description;SETNP,Description;SETNS,Description;SETNZ,Description;SETO,Description;SETP,Description;SETPE,Description;SETPO,Description;SETS,Description;SETZ,Description}
#{\footnote SET::1}
#{\footnote SETA::1}
#{\footnote SETAE::1}
#{\footnote SETB::1}
#{\footnote SETBE::1}
#{\footnote SETC::1}
#{\footnote SETE::1}
#{\footnote SETG::1}
#{\footnote SETGE::1}
#{\footnote SETL::1}
#{\footnote SETLE::1}
#{\footnote SETNA::1}
#{\footnote SETNAE::1}
#{\footnote SETNB::1}
#{\footnote SETNBE::1}
#{\footnote SETNC::1}
#{\footnote SETNE::1}
#{\footnote SETNG::1}
#{\footnote SETNGE::1}
#{\footnote SETNL::1}
#{\footnote SETNLE::1}
#{\footnote SETNO::1}
#{\footnote SETNP::1}
#{\footnote SETNS::1}
#{\footnote SETNZ::1}
#{\footnote SETO::1}
#{\footnote SETP::1}
#{\footnote SETPE::1}
#{\footnote SETPO::1}
#{\footnote SETS::1}
#{\footnote SETZ::1}

{\fs20\b SET/SETA/SETAE/SETB/SETBE/SETC/SETE/SETG/SETGE/SETL/SETLE/SETNA/SETNAE/SETNB/SETNBE/SETNC/SETNE/SETNG/SETNGE/SETNL/SETNLE/SETNO/SETNP/SETNS/SETNZ/SETO/SETP/SETPE/SETPO/SETS/SETZ}\tab{\b Description}\par\par
SET cc: Set Byte on Condition
\par 
\par Set the destination operand to 0 or 1 depending on the settings of the status flags (CF, SF, OF, ZF, and PF) in the EFLAGS register. The destination operand points to a byte register or a byte in memory. The condition code suffix (cc) indicates the condition being tested for. The terms "above" and "below" are associated with the CF flag and refer to the relationship between two unsigned integer values. The terms "greater" and "less" are associated with the SF and OF flags and refer to the relationship between two signed integer values.
\par Many of the SETcc instruction opcodes have alternate mnemonics. For example, the SETG (set byte if greater) and SETNLE (set if not less or equal) both have the same opcode and test for the same condition: ZF equals 0 and SF equals OF. These alternate mnemonics are provided to make code more intelligible. Some languages represent a logical one as an integer with all bits set. This representation can be obtained by choosing the logically opposite condition for the SETcc instruction, then decrementing the result. For example, to test for overflow, use the SETNO instruction, then decrement the result.
{\page}

${\footnote SET,Operation}
K{\footnote SET,SET;SETA,SETA;SETAE,SETAE;SETB,SETB;SETBE,SETBE;SETC,SETC;SETE,SETE;SETG,SETG;SETGE,SETGE;SETL,SETL;SETLE,SETLE;SETNA,SETNA;SETNAE,SETNAE;SETNB,SETNB;SETNBE,SETNBE;SETNC,SETNC;SETNE,SETNE;SETNG,SETNG;SETNGE,SETNGE;SETNL,SETNL;SETNLE,SETNLE;SETNO,SETNO;SETNP,SETNP;SETNS,SETNS;SETNZ,SETNZ;SETO,SETO;SETP,SETP;SETPE,SETPE;SETPO,SETPO;SETS,SETS;SETZ,SETZ;SET,Operation;SETA,Operation;SETAE,Operation;SETB,Operation;SETBE,Operation;SETC,Operation;SETE,Operation;SETG,Operation;SETGE,Operation;SETL,Operation;SETLE,Operation;SETNA,Operation;SETNAE,Operation;SETNB,Operation;SETNBE,Operation;SETNC,Operation;SETNE,Operation;SETNG,Operation;SETNGE,Operation;SETNL,Operation;SETNLE,Operation;SETNO,Operation;SETNP,Operation;SETNS,Operation;SETNZ,Operation;SETO,Operation;SETP,Operation;SETPE,Operation;SETPO,Operation;SETS,Operation;SETZ,Operation}
#{\footnote SET::2}
#{\footnote SETA::2}
#{\footnote SETAE::2}
#{\footnote SETB::2}
#{\footnote SETBE::2}
#{\footnote SETC::2}
#{\footnote SETE::2}
#{\footnote SETG::2}
#{\footnote SETGE::2}
#{\footnote SETL::2}
#{\footnote SETLE::2}
#{\footnote SETNA::2}
#{\footnote SETNAE::2}
#{\footnote SETNB::2}
#{\footnote SETNBE::2}
#{\footnote SETNC::2}
#{\footnote SETNE::2}
#{\footnote SETNG::2}
#{\footnote SETNGE::2}
#{\footnote SETNL::2}
#{\footnote SETNLE::2}
#{\footnote SETNO::2}
#{\footnote SETNP::2}
#{\footnote SETNS::2}
#{\footnote SETNZ::2}
#{\footnote SETO::2}
#{\footnote SETP::2}
#{\footnote SETPE::2}
#{\footnote SETPO::2}
#{\footnote SETS::2}
#{\footnote SETZ::2}

{\fs20\b SET/SETA/SETAE/SETB/SETBE/SETC/SETE/SETG/SETGE/SETL/SETLE/SETNA/SETNAE/SETNB/SETNBE/SETNC/SETNE/SETNG/SETNGE/SETNL/SETNLE/SETNO/SETNP/SETNS/SETNZ/SETO/SETP/SETPE/SETPO/SETS/SETZ}\tab{\b Operation}\par\par
IF condition
\par THEN DEST <- 1
\par ELSE DEST <- 0;
\par FI;
{\page}

${\footnote SET,Flags affected}
K{\footnote SET,SET;SETA,SETA;SETAE,SETAE;SETB,SETB;SETBE,SETBE;SETC,SETC;SETE,SETE;SETG,SETG;SETGE,SETGE;SETL,SETL;SETLE,SETLE;SETNA,SETNA;SETNAE,SETNAE;SETNB,SETNB;SETNBE,SETNBE;SETNC,SETNC;SETNE,SETNE;SETNG,SETNG;SETNGE,SETNGE;SETNL,SETNL;SETNLE,SETNLE;SETNO,SETNO;SETNP,SETNP;SETNS,SETNS;SETNZ,SETNZ;SETO,SETO;SETP,SETP;SETPE,SETPE;SETPO,SETPO;SETS,SETS;SETZ,SETZ;SET,Flags affected;SETA,Flags affected;SETAE,Flags affected;SETB,Flags affected;SETBE,Flags affected;SETC,Flags affected;SETE,Flags affected;SETG,Flags affected;SETGE,Flags affected;SETL,Flags affected;SETLE,Flags affected;SETNA,Flags affected;SETNAE,Flags affected;SETNB,Flags affected;SETNBE,Flags affected;SETNC,Flags affected;SETNE,Flags affected;SETNG,Flags affected;SETNGE,Flags affected;SETNL,Flags affected;SETNLE,Flags affected;SETNO,Flags affected;SETNP,Flags affected;SETNS,Flags affected;SETNZ,Flags affected;SETO,Flags affected;SETP,Flags affected;SETPE,Flags affected;SETPO,Flags affected;SETS,Flags affected;SETZ,Flags affected}
#{\footnote SET::3}
#{\footnote SETA::3}
#{\footnote SETAE::3}
#{\footnote SETB::3}
#{\footnote SETBE::3}
#{\footnote SETC::3}
#{\footnote SETE::3}
#{\footnote SETG::3}
#{\footnote SETGE::3}
#{\footnote SETL::3}
#{\footnote SETLE::3}
#{\footnote SETNA::3}
#{\footnote SETNAE::3}
#{\footnote SETNB::3}
#{\footnote SETNBE::3}
#{\footnote SETNC::3}
#{\footnote SETNE::3}
#{\footnote SETNG::3}
#{\footnote SETNGE::3}
#{\footnote SETNL::3}
#{\footnote SETNLE::3}
#{\footnote SETNO::3}
#{\footnote SETNP::3}
#{\footnote SETNS::3}
#{\footnote SETNZ::3}
#{\footnote SETO::3}
#{\footnote SETP::3}
#{\footnote SETPE::3}
#{\footnote SETPO::3}
#{\footnote SETS::3}
#{\footnote SETZ::3}

{\fs20\b SET/SETA/SETAE/SETB/SETBE/SETC/SETE/SETG/SETGE/SETL/SETLE/SETNA/SETNAE/SETNB/SETNBE/SETNC/SETNE/SETNG/SETNGE/SETNL/SETNLE/SETNO/SETNP/SETNS/SETNZ/SETO/SETP/SETPE/SETPO/SETS/SETZ}\tab{\b Flags affected}\par\par
None.
{\page}

${\footnote SET,Exceptions}
K{\footnote SET,SET;SETA,SETA;SETAE,SETAE;SETB,SETB;SETBE,SETBE;SETC,SETC;SETE,SETE;SETG,SETG;SETGE,SETGE;SETL,SETL;SETLE,SETLE;SETNA,SETNA;SETNAE,SETNAE;SETNB,SETNB;SETNBE,SETNBE;SETNC,SETNC;SETNE,SETNE;SETNG,SETNG;SETNGE,SETNGE;SETNL,SETNL;SETNLE,SETNLE;SETNO,SETNO;SETNP,SETNP;SETNS,SETNS;SETNZ,SETNZ;SETO,SETO;SETP,SETP;SETPE,SETPE;SETPO,SETPO;SETS,SETS;SETZ,SETZ;SET,Exceptions;SETA,Exceptions;SETAE,Exceptions;SETB,Exceptions;SETBE,Exceptions;SETC,Exceptions;SETE,Exceptions;SETG,Exceptions;SETGE,Exceptions;SETL,Exceptions;SETLE,Exceptions;SETNA,Exceptions;SETNAE,Exceptions;SETNB,Exceptions;SETNBE,Exceptions;SETNC,Exceptions;SETNE,Exceptions;SETNG,Exceptions;SETNGE,Exceptions;SETNL,Exceptions;SETNLE,Exceptions;SETNO,Exceptions;SETNP,Exceptions;SETNS,Exceptions;SETNZ,Exceptions;SETO,Exceptions;SETP,Exceptions;SETPE,Exceptions;SETPO,Exceptions;SETS,Exceptions;SETZ,Exceptions}
#{\footnote SET::4}
#{\footnote SETA::4}
#{\footnote SETAE::4}
#{\footnote SETB::4}
#{\footnote SETBE::4}
#{\footnote SETC::4}
#{\footnote SETE::4}
#{\footnote SETG::4}
#{\footnote SETGE::4}
#{\footnote SETL::4}
#{\footnote SETLE::4}
#{\footnote SETNA::4}
#{\footnote SETNAE::4}
#{\footnote SETNB::4}
#{\footnote SETNBE::4}
#{\footnote SETNC::4}
#{\footnote SETNE::4}
#{\footnote SETNG::4}
#{\footnote SETNGE::4}
#{\footnote SETNL::4}
#{\footnote SETNLE::4}
#{\footnote SETNO::4}
#{\footnote SETNP::4}
#{\footnote SETNS::4}
#{\footnote SETNZ::4}
#{\footnote SETO::4}
#{\footnote SETP::4}
#{\footnote SETPE::4}
#{\footnote SETPO::4}
#{\footnote SETS::4}
#{\footnote SETZ::4}

{\fs20\b SET/SETA/SETAE/SETB/SETBE/SETC/SETE/SETG/SETGE/SETL/SETLE/SETNA/SETNAE/SETNB/SETNBE/SETNC/SETNE/SETNG/SETNGE/SETNL/SETNLE/SETNO/SETNP/SETNS/SETNZ/SETO/SETP/SETPE/SETPO/SETS/SETZ}\tab{\b Exceptions}\par\par
Protected Mode Exceptions
\par 
\par #GP(0) If the destination is located in a nonwritable segment. If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit. If the DS, ES, FS, or GS register contains a null segment selector.
\par #SS(0) If a memory operand effective address is outside the SS segment limit.
\par #PF(fault-code) If a page fault occurs.
\par 
\par Real-Address Mode Exceptions
\par 
\par #GP If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.
\par #SS If a memory operand effective address is outside the SS segment limit.
\par 
\par Virtual-8086 Mode Exceptions
\par 
\par #GP(0) If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.
\par #SS(0) If a memory operand effective address is outside the SS segment limit.
\par #PF(fault-code) If a page fault occurs.
{\page}

${\footnote SET,Opcode}
K{\footnote SET,SET;SETA,SETA;SETAE,SETAE;SETB,SETB;SETBE,SETBE;SETC,SETC;SETE,SETE;SETG,SETG;SETGE,SETGE;SETL,SETL;SETLE,SETLE;SETNA,SETNA;SETNAE,SETNAE;SETNB,SETNB;SETNBE,SETNBE;SETNC,SETNC;SETNE,SETNE;SETNG,SETNG;SETNGE,SETNGE;SETNL,SETNL;SETNLE,SETNLE;SETNO,SETNO;SETNP,SETNP;SETNS,SETNS;SETNZ,SETNZ;SETO,SETO;SETP,SETP;SETPE,SETPE;SETPO,SETPO;SETS,SETS;SETZ,SETZ;SET,Opcode;SETA,Opcode;SETAE,Opcode;SETB,Opcode;SETBE,Opcode;SETC,Opcode;SETE,Opcode;SETG,Opcode;SETGE,Opcode;SETL,Opcode;SETLE,Opcode;SETNA,Opcode;SETNAE,Opcode;SETNB,Opcode;SETNBE,Opcode;SETNC,Opcode;SETNE,Opcode;SETNG,Opcode;SETNGE,Opcode;SETNL,Opcode;SETNLE,Opcode;SETNO,Opcode;SETNP,Opcode;SETNS,Opcode;SETNZ,Opcode;SETO,Opcode;SETP,Opcode;SETPE,Opcode;SETPO,Opcode;SETS,Opcode;SETZ,Opcode}
#{\footnote SET::5}
#{\footnote SETA::5}
#{\footnote SETAE::5}
#{\footnote SETB::5}
#{\footnote SETBE::5}
#{\footnote SETC::5}
#{\footnote SETE::5}
#{\footnote SETG::5}
#{\footnote SETGE::5}
#{\footnote SETL::5}
#{\footnote SETLE::5}
#{\footnote SETNA::5}
#{\footnote SETNAE::5}
#{\footnote SETNB::5}
#{\footnote SETNBE::5}
#{\footnote SETNC::5}
#{\footnote SETNE::5}
#{\footnote SETNG::5}
#{\footnote SETNGE::5}
#{\footnote SETNL::5}
#{\footnote SETNLE::5}
#{\footnote SETNO::5}
#{\footnote SETNP::5}
#{\footnote SETNS::5}
#{\footnote SETNZ::5}
#{\footnote SETO::5}
#{\footnote SETP::5}
#{\footnote SETPE::5}
#{\footnote SETPO::5}
#{\footnote SETS::5}
#{\footnote SETZ::5}

{\fs20\b SET/SETA/SETAE/SETB/SETBE/SETC/SETE/SETG/SETGE/SETL/SETLE/SETNA/SETNAE/SETNB/SETNBE/SETNC/SETNE/SETNG/SETNGE/SETNL/SETNLE/SETNO/SETNP/SETNS/SETNZ/SETO/SETP/SETPE/SETPO/SETS/SETZ}\tab{\b Opcode}\par\par
0F 97 SETA r/m8 Set byte if above (CF=0 and ZF=0)
\par 0F 93 SETAE r/m8 Set byte if above or equal (CF=0)
\par 0F 92 SETB r/m8 Set byte if below (CF=1)
\par 0F 96 SETBE r/m8 Set byte if below or equal (CF=1 or ZF=1)
\par 0F 92 SETC r/m8 Set if carry (CF=1)
\par 0F 94 SETE r/m8 Set byte if equal (ZF=1)
\par 0F 9F SETG r/m8 Set byte if greater (ZF=0 and SF=OF)
\par 0F 9D SETGE r/m8 Set byte if greater or equal (SF=OF)
\par 0F 9C SETL r/m8 Set byte if less (SF<>OF)
\par 0F 9E SETLE r/m8 Set byte if less or equal (ZF=1 or SF<>OF)
\par 0F 96 SETNA r/m8 Set byte if not above (CF=1 or ZF=1)
\par 0F 92 SETNAE r/m8 Set byte if not above or equal (CF=1)
\par 0F 93 SETNB r/m8 Set byte if not below (CF=0)
\par 0F 97 SETNBE r/m8 Set byte if not below or equal (CF=0 and ZF=0)
\par 0F 93 SETNC r/m8 Set byte if not carry (CF=0)
\par 0F 95 SETNE r/m8 Set byte if not equal (ZF=0)
\par 0F 9E SETNG r/m8 Set byte if not greater (ZF=1 or SF<>OF)
\par 0F 9C SETNGE r/m8 Set if not greater or equal (SF<>OF)
\par 0F 9D SETNL r/m8 Set byte if not less (SF=OF)
\par 0F 9F SETNLE r/m8 Set byte if not less or equal (ZF=0 and SF=OF)
\par 0F 91 SETNO r/m8 Set byte if not overflow (OF=0)
\par 0F 9B SETNP r/m8 Set byte if not parity (PF=0)
\par 0F 99 SETNS r/m8 Set byte if not sign (SF=0)
\par 0F 95 SETNZ r/m8 Set byte if not zero (ZF=0)
\par 0F 90 SETO r/m8 Set byte if overflow (OF=1)
\par 0F 9A SETP r/m8 Set byte if parity (PF=1)
\par 0F 9A SETPE r/m8 Set byte if parity even (PF=1)
\par 0F 9B SETPO r/m8 Set byte if parity odd (PF=0)
\par 0F 98 SETS r/m8 Set byte if sign (SF=1)
\par 0F 94 SETZ r/m8 Set byte if zero (ZF=1)
{\page}

${\footnote SGDT,Description}
K{\footnote SGDT,SGDT;SIDT,SIDT;SGDT,Description;SIDT,Description}
#{\footnote SGDT::1}
#{\footnote SIDT::1}

{\fs20\b SGDT/SIDT}\tab{\b Description}\par\par
SGDT/SIDT: Store Global/Interrupt Descriptor Table Register
\par 
\par Stores the contents of the global descriptor table register (GDTR) or the interrupt descriptor table register (IDTR) in the destination operand. The destination operand specifies a 6-byte memory location. If the operand-size attribute is 32 bits, the 16-bit limit field of the register is stored in the lower 2 bytes of the memory location and the 32-bit base address is stored in the upper 4 bytes. If the operand-size attribute is 16 bits, the limit is stored in the lower 2 bytes and the 24-bit base address is stored in the third, fourth, and fifth byte, with the sixth byte filled with 0s.
\par The SGDT and SIDT instructions are only useful in operating-system software; however, they can be used in application programs without causing an exception to be generated.
\par 
\par Intel Architecture Compatibility
\par 
\par The 16-bit forms of the SGDT and SIDT instructions are compatible with the Intel 286 processor, if the upper 8 bits are not referenced. The Intel 286 processor fills these bits with 1s; the Pentium Pro, Pentium, Intel486, and Intel386 processors fill these bits with 0s.
{\page}

${\footnote SGDT,Operation}
K{\footnote SGDT,SGDT;SIDT,SIDT;SGDT,Operation;SIDT,Operation}
#{\footnote SGDT::2}
#{\footnote SIDT::2}

{\fs20\b SGDT/SIDT}\tab{\b Operation}\par\par
IF instruction is IDTR
\par THEN
\par IF OperandSize = 16
\par THEN
\par DEST[0:15] <- IDTR(Limit);
\par DEST[16:39] <- IDTR(Base); (* 24 bits of base address loaded; *)
\par DEST[40:47] <- 0;
\par ELSE (* 32-bit Operand Size *)
\par DEST[0:15] <- IDTR(Limit);
\par DEST[16:47] <- IDTR(Base); (* full 32-bit base address loaded *)
\par FI;
\par ELSE (* instruction is SGDT *)
\par IF OperandSize = 16
\par THEN
\par DEST[0:15] <- GDTR(Limit);
\par DEST[16:39] <- GDTR(Base); (* 24 bits of base address loaded; *)
\par DEST[40:47] <- 0;
\par ELSE (* 32-bit Operand Size *)
\par DEST[0:15] <- GDTR(Limit);
\par DEST[16:47] <- GDTR(Base); (* full 32-bit base address loaded *)
\par FI;
\par FI;
{\page}

${\footnote SGDT,Flags affected}
K{\footnote SGDT,SGDT;SIDT,SIDT;SGDT,Flags affected;SIDT,Flags affected}
#{\footnote SGDT::3}
#{\footnote SIDT::3}

{\fs20\b SGDT/SIDT}\tab{\b Flags affected}\par\par
None.
{\page}

${\footnote SGDT,Exceptions}
K{\footnote SGDT,SGDT;SIDT,SIDT;SGDT,Exceptions;SIDT,Exceptions}
#{\footnote SGDT::4}
#{\footnote SIDT::4}

{\fs20\b SGDT/SIDT}\tab{\b Exceptions}\par\par
Protected Mode Exceptions
\par 
\par #UD If the destination operand is a register.
\par #GP(0) If the destination is located in a nonwritable segment. If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit. If the DS, ES, FS, or GS register is used to access memory and it contains a null segment selector.
\par #SS(0) If a memory operand effective address is outside the SS segment limit.
\par #PF(fault-code) If a page fault occurs.
\par #AC(0) If an unaligned memory access occurs when the CPL is 3 and alignment checking is enabled.
\par 
\par Real-Address Mode Exceptions
\par 
\par #UD If the destination operand is a register.
\par #GP If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.
\par #SS If a memory operand effective address is outside the SS segment limit.
\par 
\par Virtual-8086 Mode Exceptions
\par 
\par #UD If the destination operand is a register.
\par #GP(0) If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.
\par #SS(0) If a memory operand effective address is outside the SS segment limit.
\par #PF(fault-code) If a page fault occurs.
\par #AC(0) If an unaligned memory access occurs when alignment checking is enabled.
{\page}

${\footnote SGDT,Opcode}
K{\footnote SGDT,SGDT;SIDT,SIDT;SGDT,Opcode;SIDT,Opcode}
#{\footnote SGDT::5}
#{\footnote SIDT::5}

{\fs20\b SGDT/SIDT}\tab{\b Opcode}\par\par
0F 01 /0 SGDT m Store GDTR to m
\par 0F 01 /1 SIDT m Store IDTR to m
{\page}

${\footnote SHLD,Description}
K{\footnote SHLD,SHLD;SHLD,Description}
#{\footnote SHLD::1}

{\fs20\b SHLD}\tab{\b Description}\par\par
SHLD: Double Precision Shift Left
\par 
\par Shifts the first operand (destination operand) to the left the number of bits specified by the third operand (count operand). The second operand (source operand) provides bits to shift in from the right (starting with bit 0 of the destination operand). The destination operand can be a register or a memory location; the source operand is a register. The count operand is an unsigned integer that can be an immediate byte or the contents of the CL register. Only bits 0 through 4 of the count are used, which masks the count to a value between 0 and 31. If the count is greater than the operand size, the result in the destination operand is undefined.
\par If the count is 1 or greater, the CF flag is filled with the last bit shifted out of the destination operand. For a 1-bit shift, the OF flag is set if a sign change occurred; otherwise, it is cleared. If the count operand is 0, the flags are not affected. The SHLD instruction is useful for multiprecision shifts of 64 bits or more.
{\page}

${\footnote SHLD,Operation}
K{\footnote SHLD,SHLD;SHLD,Operation}
#{\footnote SHLD::2}

{\fs20\b SHLD}\tab{\b Operation}\par\par
COUNT <- COUNT MOD 32;
\par SIZE <- OperandSize
\par IF COUNT = 0
\par THEN
\par no operation
\par ELSE
\par IF COUNT  SIZE
\par THEN (* Bad parameters *)
\par DEST is undefined;
\par CF, OF, SF, ZF, AF, PF are undefined;
\par ELSE (* Perform the shift *)
\par CF <- BIT[DEST, SIZE - COUNT];
\par (* Last bit shifted out on exit *)
\par FOR i <- SIZE - 1 DOWNTO COUNT
\par DO
\par Bit(DEST, i) <- Bit(DEST, i - COUNT);
\par OD;
\par FOR i <- COUNT - 1 DOWNTO 0
\par DO
\par BIT[DEST, i] <- BIT[SRC, i - COUNT + SIZE];
\par OD;
\par FI;
\par FI;
{\page}

${\footnote SHLD,Flags affected}
K{\footnote SHLD,SHLD;SHLD,Flags affected}
#{\footnote SHLD::3}

{\fs20\b SHLD}\tab{\b Flags affected}\par\par
If the count is 1 or greater, the CF flag is filled with the last bit shifted out of the destination operand and the SF, ZF, and PF flags are set according to the value of the result. For a 1-bit shift, the OF flag is set if a sign change occurred; otherwise, it is cleared. For shifts greater than 1 bit, the OF flag is undefined. If a shift occurs, the AF flag is undefined. If the count operand is 0, the flags are not affected. If the count is greater than the operand size, the flags are undefined.
{\page}

${\footnote SHLD,Exceptions}
K{\footnote SHLD,SHLD;SHLD,Exceptions}
#{\footnote SHLD::4}

{\fs20\b SHLD}\tab{\b Exceptions}\par\par
Protected Mode Exceptions
\par 
\par #GP(0) If the destination is located in a nonwritable segment. If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit. If the DS, ES, FS, or GS register contains a null segment selector.
\par #SS(0) If a memory operand effective address is outside the SS segment limit.
\par #PF(fault-code) If a page fault occurs.
\par #AC(0) If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.
\par 
\par Real-Address Mode Exceptions
\par 
\par #GP If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.
\par #SS If a memory operand effective address is outside the SS segment limit.
\par 
\par Virtual-8086 Mode Exceptions
\par 
\par #GP(0) If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.
\par #SS(0) If a memory operand effective address is outside the SS segment limit.
\par #PF(fault-code) If a page fault occurs.
\par #AC(0) If alignment checking is enabled and an unaligned memory reference is made.
{\page}

${\footnote SHLD,Opcode}
K{\footnote SHLD,SHLD;SHLD,Opcode}
#{\footnote SHLD::5}

{\fs20\b SHLD}\tab{\b Opcode}\par\par
0F A4 SHLD r/m16,r16,imm8 Shift r/m16 to left imm8 places while shifting bits from r16 in from the right
\par 0F A5 SHLD r/m16,r16,CL Shift r/m16 to left CL places while shifting bits from r16 in from the right
\par 0F A4 SHLD r/m32,r32,imm8 Shift r/m32 to left imm8 places while shifting bits from r32 in from the right
\par 0F A5 SHLD r/m32,r32,CL Shift r/m32 to left CL places while shifting bits from r32 in from the right
{\page}

${\footnote SHRD,Description}
K{\footnote SHRD,SHRD;SHRD,Description}
#{\footnote SHRD::1}

{\fs20\b SHRD}\tab{\b Description}\par\par
SHRD: Double Precision Shift Right
\par 
\par Shifts the first operand (destination operand) to the right the number of bits specified by the third operand (count operand). The second operand (source operand) provides bits to shift in from the left (starting with the most significant bit of the destination operand). The destination operand can be a register or a memory location; the source operand is a register. The count operand is an unsigned integer that can be an immediate byte or the contents of the CL register. Only bits 0 through 4 of the count are used, which masks the count to a value between 0 and 31. If the count is greater than the operand size, the result in the destination operand is undefined.
\par If the count is 1 or greater, the CF flag is filled with the last bit shifted out of the destination operand. For a 1-bit shift, the OF flag is set if a sign change occurred; otherwise, it is cleared. If the count operand is 0, the flags are not affected. The SHRD instruction is useful for multiprecision shifts of 64 bits or more.
{\page}

${\footnote SHRD,Operation}
K{\footnote SHRD,SHRD;SHRD,Operation}
#{\footnote SHRD::2}

{\fs20\b SHRD}\tab{\b Operation}\par\par
COUNT <- COUNT MOD 32;
\par SIZE <- OperandSize
\par IF COUNT = 0
\par THEN
\par no operation
\par ELSE
\par IF COUNT  SIZE
\par THEN (* Bad parameters *)
\par DEST is undefined;
\par CF, OF, SF, ZF, AF, PF are undefined;
\par ELSE (* Perform the shift *)
\par CF <- BIT[DEST, COUNT - 1]; (* last bit shifted out on exit *)
\par FOR i <- 0 TO SIZE - 1 - COUNT
\par DO
\par BIT[DEST, i] <- BIT[DEST , i - COUNT];
\par OD;
\par FOR i <- SIZE - COUNT TO SIZE - 1
\par DO
\par BIT[DEST ,i] <- BIT[inBits,i+COUNT - SIZE];
\par OD;
\par FI;
\par FI;
{\page}

${\footnote SHRD,Flags affected}
K{\footnote SHRD,SHRD;SHRD,Flags affected}
#{\footnote SHRD::3}

{\fs20\b SHRD}\tab{\b Flags affected}\par\par
If the count is 1 or greater, the CF flag is filled with the last bit shifted out of the destination operand and the SF, ZF, and PF flags are set according to the value of the result. For a 1-bit shift, the OF flag is set if a sign change occurred; otherwise, it is cleared. For shifts greater than 1 bit, the OF flag is undefined. If a shift occurs, the AF flag is undefined. If the count operand is 0, the flags are not affected. If the count is greater than the operand size, the flags are undefined.
{\page}

${\footnote SHRD,Exceptions}
K{\footnote SHRD,SHRD;SHRD,Exceptions}
#{\footnote SHRD::4}

{\fs20\b SHRD}\tab{\b Exceptions}\par\par
Protected Mode Exceptions
\par 
\par #GP(0) If the destination is located in a nonwritable segment. If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit. If the DS, ES, FS, or GS register contains a null segment selector.
\par #SS(0) If a memory operand effective address is outside the SS segment limit.
\par #PF(fault-code) If a page fault occurs.
\par #AC(0) If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.
\par 
\par Real-Address Mode Exceptions
\par 
\par #GP If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.
\par #SS If a memory operand effective address is outside the SS segment limit.
\par 
\par Virtual-8086 Mode Exceptions
\par 
\par #GP(0) If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.
\par #SS(0) If a memory operand effective address is outside the SS segment limit.
\par #PF(fault-code) If a page fault occurs.
\par #AC(0) If alignment checking is enabled and an unaligned memory reference is made.
{\page}

${\footnote SHRD,Opcode}
K{\footnote SHRD,SHRD;SHRD,Opcode}
#{\footnote SHRD::5}

{\fs20\b SHRD}\tab{\b Opcode}\par\par
0F AC SHRD r/m16,r16,imm8 Shift r/m16 to right imm8 places while shifting bits from r16 in from the left
\par 0F AD SHRD r/m16,r16,CL Shift r/m16 to right CL places while shifting bits from r16 in from the left
\par 0F AC SHRD r/m32,r32,imm8 Shift r/m32 to right imm8 places while shifting bits from r32 in from the left
\par 0F AD SHRD r/m32,r32,CL Shift r/m32 to right CL places while shifting bits from r32 in from the left
{\page}

${\footnote SLDT,Description}
K{\footnote SLDT,SLDT;SLDT,Description}
#{\footnote SLDT::1}

{\fs20\b SLDT}\tab{\b Description}\par\par
SLDT: Store Local Descriptor Table Register
\par 
\par Stores the segment selector from the local descriptor table register (LDTR) in the destination operand. The destination operand can be a general-purpose register or a memory location. The segment selector stored with this instruction points to the segment descriptor (located in the GDT) for the current LDT. This instruction can only be executed in protected mode.
\par When the destination operand is a 32-bit register, the 16-bit segment selector is copied into the lower-order 16 bits of the register. The high-order 16 bits of the register are cleared to 0s for the Pentium Pro processor and are undefined for Pentium, Intel486, and Intel386 processors. When the destination operand is a memory location, the segment selector is written to memory as a 16-bit quantity, regardless of the operand size. The SLDT instruction is only useful in operating-system software; however, it can be used in application programs.
{\page}

${\footnote SLDT,Operation}
K{\footnote SLDT,SLDT;SLDT,Operation}
#{\footnote SLDT::2}

{\fs20\b SLDT}\tab{\b Operation}\par\par
DEST <- LDTR(SegmentSelector);
{\page}

${\footnote SLDT,Flags affected}
K{\footnote SLDT,SLDT;SLDT,Flags affected}
#{\footnote SLDT::3}

{\fs20\b SLDT}\tab{\b Flags affected}\par\par
None.
{\page}

${\footnote SLDT,Exceptions}
K{\footnote SLDT,SLDT;SLDT,Exceptions}
#{\footnote SLDT::4}

{\fs20\b SLDT}\tab{\b Exceptions}\par\par
Protected Mode Exceptions
\par 
\par #GP(0) If the destination is located in a nonwritable segment. If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit. If the DS, ES, FS, or GS register is used to access memory and it contains a null segment selector.
\par #SS(0) If a memory operand effective address is outside the SS segment limit.
\par #PF(fault-code) If a page fault occurs.
\par #AC(0) If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.
\par 
\par Real-Address Mode Exceptions
\par 
\par #UD The SLDT instruction is not recognized in real-address mode.
\par 
\par Virtual-8086 Mode Exceptions
\par 
\par #UD The SLDT instruction is not recognized in virtual-8086 mode.
{\page}

${\footnote SLDT,Opcode}
K{\footnote SLDT,SLDT;SLDT,Opcode}
#{\footnote SLDT::5}

{\fs20\b SLDT}\tab{\b Opcode}\par\par
0F 00 /0 SLDT r/m16 Stores segment selector from LDTR in r/m16
\par 0F 00 /0 SLDT r/m32 Store segment selector from LDTR in low-order 16 bits of r/m32
{\page}

${\footnote SMSW,Description}
K{\footnote SMSW,SMSW;SMSW,Description}
#{\footnote SMSW::1}

{\fs20\b SMSW}\tab{\b Description}\par\par
SMSW: Store Machine Status Word
\par 
\par Stores the machine status word (bits 0 through 15 of control register CR0) into the destination operand. The destination operand can be a 16-bit general-purpose register or a memory location. When the destination operand is a 32-bit register, the low-order 16 bits of register CR0 are copied into the low-order 16 bits of the register and the upper 16 bits of the register are undefined.
\par When the destination operand is a memory location, the low-order 16 bits of register CR0 are written to memory as a 16-bit quantity, regardless of the operand size. The SMSW instruction is only useful in operating-system software; however, it is not a privileged instruction and can be used in application programs. This instruction is provided for compatibility with the Intel 286 processor. Programs and procedures intended to run on the Pentium Pro, Pentium, Intel486, and Intel386 processors should use the MOV (control registers) instruction to load the machine status word.
{\page}

${\footnote SMSW,Operation}
K{\footnote SMSW,SMSW;SMSW,Operation}
#{\footnote SMSW::2}

{\fs20\b SMSW}\tab{\b Operation}\par\par
DEST <- CR0[15:0]; (* Machine status word *);
{\page}

${\footnote SMSW,Flags affected}
K{\footnote SMSW,SMSW;SMSW,Flags affected}
#{\footnote SMSW::3}

{\fs20\b SMSW}\tab{\b Flags affected}\par\par
None.
{\page}

${\footnote SMSW,Exceptions}
K{\footnote SMSW,SMSW;SMSW,Exceptions}
#{\footnote SMSW::4}

{\fs20\b SMSW}\tab{\b Exceptions}\par\par
Protected Mode Exceptions
\par 
\par #GP(0) If the destination is located in a nonwritable segment. If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit. If the DS, ES, FS, or GS register is used to access memory and it contains a null segment selector.
\par #SS(0) If a memory operand effective address is outside the SS segment limit.
\par #PF(fault-code) If a page fault occurs.
\par #AC(0) If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.
\par 
\par Real-Address Mode Exceptions
\par 
\par #GP If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.
\par #SS(0) If a memory operand effective address is outside the SS segment limit.
\par 
\par Virtual-8086 Mode Exceptions
\par 
\par #GP(0) If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.
\par #SS(0) If a memory operand effective address is outside the SS segment limit.
\par #PF(fault-code) If a page fault occurs.
\par #AC(0) If alignment checking is enabled and an unaligned memory reference is made.
{\page}

${\footnote SMSW,Opcode}
K{\footnote SMSW,SMSW;SMSW,Opcode}
#{\footnote SMSW::5}

{\fs20\b SMSW}\tab{\b Opcode}\par\par
0F 01 /4 SMSW r/m16 Store machine status word to r/m16
\par 0F 01 /4 SMSW r32/m16 Store machine status word in low-order 16 bits of r32/m16; high-order 16 bits of r32 are undefined
{\page}

${\footnote STC,Description}
K{\footnote STC,STC;STC,Description}
#{\footnote STC::1}

{\fs20\b STC}\tab{\b Description}\par\par
STC: Set Carry Flag
\par 
\par Sets the CF flag in the EFLAGS register.
{\page}

${\footnote STC,Operation}
K{\footnote STC,STC;STC,Operation}
#{\footnote STC::2}

{\fs20\b STC}\tab{\b Operation}\par\par
CF <- 1;
{\page}

${\footnote STC,Flags affected}
K{\footnote STC,STC;STC,Flags affected}
#{\footnote STC::3}

{\fs20\b STC}\tab{\b Flags affected}\par\par
The CF flag is set. The OF, ZF, SF, AF, and PF flags are unaffected.
{\page}

${\footnote STC,Exceptions}
K{\footnote STC,STC;STC,Exceptions}
#{\footnote STC::4}

{\fs20\b STC}\tab{\b Exceptions}\par\par
(All Operating Modes)
\par None.
{\page}

${\footnote STC,Opcode}
K{\footnote STC,STC;STC,Opcode}
#{\footnote STC::5}

{\fs20\b STC}\tab{\b Opcode}\par\par
F9 STC Set CF flag
{\page}

${\footnote STD,Description}
K{\footnote STD,STD;STD,Description}
#{\footnote STD::1}

{\fs20\b STD}\tab{\b Description}\par\par
STD: Set Direction Flag
\par 
\par Sets the DF flag in the EFLAGS register. When the DF flag is set to 1, string operations decrement the index registers (ESI and/or EDI).
{\page}

${\footnote STD,Operation}
K{\footnote STD,STD;STD,Operation}
#{\footnote STD::2}

{\fs20\b STD}\tab{\b Operation}\par\par
DF <- 1;
{\page}

${\footnote STD,Flags affected}
K{\footnote STD,STD;STD,Flags affected}
#{\footnote STD::3}

{\fs20\b STD}\tab{\b Flags affected}\par\par
The DF flag is set. The CF, OF, ZF, SF, AF, and PF flags are unaffected.
{\page}

${\footnote STD,Exceptions}
K{\footnote STD,STD;STD,Exceptions}
#{\footnote STD::4}

{\fs20\b STD}\tab{\b Exceptions}\par\par
(All Operating Modes)
\par None.
{\page}

${\footnote STD,Opcode}
K{\footnote STD,STD;STD,Opcode}
#{\footnote STD::5}

{\fs20\b STD}\tab{\b Opcode}\par\par
FD STD Set DF flag
{\page}

${\footnote STI,Description}
K{\footnote STI,STI;STI,Description}
#{\footnote STI::1}

{\fs20\b STI}\tab{\b Description}\par\par
STI: Set Interrupt Flag
\par 
\par Sets the interrupt flag (IF) in the EFLAGS register. After the IF flag is set, the processor begins responding to external, maskable interrupts after the next instruction is executed. The delayed effect of this instruction is provided to allow interrupts to be enabled just before returning from a procedure (or subroutine). For instance, if an STI instruction is followed by an RET instruction, the RET instruction is allowed to execute before external interrupts are recognized 1 . This behavior allows external interrupts to be disabled at the beginning of a procedure and enabled again at the end of the procedure. If the STI instruction is followed by a CLI instruction (which clears the IF flag), the effect of the STI instruction is negated. The IF flag and the STI and CLI instructions have no affect on the generation of exceptions and NMI interrupts.
{\page}

${\footnote STI,Operation}
K{\footnote STI,STI;STI,Operation}
#{\footnote STI::2}

{\fs20\b STI}\tab{\b Operation}\par\par
IF PE=0 (* Executing in real-address mode *)
\par THEN
\par IF <- 1; (* Set Interrupt Flag *)
\par ELSE (* Executing in protected mode or virtual-8086 mode *)
\par IF VM=0 (* Executing in protected mode*)
\par THEN
\par IF IOPL = 3
\par THEN
\par IF <- 1;
\par ELSE
\par IF CPL  IOPL
\par THEN
\par IF <- 1;
\par ELSE
\par #GP(0);
\par FI;
\par FI;
\par ELSE (* Executing in Virtual-8086 mode *)
\par #GP(0); (* Trap to virtual-8086 monitor *)
\par FI;
\par FI;
{\page}

${\footnote STI,Flags affected}
K{\footnote STI,STI;STI,Flags affected}
#{\footnote STI::3}

{\fs20\b STI}\tab{\b Flags affected}\par\par
The IF flag is set to 1.
{\page}

${\footnote STI,Exceptions}
K{\footnote STI,STI;STI,Exceptions}
#{\footnote STI::4}

{\fs20\b STI}\tab{\b Exceptions}\par\par
Protected Mode Exceptions
\par 
\par #GP(0) If the CPL is greater (has less privilege) than the IOPL of the current program or procedure.
\par 
\par Real-Address Mode Exceptions
\par 
\par None.
\par 
\par Virtual-8086 Mode Exceptions
\par 
\par #GP(0) If the CPL is greater (has less privilege) than the IOPL of the current program or procedure.
{\page}

${\footnote STI,Opcode}
K{\footnote STI,STI;STI,Opcode}
#{\footnote STI::5}

{\fs20\b STI}\tab{\b Opcode}\par\par
FB STI Set interrupt flag; external, maskable interrupts enabled
{\page}

${\footnote STOS,Description}
K{\footnote STOS,STOS;STOSB,STOSB;STOSD,STOSD;STOSW,STOSW;STOS,Description;STOSB,Description;STOSD,Description;STOSW,Description}
#{\footnote STOS::1}
#{\footnote STOSB::1}
#{\footnote STOSD::1}
#{\footnote STOSW::1}

{\fs20\b STOS/STOSB/STOSD/STOSW}\tab{\b Description}\par\par
STOS/STOSB/STOSW/STOSD: Store String
\par 
\par Stores a byte, word, or doubleword from the AL, AX, or EAX register, respectively, into the destination operand. The destination operand is a memory location, the address of which is read from either the ES:EDI or the ES:DI registers (depending on the address-size attribute of the instruction, 32 or 16, respectively). The ES segment cannot be overridden with a segment override prefix.
\par At the assembly-code level, two forms of this instruction are allowed: the "explicit-operands" form and the "no-operands" form. The explicit-operands form (specified with the STOS mnemonic) allows the destination operand to be specified explicitly. Here, the destination operand should be a symbol that indicates the size and location of the destination value. The source operand is then automatically selected to match the size of the destination operand (the AL register for byte operands, AX for word operands, and EAX for doubleword operands). This explicit-operands form is provided to allow documentation; however, note that the documentation provided by this form can be misleading. That is, the destination operand symbol must specify the correct type (size) of the operand (byte, word, or doubleword), but it does not have to specify the correct location. The location is always specified by the ES:(E)DI registers, which must be loaded correctly before the store string instruction is executed.
\par The no-operands form provides "short forms" of the byte, word, and doubleword versions of the STOS instructions. Here also ES:(E)DI is assumed to be the destination operand and the AL, AX, or EAX register is assumed to be the source operand. The size of the destination and source operands is selected with the mnemonic: STOSB (byte read from register AL), STOSW (word from AX), or STOSD (doubleword from EAX). After the byte, word, or doubleword is transferred from the AL, AX, or EAX register to the memory location, the (E)DI register is incremented or decremented automatically according to the setting of the DF flag in the EFLAGS register. (If the DF flag is 0, the (E)DI register is incremented; if the DF flag is 1, the (E)DI register is decremented.) The (E)DI register is incremented or decremented by 1 for byte operations, by 2 for word operations, or by 4 for doubleword operations.
\par The STOS, STOSB, STOSW, and STOSD instructions can be preceded by the REP prefix for block loads of ECX bytes, words, or doublewords. More often, however, these instructions are used within a LOOP construct because data needs to be moved into the AL, AX, or EAX register before it can be stored.
{\page}

${\footnote STOS,Operation}
K{\footnote STOS,STOS;STOSB,STOSB;STOSD,STOSD;STOSW,STOSW;STOS,Operation;STOSB,Operation;STOSD,Operation;STOSW,Operation}
#{\footnote STOS::2}
#{\footnote STOSB::2}
#{\footnote STOSD::2}
#{\footnote STOSW::2}

{\fs20\b STOS/STOSB/STOSD/STOSW}\tab{\b Operation}\par\par
IF (byte store)
\par THEN
\par DEST <- AL;
\par THEN IF DF = 0
\par THEN (E)DI <- (E)DI + 1;
\par ELSE (E)DI <- (E)DI - 1;
\par FI;
\par ELSE IF (word store)
\par THEN
\par DEST <- AX;
\par THEN IF DF = 0
\par THEN (E)DI <- (E)DI + 2;
\par ELSE (E)DI <- (E)DI - 2;
\par FI;
\par ELSE (* doubleword store *)
\par DEST <- EAX;
\par THEN IF DF = 0
\par THEN (E)DI <- (E)DI + 4;
\par ELSE (E)DI <- (E)DI - 4;
\par FI;
\par FI;
\par FI;
{\page}

${\footnote STOS,Flags affected}
K{\footnote STOS,STOS;STOSB,STOSB;STOSD,STOSD;STOSW,STOSW;STOS,Flags affected;STOSB,Flags affected;STOSD,Flags affected;STOSW,Flags affected}
#{\footnote STOS::3}
#{\footnote STOSB::3}
#{\footnote STOSD::3}
#{\footnote STOSW::3}

{\fs20\b STOS/STOSB/STOSD/STOSW}\tab{\b Flags affected}\par\par
None.
{\page}

${\footnote STOS,Exceptions}
K{\footnote STOS,STOS;STOSB,STOSB;STOSD,STOSD;STOSW,STOSW;STOS,Exceptions;STOSB,Exceptions;STOSD,Exceptions;STOSW,Exceptions}
#{\footnote STOS::4}
#{\footnote STOSB::4}
#{\footnote STOSD::4}
#{\footnote STOSW::4}

{\fs20\b STOS/STOSB/STOSD/STOSW}\tab{\b Exceptions}\par\par
Protected Mode Exceptions
\par 
\par #GP(0) If the destination is located in a nonwritable segment. If a memory operand effective address is outside the limit of the ES segment. If the ES register contains a null segment selector.
\par #PF(fault-code) If a page fault occurs.
\par #AC(0) If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.
\par 
\par Real-Address Mode Exceptions
\par 
\par #GP If a memory operand effective address is outside the ES segment limit.
\par 
\par Virtual-8086 Mode Exceptions
\par 
\par #GP(0) If a memory operand effective address is outside the ES segment limit.
\par #PF(fault-code) If a page fault occurs.
\par #AC(0) If alignment checking is enabled and an unaligned memory reference is made.
{\page}

${\footnote STOS,Opcode}
K{\footnote STOS,STOS;STOSB,STOSB;STOSD,STOSD;STOSW,STOSW;STOS,Opcode;STOSB,Opcode;STOSD,Opcode;STOSW,Opcode}
#{\footnote STOS::5}
#{\footnote STOSB::5}
#{\footnote STOSD::5}
#{\footnote STOSW::5}

{\fs20\b STOS/STOSB/STOSD/STOSW}\tab{\b Opcode}\par\par
AA STOS m8 Store AL at address ES:(E)DI
\par AB STOS m16 Store AX at address ES:(E)DI
\par AB STOS m32 Store EAX at address ES:(E)DI
\par AA STOSB Store AL at address ES:(E)DI
\par AB STOSW Store AX at address ES:(E)DI
\par AB STOSD Store EAX at address ES:(E)DI
{\page}

${\footnote STR,Description}
K{\footnote STR,STR;STR,Description}
#{\footnote STR::1}

{\fs20\b STR}\tab{\b Description}\par\par
STR: Store Task Register
\par 
\par Stores the segment selector from the task register (TR) in the destination operand. The destination operand can be a general-purpose register or a memory location. The segment selector stored with this instruction points to the task state segment (TSS) for the currently running task. When the destination operand is a 32-bit register, the 16-bit segment selector is copied into the lower 16 bits of the register and the upper 16 bits of the register are cleared to 0s. When the destination operand is a memory location, the segment selector is written to memory as a 16-bit quantity, regardless of operand size.
\par The STR instruction is useful only in operating-system software. It can only be executed in protected mode.
{\page}

${\footnote STR,Operation}
K{\footnote STR,STR;STR,Operation}
#{\footnote STR::2}

{\fs20\b STR}\tab{\b Operation}\par\par
DEST <- TR(SegmentSelector);
{\page}

${\footnote STR,Flags affected}
K{\footnote STR,STR;STR,Flags affected}
#{\footnote STR::3}

{\fs20\b STR}\tab{\b Flags affected}\par\par
None.
{\page}

${\footnote STR,Exceptions}
K{\footnote STR,STR;STR,Exceptions}
#{\footnote STR::4}

{\fs20\b STR}\tab{\b Exceptions}\par\par
Protected Mode Exceptions
\par 
\par #GP(0) If the destination is a memory operand that is located in a nonwritable segment or if the effective address is outside the CS, DS, ES, FS, or GS segment limit. If the DS, ES, FS, or GS register is used to access memory and it contains a null segment selector.
\par #SS(0) If a memory operand effective address is outside the SS segment limit.
\par #PF(fault-code) If a page fault occurs.
\par #AC(0) If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.
\par 
\par Real-Address Mode Exceptions
\par 
\par #UD The STR instruction is not recognized in real-address mode.
\par 
\par Virtual-8086 Mode Exceptions
\par 
\par #UD The STR instruction is not recognized in virtual-8086 mode.
{\page}

${\footnote STR,Opcode}
K{\footnote STR,STR;STR,Opcode}
#{\footnote STR::5}

{\fs20\b STR}\tab{\b Opcode}\par\par
0F 00 /1 STR r/m16 Stores segment selector from TR in r/m16
{\page}

${\footnote SUB,Description}
K{\footnote SUB,SUB;SUB,Description}
#{\footnote SUB::1}

{\fs20\b SUB}\tab{\b Description}\par\par
SUB: Subtract
\par 
\par Subtracts the second operand (source operand) from the first operand (destination operand) and stores the result in the destination operand. The destination operand can be a register or a memory location; the source operand can be an immediate, register, or memory location. (However, two memory operands cannot be used in one instruction.) When an immediate value is used as an operand, it is sign-extended to the length of the destination operand format.
\par The SUB instruction does not distinguish between signed or unsigned operands. Instead, the processor evaluates the result for both data types and sets the OF and CF flags to indicate a borrow in the signed or unsigned result, respectively. The SF flag indicates the sign of the signed result.
{\page}

${\footnote SUB,Operation}
K{\footnote SUB,SUB;SUB,Operation}
#{\footnote SUB::2}

{\fs20\b SUB}\tab{\b Operation}\par\par
DEST <- DEST - SRC;
{\page}

${\footnote SUB,Flags affected}
K{\footnote SUB,SUB;SUB,Flags affected}
#{\footnote SUB::3}

{\fs20\b SUB}\tab{\b Flags affected}\par\par
The OF, SF, ZF, AF, PF, and CF flags are set according to the result.
{\page}

${\footnote SUB,Exceptions}
K{\footnote SUB,SUB;SUB,Exceptions}
#{\footnote SUB::4}

{\fs20\b SUB}\tab{\b Exceptions}\par\par
Protected Mode Exceptions
\par 
\par #GP(0) If the destination is located in a nonwritable segment. If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit. If the DS, ES, FS, or GS register contains a null segment selector.
\par #SS(0) If a memory operand effective address is outside the SS segment limit.
\par #PF(fault-code) If a page fault occurs.
\par #AC(0) If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.
\par 
\par Real-Address Mode Exceptions
\par 
\par #GP If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.
\par #SS If a memory operand effective address is outside the SS segment limit.
\par 
\par Virtual-8086 Mode Exceptions
\par 
\par #GP(0) If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.
\par #SS(0) If a memory operand effective address is outside the SS segment limit.
\par #PF(fault-code) If a page fault occurs.
\par #AC(0) If alignment checking is enabled and an unaligned memory reference is made.
{\page}

${\footnote SUB,Opcode}
K{\footnote SUB,SUB;SUB,Opcode}
#{\footnote SUB::5}

{\fs20\b SUB}\tab{\b Opcode}\par\par
2C ib SUB AL, imm8 Subtract imm8 from AL
\par 2D iw SUB AX, imm16 Subtract imm16 from AX
\par 2D id SUB EAX, imm32 Subtract imm32 from EAX
\par 80 /5 ib SUB r/m8,imm8 Subtract imm8 from r/m8
\par 81 /5 iw SUB r/m16,imm16 Subtract imm16 from r/m16
\par 81 /5 id SUB r/m32,imm32 Subtract imm32 from r/m32
\par 83 /5 ib SUB r/m16,imm8 Subtract sign-extended imm8 from r/m16
\par 83 /5 ib SUB r/m32,imm8 Subtract sign-extended imm8 from r/m32
\par 28 / r SUB r/m8,r8 Subtract r8 from r/m8
\par 29 / r SUB r/m16,r16 Subtract r16 from r/m16
\par 29 / r SUB r/m32,r32 Subtract r32 from r/m32
\par 2A / r SUB r8,r/m8 Subtract r/m8 from r8
\par 2B / r SUB r16,r/m16 Subtract r/m16 from r16
\par 2B / r SUB r32,r/m32 Subtract r/m32 from r32
{\page}

${\footnote SS:,Description}
K{\footnote SS:,SS:;SS:,Description}
#{\footnote SS:::1}

{\fs20\b SS:}\tab{\b Description}\par\par
Internal disassembler's symbol which indicates that the next command is used with the SS: segment.
{\page}

${\footnote SS:,Operation}
K{\footnote SS:,SS:;SS:,Operation}
#{\footnote SS:::2}

{\fs20\b SS:}\tab{\b Operation}\par\par
N/A
{\page}

${\footnote SS:,Flags affected}
K{\footnote SS:,SS:;SS:,Flags affected}
#{\footnote SS:::3}

{\fs20\b SS:}\tab{\b Flags affected}\par\par
N/A
{\page}

${\footnote SS:,Exceptions}
K{\footnote SS:,SS:;SS:,Exceptions}
#{\footnote SS:::4}

{\fs20\b SS:}\tab{\b Exceptions}\par\par
N/A
{\page}

${\footnote SS:,Opcode}
K{\footnote SS:,SS:;SS:,Opcode}
#{\footnote SS:::5}

{\fs20\b SS:}\tab{\b Opcode}\par\par
N/A
{\page}

${\footnote TEST,Description}
K{\footnote TEST,TEST;TEST,Description}
#{\footnote TEST::1}

{\fs20\b TEST}\tab{\b Description}\par\par
TEST: Logical Compare
\par 
\par Computes the bit-wise logical AND of first operand (source 1 operand) and the second operand (source 2 operand) and sets the SF, ZF, and PF status flags according to the result. The result is then discarded.
{\page}

${\footnote TEST,Operation}
K{\footnote TEST,TEST;TEST,Operation}
#{\footnote TEST::2}

{\fs20\b TEST}\tab{\b Operation}\par\par
TEMP <- SRC1 AND SRC2;
\par SF <- MSB(TEMP);
\par IF TEMP = 0
\par THEN ZF <- 0;
\par ELSE ZF <- 1;
\par FI:
\par PF <- BitwiseXNOR(TEMP[0:7]);
\par CF <- 0;
\par OF <- 0;
\par (*AF is Undefined*)
{\page}

${\footnote TEST,Flags affected}
K{\footnote TEST,TEST;TEST,Flags affected}
#{\footnote TEST::3}

{\fs20\b TEST}\tab{\b Flags affected}\par\par
The OF and CF flags are cleared to 0. The SF, ZF, and PF flags are set according to the result (see the "Operation" section). The state of the AF flag is undefined.
{\page}

${\footnote TEST,Exceptions}
K{\footnote TEST,TEST;TEST,Exceptions}
#{\footnote TEST::4}

{\fs20\b TEST}\tab{\b Exceptions}\par\par
Protected Mode Exceptions
\par 
\par #GP(0) If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit. If the DS, ES, FS, or GS register contains a null segment selector.
\par #SS(0) If a memory operand effective address is outside the SS segment limit.
\par #PF(fault-code) If a page fault occurs.
\par #AC(0) If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.
\par 
\par Real-Address Mode Exceptions
\par 
\par #GP If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.
\par #SS If a memory operand effective address is outside the SS segment limit.
\par 
\par Virtual-8086 Mode Exceptions
\par 
\par #GP(0) If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.
\par #SS(0) If a memory operand effective address is outside the SS segment limit.
\par #PF(fault-code) If a page fault occurs.
\par #AC(0) If alignment checking is enabled and an unaligned memory reference is made.
{\page}

${\footnote TEST,Opcode}
K{\footnote TEST,TEST;TEST,Opcode}
#{\footnote TEST::5}

{\fs20\b TEST}\tab{\b Opcode}\par\par
A8 ib TEST AL, imm8 AND imm8 with AL; set SF, ZF, PF according to result
\par A9 iw TEST AX, imm16 AND imm16 with AX; set SF, ZF, PF according to result
\par A9 id TEST EAX, imm32 AND imm32 with EAX; set SF, ZF, PF according to result
\par F6 /0 ib TEST r/m8,imm8 AND imm8 with r/m8; set SF, ZF, PF according to result
\par F7 /0 iw TEST r/m16,imm16 AND imm16 with r/m16; set SF, ZF, PF according to result
\par F7 /0 id TEST r/m32,imm32 AND imm32 with r/m32; set SF, ZF, PF according to result
\par 84 / r TEST r/m8,r8 AND r8 with r/m8; set SF, ZF, PF according to result
\par 85 / r TEST r/m16,r16 AND r16 with r/m16; set SF, ZF, PF according to result
\par 85 / r TEST r/m32,r32 AND r32 with r/m32; set SF, ZF, PF according to result
{\page}

${\footnote UD2,Description}
K{\footnote UD2,UD2;UD2,Description}
#{\footnote UD2::1}

{\fs20\b UD2}\tab{\b Description}\par\par
UD2: Undefined Instruction
\par 
\par Generates an invalid opcode. This instruction is provided for software testing to explicitly generate an invalid opcode. The opcode for this instruction is reserved for this purpose. Other than raising the invalid opcode exception, this instruction is the same as the NOP instruction.
{\page}

${\footnote UD2,Operation}
K{\footnote UD2,UD2;UD2,Operation}
#{\footnote UD2::2}

{\fs20\b UD2}\tab{\b Operation}\par\par
#UD (* Generates invalid opcode exception *);
{\page}

${\footnote UD2,Flags affected}
K{\footnote UD2,UD2;UD2,Flags affected}
#{\footnote UD2::3}

{\fs20\b UD2}\tab{\b Flags affected}\par\par
None.
{\page}

${\footnote UD2,Exceptions}
K{\footnote UD2,UD2;UD2,Exceptions}
#{\footnote UD2::4}

{\fs20\b UD2}\tab{\b Exceptions}\par\par
(All Operating Modes)
\par #UD Instruction is guaranteed to raise an invalid opcode exception in all operating modes.
{\page}

${\footnote UD2,Opcode}
K{\footnote UD2,UD2;UD2,Opcode}
#{\footnote UD2::5}

{\fs20\b UD2}\tab{\b Opcode}\par\par
0F 0B UD2 Raise invalid opcode exception
{\page}

${\footnote VERR,Description}
K{\footnote VERR,VERR;VERW,VERW;VERR,Description;VERW,Description}
#{\footnote VERR::1}
#{\footnote VERW::1}

{\fs20\b VERR/VERW}\tab{\b Description}\par\par
VERR, VERW: Verify a Segment for Reading or Writing
\par 
\par Verifies whether the code or data segment specified with the source operand is readable (VERR) or writable (VERW) from the current privilege level (CPL). The source operand is a 16-bit register or a memory location that contains the segment selector for the segment to be verified. If the segment is accessible and readable (VERR) or writable (VERW), the ZF flag is set; otherwise, the ZF flag is cleared. Code segments are never verified as writable. This check cannot be performed on system segments.
\par To set the ZF flag, the following conditions must be met:
\par 
\par - The segment selector is not null.
\par - The selector must denote a descriptor within the bounds of the descriptor table (GDT or LDT).
\par - The selector must denote the descriptor of a code or data segment (not that of a system segment or gate).
\par - For the VERR instruction, the segment must be readable.
\par - For the VERW instruction, the segment must be a writable data segment.
\par - If the segment is not a conforming code segment, the segment's DPL must be greater than or equal to (have less or the same privilege as) both the CPL and the segment selector's RPL.
\par 
\par The validation performed is the same as is performed when a segment selector is loaded into the DS, ES, FS, or GS register, and the indicated access (read or write) is performed. The segment selector's value cannot result in a protection exception, enabling the software to anticipate possible segment access problems.
{\page}

${\footnote VERR,Operation}
K{\footnote VERR,VERR;VERW,VERW;VERR,Operation;VERW,Operation}
#{\footnote VERR::2}
#{\footnote VERW::2}

{\fs20\b VERR/VERW}\tab{\b Operation}\par\par
IF SRC(Offset) > (GDTR(Limit) OR (LDTR(Limit))
\par 
\par ZF <- 0
\par Read segment descriptor;
\par IF SegmentDescriptor(DescriptorType) = 0 (* system segment *)
\par OR (SegmentDescriptor(Type) != conforming code segment)
\par AND (CPL > DPL) OR (RPL > DPL)
\par THEN
\par ZF <- 0
\par ELSE
\par IF ((Instruction = VERR) AND (segment = readable))
\par OR ((Instruction = VERW) AND (segment = writable))
\par THEN
\par ZF <- 1;
\par FI;
\par FI;
{\page}

${\footnote VERR,Flags affected}
K{\footnote VERR,VERR;VERW,VERW;VERR,Flags affected;VERW,Flags affected}
#{\footnote VERR::3}
#{\footnote VERW::3}

{\fs20\b VERR/VERW}\tab{\b Flags affected}\par\par
The ZF flag is set to 1 if the segment is accessible and readable (VERR) or writable (VERW); otherwise, it is cleared to 0.
{\page}

${\footnote VERR,Exceptions}
K{\footnote VERR,VERR;VERW,VERW;VERR,Exceptions;VERW,Exceptions}
#{\footnote VERR::4}
#{\footnote VERW::4}

{\fs20\b VERR/VERW}\tab{\b Exceptions}\par\par
Protected Mode Exceptions
\par 
\par The only exceptions generated for these instructions are those related to illegal addressing of the source operand.
\par #GP(0) If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit. If the DS, ES, FS, or GS register is used to access memory and it contains a null segment selector.
\par #SS(0) If a memory operand effective address is outside the SS segment limit.
\par #PF(fault-code) If a page fault occurs.
\par #AC(0) If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.
\par 
\par Real-Address Mode Exceptions
\par 
\par #UD The VERR and VERW instructions are not recognized in real-address mode.
\par 
\par Virtual-8086 Mode Exceptions
\par 
\par #UD The VERR and VERW instructions are not recognized in virtual-8086 mode.
{\page}

${\footnote VERR,Opcode}
K{\footnote VERR,VERR;VERW,VERW;VERR,Opcode;VERW,Opcode}
#{\footnote VERR::5}
#{\footnote VERW::5}

{\fs20\b VERR/VERW}\tab{\b Opcode}\par\par
0F 00 /4 VERR r/m16 Set ZF=1 if segment specified with r/m16 can be read
\par 0F 00 /5 VERW r/m16 Set ZF=1 if segment specified with r/m16 can be written
{\page}

${\footnote WAIT,Description}
K{\footnote WAIT,WAIT;WAIT,Description}
#{\footnote WAIT::1}

{\fs20\b WAIT}\tab{\b Description}\par\par
WAIT: Wait
\par 
\par Causes the processor to check for and handle pending, unmasked, floating-point exceptions before proceeding. (FWAIT is an alternate mnemonic for the WAIT). This instruction is useful for synchronizing exceptions in critical sections of code. Coding a WAIT instruction after a floating-point instruction insures that any unmasked floating-point exceptions the instruction may raise are handled before the processor can modify the instruction's results.
{\page}

${\footnote WAIT,Operation}
K{\footnote WAIT,WAIT;WAIT,Operation}
#{\footnote WAIT::2}

{\fs20\b WAIT}\tab{\b Operation}\par\par
CheckForPendingUnmaskedFloatingPointExceptions;
{\page}

${\footnote WAIT,Flags affected}
K{\footnote WAIT,WAIT;WAIT,Flags affected}
#{\footnote WAIT::3}

{\fs20\b WAIT}\tab{\b Flags affected}\par\par
The C0, C1, C2, and C3 flags are undefined.
{\page}

${\footnote WAIT,Exceptions}
K{\footnote WAIT,WAIT;WAIT,Exceptions}
#{\footnote WAIT::4}

{\fs20\b WAIT}\tab{\b Exceptions}\par\par
Floating-Point Exceptions
\par 
\par None.
\par 
\par Protected Mode Exceptions
\par 
\par #NM MP and TS in CR0 is set.
\par 
\par Real-Address Mode Exceptions
\par 
\par #NM MP and TS in CR0 is set.
\par 
\par Virtual-8086 Mode Exceptions
\par 
\par #NM MP and TS in CR0 is set.
{\page}

${\footnote WAIT,Opcode}
K{\footnote WAIT,WAIT;WAIT,Opcode}
#{\footnote WAIT::5}

{\fs20\b WAIT}\tab{\b Opcode}\par\par
9B WAIT Check pending unmasked floating-point exceptions.
{\page}

${\footnote WBINVD,Description}
K{\footnote WBINVD,WBINVD;WBINVD,Description}
#{\footnote WBINVD::1}

{\fs20\b WBINVD}\tab{\b Description}\par\par
WBINVD: Write Back and Invalidate Cache
\par 
\par Writes back all modified cache lines in the processor's internal cache to main memory and invalidates (flushes) the internal caches. The instruction then issues a special-function bus cycle that directs external caches to also write back modified data and another bus cycle to indicate that the external caches should be invalidated.
\par After executing this instruction, the processor does not wait for the external caches to complete their write-back and flushing operations before proceeding with instruction execution. It is the responsibility of hardware to respond to the cache write-back and flush signals. The WDINVD instruction is a privileged instruction. When the processor is running in protected mode, the CPL of a program or procedure must be 0 to execute this instruction. This instruction is also a serializing instruction.
\par 
\par Intel Architecture Compatibility
\par 
\par The WBINVD instruction is implementation dependent, and its function may be implemented differently on future Intel Architecture processors. The instruction is not supported on Intel Architecture processors earlier than the Intel486 processor.
{\page}

${\footnote WBINVD,Operation}
K{\footnote WBINVD,WBINVD;WBINVD,Operation}
#{\footnote WBINVD::2}

{\fs20\b WBINVD}\tab{\b Operation}\par\par
WriteBack(InternalCaches);
\par Flush(InternalCaches);
\par SignalWriteBack(ExternalCaches);
\par SignalFlush(ExternalCaches);
\par Continue (* Continue execution);
{\page}

${\footnote WBINVD,Flags affected}
K{\footnote WBINVD,WBINVD;WBINVD,Flags affected}
#{\footnote WBINVD::3}

{\fs20\b WBINVD}\tab{\b Flags affected}\par\par
None.
{\page}

${\footnote WBINVD,Exceptions}
K{\footnote WBINVD,WBINVD;WBINVD,Exceptions}
#{\footnote WBINVD::4}

{\fs20\b WBINVD}\tab{\b Exceptions}\par\par
Protected Mode Exceptions
\par 
\par #GP(0) If the current privilege level is not 0.
\par 
\par Real-Address Mode Exceptions
\par 
\par None.
\par 
\par Virtual-8086 Mode Exceptions
\par 
\par #GP(0) The WBINVD instruction cannot be executed at the virtual-8086 mode.
{\page}

${\footnote WBINVD,Opcode}
K{\footnote WBINVD,WBINVD;WBINVD,Opcode}
#{\footnote WBINVD::5}

{\fs20\b WBINVD}\tab{\b Opcode}\par\par
0F 09 WBINVD Write back and flush Internal caches; initiate writing-back and flushing of external caches.
{\page}

${\footnote WRMSR,Description}
K{\footnote WRMSR,WRMSR;WRMSR,Description}
#{\footnote WRMSR::1}

{\fs20\b WRMSR}\tab{\b Description}\par\par
WRMSR: Write to Model Specific Register
\par 
\par Writes the contents of registers EDX:EAX into the 64-bit model specific register (MSR) specified in the ECX register. The high-order 32 bits are copied from EDX and the low-order 32 bits are copied from EAX. Always set the undefined or reserved bits in an MSR to the values previously read.
\par This instruction must be executed at privilege level 0 or in real-address mode; otherwise, a general protection exception #GP(0) will be generated. Specifying a reserved or unimplemented MSR address in ECX will also cause a general protection exception.
\par When the WRMSR instruction is used to write to an MTRR, the TLBs are invalidated, including the global entries. (MTRRs are an implementation-specific feature of the Pentium Pro processor.)
\par 
\par Intel Architecture Compatibility
\par 
\par The MSRs and the ability to read them with the WRMSR instruction were introduced into the Intel Architecture with the Pentium processor. Execution of this instruction by an Intel Architecture processor earlier than the Pentium processor results in an invalid opcode exception #UD.
{\page}

${\footnote WRMSR,Operation}
K{\footnote WRMSR,WRMSR;WRMSR,Operation}
#{\footnote WRMSR::2}

{\fs20\b WRMSR}\tab{\b Operation}\par\par
MSR[ECX] <- EDX:EAX;
{\page}

${\footnote WRMSR,Flags affected}
K{\footnote WRMSR,WRMSR;WRMSR,Flags affected}
#{\footnote WRMSR::3}

{\fs20\b WRMSR}\tab{\b Flags affected}\par\par
None.
{\page}

${\footnote WRMSR,Exceptions}
K{\footnote WRMSR,WRMSR;WRMSR,Exceptions}
#{\footnote WRMSR::4}

{\fs20\b WRMSR}\tab{\b Exceptions}\par\par
Protected Mode Exceptions
\par 
\par #GP(0) If the current privilege level is not 0. If the value in ECX specifies a reserved or unimplemented MSR address.
\par 
\par Real-Address Mode Exceptions
\par 
\par #GP If the value in ECX specifies a reserved or unimplemented MSR address.
\par 
\par Virtual-8086 Mode Exceptions
\par 
\par #GP(0) The WRMSR instruction is not recognized in virtual-8086 mode.
{\page}

${\footnote WRMSR,Opcode}
K{\footnote WRMSR,WRMSR;WRMSR,Opcode}
#{\footnote WRMSR::5}

{\fs20\b WRMSR}\tab{\b Opcode}\par\par
0F 30 WRMSR Write the value in EDX:EAX to MSR specified by ECX
{\page}

${\footnote XADD,Description}
K{\footnote XADD,XADD;XADD,Description}
#{\footnote XADD::1}

{\fs20\b XADD}\tab{\b Description}\par\par
XADD: Exchange and Add
\par 
\par Exchanges the first operand (destination operand) with the second operand (source operand), then loads the sum of the two values into the destination operand. The destination operand can be a register or a memory location; the source operand is a register. This instruction can be used with a LOCK prefix.
\par 
\par Intel Architecture Compatibility
\par 
\par Intel Architecture processors earlier than the Intel486 processor do not recognize this instruction. If this instruction is used, you should provide an equivalent code sequence that runs on earlier processors.
{\page}

${\footnote XADD,Operation}
K{\footnote XADD,XADD;XADD,Operation}
#{\footnote XADD::2}

{\fs20\b XADD}\tab{\b Operation}\par\par
TEMP <- SRC + DEST
\par SRC <- DEST
\par DEST <- TEMP
{\page}

${\footnote XADD,Flags affected}
K{\footnote XADD,XADD;XADD,Flags affected}
#{\footnote XADD::3}

{\fs20\b XADD}\tab{\b Flags affected}\par\par
The CF, PF, AF, SF, ZF, and OF flags are set according to the result of the addition, which is stored in the destination operand.
{\page}

${\footnote XADD,Exceptions}
K{\footnote XADD,XADD;XADD,Exceptions}
#{\footnote XADD::4}

{\fs20\b XADD}\tab{\b Exceptions}\par\par
Protected Mode Exceptions
\par 
\par #GP(0) If the destination is located in a nonwritable segment. If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit. If the DS, ES, FS, or GS register contains a null segment selector.
\par #SS(0) If a memory operand effective address is outside the SS segment limit.
\par #PF(fault-code) If a page fault occurs.
\par #AC(0) If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.
\par 
\par Real-Address Mode Exceptions
\par 
\par #GP If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.
\par #SS If a memory operand effective address is outside the SS segment limit.
\par 
\par Virtual-8086 Mode Exceptions
\par 
\par #GP(0) If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.
\par #SS(0) If a memory operand effective address is outside the SS segment limit.
\par #PF(fault-code) If a page fault occurs.
\par #AC(0) If alignment checking is enabled and an unaligned memory reference is made.
{\page}

${\footnote XADD,Opcode}
K{\footnote XADD,XADD;XADD,Opcode}
#{\footnote XADD::5}

{\fs20\b XADD}\tab{\b Opcode}\par\par
0F C0/r XADD r/m8,r8 Exchange r8 and r/m8; load sum into r/m8.
\par 0F C1/r XADD r/m16,r16 Exchange r16 and r/m16; load sum into r/m16.
\par 0F C1/r XADD r/m32,r32 Exchange r32 and r/m32; load sum into r/m32.
{\page}

${\footnote XCHG,Description}
K{\footnote XCHG,XCHG;XCHG,Description}
#{\footnote XCHG::1}

{\fs20\b XCHG}\tab{\b Description}\par\par
XCHG: Exchange Register/Memory with Register
\par 
\par Exchanges the contents of the destination (first) and source (second) operands. The operands can be two general-purpose registers or a register and a memory location. If a memory operand is referenced, the processor's locking protocol is automatically implemented for the duration of the exchange operation, regardless of the presence or absence of the LOCK prefix or of the value of the IOPL.
\par This instruction is useful for implementing semaphores or similar data structures for process synchronization. The XCHG instruction can also be used instead of the BSWAP instruction for 16-bit operands.
{\page}

${\footnote XCHG,Operation}
K{\footnote XCHG,XCHG;XCHG,Operation}
#{\footnote XCHG::2}

{\fs20\b XCHG}\tab{\b Operation}\par\par
TEMP <- DEST
\par DEST <- SRC
\par SRC <- TEMP
{\page}

${\footnote XCHG,Flags affected}
K{\footnote XCHG,XCHG;XCHG,Flags affected}
#{\footnote XCHG::3}

{\fs20\b XCHG}\tab{\b Flags affected}\par\par
None.
{\page}

${\footnote XCHG,Exceptions}
K{\footnote XCHG,XCHG;XCHG,Exceptions}
#{\footnote XCHG::4}

{\fs20\b XCHG}\tab{\b Exceptions}\par\par
Protected Mode Exceptions
\par 
\par #GP(0) If either operand is in a nonwritable segment. If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit. If the DS, ES, FS, or GS register contains a null segment selector.
\par #SS(0) If a memory operand effective address is outside the SS segment limit.
\par #PF(fault-code) If a page fault occurs.
\par #AC(0) If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.
\par 
\par Real-Address Mode Exceptions
\par 
\par #GP If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.
\par #SS If a memory operand effective address is outside the SS segment limit.
\par 
\par Virtual-8086 Mode Exceptions
\par 
\par #GP(0) If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.
\par #SS(0) If a memory operand effective address is outside the SS segment limit.
\par #PF(fault-code) If a page fault occurs.
\par #AC(0) If alignment checking is enabled and an unaligned memory reference is made.
{\page}

${\footnote XCHG,Opcode}
K{\footnote XCHG,XCHG;XCHG,Opcode}
#{\footnote XCHG::5}

{\fs20\b XCHG}\tab{\b Opcode}\par\par
90+ rw XCHG AX, r16 Exchange r16 with AX
\par 90+ rw XCHG r16,AX Exchange AX with r16
\par 90+ rd XCHG EAX, r32 Exchange r32 with EAX
\par 90+ rd XCHG r32,EAX Exchange EAX with r32
\par 86 / r XCHG r/m8,r8 Exchange r8 (byte register) with byte from r/m8
\par 86 / r XCHG r8,r/m8 Exchange byte from r/m8 with r8 (byte register)
\par 87 / r XCHG r/m16,r16 Exchange r16 with word from r/m16
\par 87 / r XCHG r16,r/m16 Exchange word from r/m16 with r16
\par 87 / r XCHG r/m32,r32 Exchange r32 with doubleword from r/m32
\par 87 / r XCHG r32,r/m32 Exchange doubleword from r/m32 with r32
{\page}

${\footnote XLAT,Description}
K{\footnote XLAT,XLAT;XLATB,XLATB;XLAT,Description;XLATB,Description}
#{\footnote XLAT::1}
#{\footnote XLATB::1}

{\fs20\b XLAT/XLATB}\tab{\b Description}\par\par
XLAT/XLATB: Table Look-up Translation
\par 
\par Locates a byte entry in a table in memory, using the contents of the AL register as a table index, then copies the contents of the table entry back into the AL register. The index in the AL register is treated as an unsigned integer. The XLAT and XLATB instructions get the base address of the table in memory from either the DS:EBX or the DS:BX registers (depending on the address-size attribute of the instruction, 32 or 16, respectively). (The DS segment may be overridden with a segment override prefix.)
\par At the assembly-code level, two forms of this instruction are allowed: the "explicit-operand" form and the "no-operand" form. The explicit-operand form (specified with the XLAT mnemonic) allows the base address of the table to be specified explicitly with a symbol. This explicit-operands form is provided to allow documentation; however, note that the documentation provided by this form can be misleading. That is, the symbol does not have to specify the correct base address. The base address is always specified by the DS:(E)BX registers, which must be loaded correctly before the XLAT instruction is executed.
\par The no-operands form (XLATB) provides a "short form" of the XLAT instructions. Here also the processor assumes that the DS:(E)BX registers contain the base address of the table.
{\page}

${\footnote XLAT,Operation}
K{\footnote XLAT,XLAT;XLATB,XLATB;XLAT,Operation;XLATB,Operation}
#{\footnote XLAT::2}
#{\footnote XLATB::2}

{\fs20\b XLAT/XLATB}\tab{\b Operation}\par\par
IF AddressSize = 16
\par THEN
\par AL <- (DS:BX + ZeroExtend(AL))
\par ELSE (* AddressSize = 32 *)
\par AL <- (DS:EBX + ZeroExtend(AL));
\par FI;
{\page}

${\footnote XLAT,Flags affected}
K{\footnote XLAT,XLAT;XLATB,XLATB;XLAT,Flags affected;XLATB,Flags affected}
#{\footnote XLAT::3}
#{\footnote XLATB::3}

{\fs20\b XLAT/XLATB}\tab{\b Flags affected}\par\par
None.
{\page}

${\footnote XLAT,Exceptions}
K{\footnote XLAT,XLAT;XLATB,XLATB;XLAT,Exceptions;XLATB,Exceptions}
#{\footnote XLAT::4}
#{\footnote XLATB::4}

{\fs20\b XLAT/XLATB}\tab{\b Exceptions}\par\par
Protected Mode Exceptions
\par 
\par #GP(0) If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit. If the DS, ES, FS, or GS register contains a null segment selector.
\par #SS(0) If a memory operand effective address is outside the SS segment limit.
\par #PF(fault-code) If a page fault occurs.
\par 
\par Real-Address Mode Exceptions
\par 
\par #GP If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.
\par #SS If a memory operand effective address is outside the SS segment limit.
\par 
\par Virtual-8086 Mode Exceptions
\par 
\par #GP(0) If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.
\par #SS(0) If a memory operand effective address is outside the SS segment limit.
\par #PF(fault-code) If a page fault occurs.
{\page}

${\footnote XLAT,Opcode}
K{\footnote XLAT,XLAT;XLATB,XLATB;XLAT,Opcode;XLATB,Opcode}
#{\footnote XLAT::5}
#{\footnote XLATB::5}

{\fs20\b XLAT/XLATB}\tab{\b Opcode}\par\par
D7 XLAT m8 Set AL to memory byte DS:[(E)BX + unsigned AL]
\par D7 XLATB Set AL to memory byte DS:[(E)BX + unsigned AL]
{\page}

${\footnote XOR,Description}
K{\footnote XOR,XOR;XOR,Description}
#{\footnote XOR::1}

{\fs20\b XOR}\tab{\b Description}\par\par
XOR: Logical Exclusive OR
\par 
\par Performs a bitwise exclusive OR (XOR) operation on the destination (first) and source (second) operands and stores the result in the destination operand location. The source operand can be an immediate, a register, or a memory location; the destination operand can be a register or a memory location. (However, two memory operands cannot be used in one instruction.) Each bit of the result is 1 if the corresponding bits of the operands are different; each bit is 0 if the corresponding bits are the same.
{\page}

${\footnote XOR,Operation}
K{\footnote XOR,XOR;XOR,Operation}
#{\footnote XOR::2}

{\fs20\b XOR}\tab{\b Operation}\par\par
DEST <- DEST XOR SRC;
{\page}

${\footnote XOR,Flags affected}
K{\footnote XOR,XOR;XOR,Flags affected}
#{\footnote XOR::3}

{\fs20\b XOR}\tab{\b Flags affected}\par\par
The OF and CF flags are cleared; the SF, ZF, and PF flags are set according to the result. The state of the AF flag is undefined.
{\page}

${\footnote XOR,Exceptions}
K{\footnote XOR,XOR;XOR,Exceptions}
#{\footnote XOR::4}

{\fs20\b XOR}\tab{\b Exceptions}\par\par
Protected Mode Exceptions
\par 
\par #GP(0) If the destination operand points to a nonwritable segment. If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit. If the DS, ES, FS, or GS register contains a null segment selector.
\par #SS(0) If a memory operand effective address is outside the SS segment limit.
\par #PF(fault-code) If a page fault occurs.
\par #AC(0) If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.
\par 
\par Real-Address Mode Exceptions
\par 
\par #GP If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.
\par #SS If a memory operand effective address is outside the SS segment limit.
\par 
\par Virtual-8086 Mode Exceptions
\par 
\par #GP(0) If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.
\par #SS(0) If a memory operand effective address is outside the SS segment limit.
\par #PF(fault-code) If a page fault occurs.
\par #AC(0) If alignment checking is enabled and an unaligned memory reference is made.
{\page}

${\footnote XOR,Opcode}
K{\footnote XOR,XOR;XOR,Opcode}
#{\footnote XOR::5}

{\fs20\b XOR}\tab{\b Opcode}\par\par
34 ib XOR AL, imm8 AL XOR imm8
\par 35 iw XOR AX, imm16 AX XOR imm16
\par 35 id XOR EAX, imm32 EAX XOR imm32
\par 80 /6 ib XOR r/m8,imm8 r/m8 XOR imm8
\par 81 /6 iw XOR r/m16,imm16 r/m16 XOR imm16
\par 81 /6 id XOR r/m32,imm32 r/m32 XOR imm32
\par 83 /6 ib XOR r/m16,imm8 r/m16 XOR imm8 (sign-extended)
\par 83 /6 ib XOR r/m32,imm8 r/m32 XOR imm8 (sign-extended)
\par 30 / r XOR r/m8,r8 r/m8 XOR r8
\par 31 / r XOR r/m16,r16 r/m16 XOR r16
\par 31 / r XOR r/m32,r32 r/m32 XOR r32
\par 32 / r XOR r8,r/m8 r8 XOR r/m8
\par 33 / r XOR r16,r/m16 r8 XOR r/m8
\par 33 / r XOR r32,r/m32 r8 XOR r/m8
{\page}

\section
${\footnote Contents}
#{\footnote Contents}
K{\footnote Contents}
{\b\fs30 Contents}
\par
\par {\uldb AAA: ASCII Adjust After Addition}{\v!{\footnote KLink("AAA,AAA")}}
\par {\uldb AAD: ASCII Adjust AX Before Division}{\v!{\footnote KLink("AAD,AAD")}}
\par {\uldb AAM: ASCII Adjust AX After Multiply}{\v!{\footnote KLink("AAM,AAM")}}
\par {\uldb AAS: ASCII Adjust AL After Subtraction}{\v!{\footnote KLink("AAS,AAS")}}
\par {\uldb ADC: Add with Carry}{\v!{\footnote KLink("ADC,ADC")}}
\par {\uldb ADD: Add}{\v!{\footnote KLink("ADD,ADD")}}
\par {\uldb AND: Logical AND}{\v!{\footnote KLink("AND,AND")}}
\par {\uldb ARPL: Adjust RPL Field of Segment Selector}{\v!{\footnote KLink("ARPL,ARPL")}}
\par {\uldb BOUND: Check Array Index Against Bounds}{\v!{\footnote KLink("BOUND,BOUND")}}
\par {\uldb BSF: Bit Scan Forward}{\v!{\footnote KLink("BSF,BSF")}}
\par {\uldb BSR: Bit Scan Reverse}{\v!{\footnote KLink("BSR,BSR")}}
\par {\uldb BSWAP: Byte Swap}{\v!{\footnote KLink("BSWAP,BSWAP")}}
\par {\uldb BT: Bit Test}{\v!{\footnote KLink("BT,BT")}}
\par {\uldb BTC: Bit Test and Complement}{\v!{\footnote KLink("BTC,BTC")}}
\par {\uldb BTR: Bit Test and Reset}{\v!{\footnote KLink("BTR,BTR")}}
\par {\uldb BTS: Bit Test and Set}{\v!{\footnote KLink("BTS,BTS")}}
\par {\uldb CALL: Call Procedure}{\v!{\footnote KLink("CALL,CALL")}}
\par {\uldb CBW/CWDE--Convert Byte to Word/Convert Word to Doubleword}{\v!{\footnote KLink("CBW,CBW")}}
\par {\uldb CLC: Clear Carry Flag}{\v!{\footnote KLink("CLC,CLC")}}
\par {\uldb CLD: Clear Direction Flag}{\v!{\footnote KLink("CLD,CLD")}}
\par {\uldb CLI: Clear Interrupt Flag}{\v!{\footnote KLink("CLI,CLI")}}
\par {\uldb CLTS: Clear Task-Switched Flag in CR0}{\v!{\footnote KLink("CLTS,CLTS")}}
\par {\uldb CMC: Complement Carry Flag}{\v!{\footnote KLink("CMC,CMC")}}
\par {\uldb CMOV cc: Conditional Move}{\v!{\footnote KLink("CMOV,CMOV")}}
\par {\uldb CMP: Compare Two Operands}{\v!{\footnote KLink("CMP,CMP")}}
\par {\uldb CMPS/CMPSB/CMPSW/CMPSD: Compare String Operands}{\v!{\footnote KLink("CMPS,CMPS")}}
\par {\uldb CMPXCHG: Compare and Exchange}{\v!{\footnote KLink("CMPXCHG,CMPXCHG")}}
\par {\uldb CMPXCHG8B: Compare and Exchange 8 Bytes}{\v!{\footnote KLink("CMPXCHG8B,CMPXCHG8B")}}
\par {\uldb CPUID--CPU Identification}{\v!{\footnote KLink("CPUID,CPUID")}}
\par {\uldb Internal disassembler's symbol which indicates that the next command is used with the CS: segment.}{\v!{\footnote KLink("CS:,CS:")}}
\par {\uldb CWD/CDQ: Convert Word to Doubleword/Convert Doubleword to Quadword}{\v!{\footnote KLink("CWD,CWD")}}
\par {\uldb DAA: Decimal Adjust AL after Addition}{\v!{\footnote KLink("DAA,DAA")}}
\par {\uldb DAS: Decimal Adjust AL after Subtraction}{\v!{\footnote KLink("DAS,DAS")}}
\par {\uldb DEC: Decrement by 1}{\v!{\footnote KLink("DEC,DEC")}}
\par {\uldb DIV: Unsigned Divide}{\v!{\footnote KLink("DIV,DIV")}}
\par {\uldb Internal disassembler's symbol which indicates that the next command is used with the DS: segment.}{\v!{\footnote KLink("DS:,DS:")}}
\par {\uldb EMMS: Empty MMX(tm) State}{\v!{\footnote KLink("EMMS,EMMS")}}
\par {\uldb ENTER: Make Stack Frame for Procedure Parameters}{\v!{\footnote KLink("ENTER,ENTER")}}
\par {\uldb Internal disassembler's symbol which indicates that the next command is used with the ES: segment.}{\v!{\footnote KLink("ES:,ES:")}}
\par {\uldb F2XM1: Compute 2^x -1}{\v!{\footnote KLink("F2XM1,F2XM1")}}
\par {\uldb FABS: Absolute Value}{\v!{\footnote KLink("FABS,FABS")}}
\par {\uldb FADD/FADDP/FIADD: Add}{\v!{\footnote KLink("FADD,FADD")}}
\par {\uldb FBLD: Load Binary Coded Decimal}{\v!{\footnote KLink("FBLD,FBLD")}}
\par {\uldb FBSTP: Store BCD Integer and Pop}{\v!{\footnote KLink("FBSTP,FBSTP")}}
\par {\uldb FCHS: Change Sign}{\v!{\footnote KLink("FCHS,FCHS")}}
\par {\uldb FCLEX/FNCLEX: Clear Exceptions}{\v!{\footnote KLink("FCLEX,FCLEX")}}
\par {\uldb FCMOV cc: Floating-Point Conditional Move}{\v!{\footnote KLink("FCMOVB,FCMOVB")}}
\par {\uldb FCOM/FCOMP/FCOMPP: Compare Real}{\v!{\footnote KLink("FCOM,FCOM")}}
\par {\uldb FCOMI/FCOMIP/FUCOMI/FUCOMIP: Compare Real and Set EFLAGS}{\v!{\footnote KLink("FCOMI,FCOMI")}}
\par {\uldb FCOS: Cosine}{\v!{\footnote KLink("FCOS,FCOS")}}
\par {\uldb FDECSTP: Decrement Stack-Top Pointer}{\v!{\footnote KLink("FDECSTP,FDECSTP")}}
\par {\uldb FDIV/FDIVP/FIDIV: Divide}{\v!{\footnote KLink("FDIV,FDIV")}}
\par {\uldb FDIVR/FDIVRP/FIDIVR: Reverse Divide}{\v!{\footnote KLink("FDIVR,FDIVR")}}
\par {\uldb FFREE: Free Floating-Point Register}{\v!{\footnote KLink("FFREE,FFREE")}}
\par {\uldb FICOM/FICOMP: Compare Integer}{\v!{\footnote KLink("FICOM,FICOM")}}
\par {\uldb FILD: Load Integer}{\v!{\footnote KLink("FILD,FILD")}}
\par {\uldb FINCSTP: Increment Stack-Top Pointer}{\v!{\footnote KLink("FINCSTP,FINCSTP")}}
\par {\uldb FINIT/FNINIT: Initialize Floating-Point Unit}{\v!{\footnote KLink("FINIT,FINIT")}}
\par {\uldb FIST/FISTP: Store Integer}{\v!{\footnote KLink("FIST,FIST")}}
\par {\uldb FLD: Load Real}{\v!{\footnote KLink("FLD,FLD")}}
\par {\uldb FLD1/FLDL2T/FLDL2E/FLDPI/FLDLG2/FLDLN2/FLDZ: Load Constant}{\v!{\footnote KLink("FLD1,FLD1")}}
\par {\uldb FLDCW: Load Control Word}{\v!{\footnote KLink("FLDCW,FLDCW")}}
\par {\uldb FLDENV: Load FPU Environment}{\v!{\footnote KLink("FLDENV,FLDENV")}}
\par {\uldb FMUL/FMULP/FIMUL: Multiply}{\v!{\footnote KLink("FMUL,FMUL")}}
\par {\uldb FNOP: No Operation}{\v!{\footnote KLink("FNOP,FNOP")}}
\par {\uldb FPATAN: Partial Arctangent}{\v!{\footnote KLink("FPATAN,FPATAN")}}
\par {\uldb FPREM - Partial Remainder}{\v!{\footnote KLink("FPREM,FPREM")}}
\par {\uldb FPREM1: Partial Remainder}{\v!{\footnote KLink("FPREM1,FPREM1")}}
\par {\uldb FPTAN: Partial Tangent}{\v!{\footnote KLink("FPTAN,FPTAN")}}
\par {\uldb FRNDINT: Round to Integer}{\v!{\footnote KLink("FRNDINT,FRNDINT")}}
\par {\uldb FRSTOR: Restore FPU State}{\v!{\footnote KLink("FRSTOR,FRSTOR")}}
\par {\uldb Internal disassembler's symbol which indicates that the next command is used with the FS: segment.}{\v!{\footnote KLink("FS:,FS:")}}
\par {\uldb FSAVE/FNSAVE: Store FPU State}{\v!{\footnote KLink("FSAVE,FSAVE")}}
\par {\uldb FSCALE: Scale}{\v!{\footnote KLink("FSCALE,FSCALE")}}
\par {\uldb FSIN: Sine}{\v!{\footnote KLink("FSIN,FSIN")}}
\par {\uldb FSINCOS: Sine and Cosine}{\v!{\footnote KLink("FSINCOS,FSINCOS")}}
\par {\uldb FSQRT: Square Root}{\v!{\footnote KLink("FSQRT,FSQRT")}}
\par {\uldb FST/FSTP: Store Real}{\v!{\footnote KLink("FST,FST")}}
\par {\uldb FSTCW/FNSTCW: Store Control Word}{\v!{\footnote KLink("FSTCW,FSTCW")}}
\par {\uldb FSTENV/FNSTENV: Store FPU Environment}{\v!{\footnote KLink("FSTENV,FSTENV")}}
\par {\uldb FSTSW/FNSTSW: Store Status Word}{\v!{\footnote KLink("FSTSW,FSTSW")}}
\par {\uldb FSUB/FSUBP/FISUB: Subtract}{\v!{\footnote KLink("FSUB,FSUB")}}
\par {\uldb FSUBR/FSUBRP/FISUBR: Reverse Subtract}{\v!{\footnote KLink("FSUBR,FSUBR")}}
\par {\uldb FTST: TEST}{\v!{\footnote KLink("FTST,FTST")}}
\par {\uldb FUCOM/FUCOMP/FUCOMPP: Unordered Compare Real}{\v!{\footnote KLink("FUCOM,FUCOM")}}
\par {\uldb FWAIT: Wait}{\v!{\footnote KLink("FWAIT,FWAIT")}}
\par {\uldb FXAM: Examine}{\v!{\footnote KLink("FXAM,FXAM")}}
\par {\uldb FXCH: Exchange Register Contents}{\v!{\footnote KLink("FXCH,FXCH")}}
\par {\uldb FXTRACT: Extract Exponent and Significand}{\v!{\footnote KLink("FXTRACT,FXTRACT")}}
\par {\uldb FYL2X: Compute y * log\{2\}x (Base of logarithm = 2)}{\v!{\footnote KLink("FYL2X,FYL2X")}}
\par {\uldb FYL2XP1: Compute y * log\{2\}(x +1)}{\v!{\footnote KLink("FYL2XP1,FYL2XP1")}}
\par {\uldb Internal disassembler's symbol which indicates that the next command is used with the GS: segment.}{\v!{\footnote KLink("GS:,GS:")}}
\par {\uldb HLT: Halt}{\v!{\footnote KLink("HLT,HLT")}}
\par {\uldb IDIV: Signed Divide}{\v!{\footnote KLink("IDIV,IDIV")}}
\par {\uldb IMUL: Signed Multiply}{\v!{\footnote KLink("IMUL,IMUL")}}
\par {\uldb IN: Input from Port}{\v!{\footnote KLink("IN,IN")}}
\par {\uldb INC: Increment by 1}{\v!{\footnote KLink("INC,INC")}}
\par {\uldb INS/INSB/INSW/INSD: Input from Port to String}{\v!{\footnote KLink("INS,INS")}}
\par {\uldb INT n/INTO/INT 3: Call to Interrupt Procedure}{\v!{\footnote KLink("INT,INT")}}
\par {\uldb INVD: Invalidate Internal Caches}{\v!{\footnote KLink("INVD,INVD")}}
\par {\uldb INVLPG: Invalidate TLB Entry}{\v!{\footnote KLink("INVLPG,INVLPG")}}
\par {\uldb IRET/IRETD: Interrupt Return}{\v!{\footnote KLink("IRET,IRET")}}
\par {\uldb J cc: Jump if Condition Is Met}{\v!{\footnote KLink("JA,JA")}}
\par {\uldb JMP: Jump}{\v!{\footnote KLink("JMP,JMP")}}
\par {\uldb LAHF: Load Status Flags into AH Register}{\v!{\footnote KLink("LAHF,LAHF")}}
\par {\uldb LAR: Load Access Rights Byte}{\v!{\footnote KLink("LAR,LAR")}}
\par {\uldb LDS/LES/LFS/LGS/LSS: Load Far Pointer}{\v!{\footnote KLink("LDS,LDS")}}
\par {\uldb LEA: Load Effective Address}{\v!{\footnote KLink("LEA,LEA")}}
\par {\uldb LEAVE: High Level Procedure Exit}{\v!{\footnote KLink("LEAVE,LEAVE")}}
\par {\uldb LGDT/LIDT: Load Global/Interrupt Descriptor Table Register}{\v!{\footnote KLink("LGDT,LGDT")}}
\par {\uldb LLDT: Load Local Descriptor Table Register}{\v!{\footnote KLink("LLDT,LLDT")}}
\par {\uldb LMSW: Load Machine Status Word}{\v!{\footnote KLink("LMSW,LMSW")}}
\par {\uldb LOCK: Assert LOCK# Signal Prefix}{\v!{\footnote KLink("LOCK,LOCK")}}
\par {\uldb LODS/LODSB/LODSW/LODSD: Load String}{\v!{\footnote KLink("LODS,LODS")}}
\par {\uldb LOOP/LOOP cc: Loop According to ECX Counter}{\v!{\footnote KLink("LOOP,LOOP")}}
\par {\uldb LSL: Load Segment Limit}{\v!{\footnote KLink("LSL,LSL")}}
\par {\uldb LTR: Load Task Register}{\v!{\footnote KLink("LTR,LTR")}}
\par {\uldb MASKMOVQ: Store using byte mask}{\v!{\footnote KLink("MASKMOVQ,MASKMOVQ")}}
\par {\uldb MOV: Move}{\v!{\footnote KLink("MOV,MOV")}}
\par {\uldb MOVD: Move 32 Bits}{\v!{\footnote KLink("MOVD,MOVD")}}
\par {\uldb MOVNTQ: Streaming (cache bypass) store}{\v!{\footnote KLink("MOVNTQ,MOVNTQ")}}
\par {\uldb MOVQ: Move 64 Bits}{\v!{\footnote KLink("MOVQ,MOVQ")}}
\par {\uldb MOVS/MOVSB/MOVSW/MOVSD: Move Data from String to String}{\v!{\footnote KLink("MOVS,MOVS")}}
\par {\uldb MOVSX: Move with Sign-Extension}{\v!{\footnote KLink("MOVSX,MOVSX")}}
\par {\uldb MOVZX: Move with Zero-Extend}{\v!{\footnote KLink("MOVZX,MOVZX")}}
\par {\uldb MUL: Unsigned Multiply}{\v!{\footnote KLink("MUL,MUL")}}
\par {\uldb NEG: Two's Complement Negation}{\v!{\footnote KLink("NEG,NEG")}}
\par {\uldb NOP: No Operation}{\v!{\footnote KLink("NOP,NOP")}}
\par {\uldb NOT: One's Complement Negation}{\v!{\footnote KLink("NOT,NOT")}}
\par {\uldb OR: Logical Inclusive OR}{\v!{\footnote KLink("OR,OR")}}
\par {\uldb OUT: Output to Port}{\v!{\footnote KLink("OUT,OUT")}}
\par {\uldb OUTS/OUTSB/OUTSW/OUTSD: Output String to Port}{\v!{\footnote KLink("OUTS,OUTS")}}
\par {\uldb PACKSSWB/PACKSSDW: Pack with Signed Saturation}{\v!{\footnote KLink("PACKSSWB,PACKSSWB")}}
\par {\uldb PACKUSWB: Pack with Unsigned Saturation}{\v!{\footnote KLink("PACKUSWB,PACKUSWB")}}
\par {\uldb PADDB/PADDW/PADDD: Packed Add}{\v!{\footnote KLink("PADDB,PADDB")}}
\par {\uldb PADDSB/PADDSW: Packed Add with Saturation}{\v!{\footnote KLink("PADDSB,PADDSB")}}
\par {\uldb PADDUSB/PADDUSW: Packed Add Unsigned with Saturation}{\v!{\footnote KLink("PADDUSB,PADDUSB")}}
\par {\uldb PAND: Logical AND}{\v!{\footnote KLink("PAND,PAND")}}
\par {\uldb PANDN: Logical AND NOT}{\v!{\footnote KLink("PANDN,PANDN")}}
\par {\uldb PAVGB: Packed average of unsigned byte}{\v!{\footnote KLink("PAVGB,PAVGB")}}
\par {\uldb PAVGW: Packed average of unsigned word}{\v!{\footnote KLink("PAVGW,PAVGW")}}
\par {\uldb PCMPGTB/PCMPGTW/PCMPGTD: Packed Compare for Greater Than}{\v!{\footnote KLink("PCMPGTB,PCMPGTB")}}
\par {\uldb PEXTRW: Extract word into integer register}{\v!{\footnote KLink("PEXTRW,PEXTRW")}}
\par {\uldb PF2IW: Packed floating-point to integer word conversion with sign extend}{\v!{\footnote KLink("PF2IW,PF2IW")}}
\par {\uldb PFNACC: Packed floating-point negative accumulate}{\v!{\footnote KLink("PFNACC,PFNACC")}}
\par {\uldb PFPNACC: Packed floating-point mixed positive-negative accumulate}{\v!{\footnote KLink("PFPNACC,PFPNACC")}}
\par {\uldb PI2FW: Packed 16-bit integer to floating-point conversion}{\v!{\footnote KLink("PI2FW,PI2FW")}}
\par {\uldb PINSRW: Insert word from integer register}{\v!{\footnote KLink("PINSRW,PINSRW")}}
\par {\uldb PMADDWD: Packed Multiply and Add}{\v!{\footnote KLink("PMADDWD,PMADDWD")}}
\par {\uldb PMAXSW: Packed maximum signed word}{\v!{\footnote KLink("PMAXSW,PMAXSW")}}
\par {\uldb PMAXUB: Packed maximum unsigned byte}{\v!{\footnote KLink("PMAXUB,PMAXUB")}}
\par {\uldb PMINSW: Packed minimum signed word}{\v!{\footnote KLink("PMINSW,PMINSW")}}
\par {\uldb PMINUB: Packed minimum unsigned byte}{\v!{\footnote KLink("PMINUB,PMINUB")}}
\par {\uldb PMOVMSKB: Move mask to integer register}{\v!{\footnote KLink("PMOVMSKB,PMOVMSKB")}}
\par {\uldb PMULHUW: Packed multiply high unsigned word}{\v!{\footnote KLink("PMULHUW,PMULHUW")}}
\par {\uldb PMULHW: Packed Multiply High}{\v!{\footnote KLink("PMULHW,PMULHW")}}
\par {\uldb PMULLW: Packed Multiply Low}{\v!{\footnote KLink("PMULLW,PMULLW")}}
\par {\uldb POP: Pop a Value from the Stack}{\v!{\footnote KLink("POP,POP")}}
\par {\uldb POPA/POPAD: Pop All General-Purpose Registers}{\v!{\footnote KLink("POPA,POPA")}}
\par {\uldb POPF/POPFD: Pop Stack into EFLAGS Register}{\v!{\footnote KLink("POPF,POPF")}}
\par {\uldb POR: Bitwise Logical OR}{\v!{\footnote KLink("POR,POR")}}
\par {\uldb PREFETCHNTA: Move data closer to the processor using the NTA reference.}{\v!{\footnote KLink("PREFETCHNTA,PREFETCHNTA")}}
\par {\uldb PSADBW: Packed sum of absolute byte differences}{\v!{\footnote KLink("PSADBW,PSADBW")}}
\par {\uldb PSHUFW: Packed shuffle word}{\v!{\footnote KLink("PSHUFW,PSHUFW")}}
\par {\uldb PSLLW/PSLLD/PSLLQ: Packed Shift Left Logical}{\v!{\footnote KLink("PSLLD,PSLLD")}}
\par {\uldb PSRAW/PSRAD: Packed Shift Right Arithmetic}{\v!{\footnote KLink("PSRAD,PSRAD")}}
\par {\uldb PSRLW/PSRLD/PSRLQ: Packed Shift Right Logical}{\v!{\footnote KLink("PSRLD,PSRLD")}}
\par {\uldb PSUBB/PSUBW/PSUBD: Packed Subtract}{\v!{\footnote KLink("PSUBB,PSUBB")}}
\par {\uldb PSUBSB/PSUBSW: Packed Subtract with Saturation}{\v!{\footnote KLink("PSUBSB,PSUBSB")}}
\par {\uldb PSUBUSB/PSUBUSW: Packed Subtract Unsigned with Saturation}{\v!{\footnote KLink("PSUBUSB,PSUBUSB")}}
\par {\uldb PSWAPD: Packed swap doubleword}{\v!{\footnote KLink("PSWAPD,PSWAPD")}}
\par {\uldb PUNPCKHBW/PUNPCKHWD/PUNPCKHDQ: Unpack High Packed Data}{\v!{\footnote KLink("PUNPCKHBW,PUNPCKHBW")}}
\par {\uldb PUNPCKLBW/PUNPCKLWD/PUNPCKLDQ: Unpack Low Packed Data}{\v!{\footnote KLink("PUNPCKLBW,PUNPCKLBW")}}
\par {\uldb PUSH: Push Word or Doubleword Onto the Stack}{\v!{\footnote KLink("PUSH,PUSH")}}
\par {\uldb PUSHA/PUSHAD: Push All General-Purpose Registers}{\v!{\footnote KLink("PUSHA,PUSHA")}}
\par {\uldb PUSHF/PUSHFD: Push EFLAGS Register onto the Stack}{\v!{\footnote KLink("PUSHF,PUSHF")}}
\par {\uldb PXOR: Logical Exclusive OR}{\v!{\footnote KLink("PXOR,PXOR")}}
\par {\uldb RCL/RCR/ROL/ROR: Rotate}{\v!{\footnote KLink("RCL,RCL")}}
\par {\uldb RDMSR: Read from Model Specific Register}{\v!{\footnote KLink("RDMSR,RDMSR")}}
\par {\uldb RDPMC: Read Performance-Monitoring Counters}{\v!{\footnote KLink("RDPMC,RDPMC")}}
\par {\uldb RDTSC: Read Time-Stamp Counter}{\v!{\footnote KLink("RDTSC,RDTSC")}}
\par {\uldb REP/REPE/REPZ/REPNE/REPNZ: Repeat String Operation Prefix}{\v!{\footnote KLink("REP,REP")}}
\par {\uldb RET: Return from Procedure}{\v!{\footnote KLink("RETF,RETF")}}
\par {\uldb RSM: Resume from System Management Mode}{\v!{\footnote KLink("RSM,RSM")}}
\par {\uldb SAHF: Store AH into Flags}{\v!{\footnote KLink("SAHF,SAHF")}}
\par {\uldb SAL/SAR/SHL/SHR: Shift}{\v!{\footnote KLink("SAL,SAL")}}
\par {\uldb SBB: Integer Subtraction with Borrow}{\v!{\footnote KLink("SBB,SBB")}}
\par {\uldb SCAS/SCASB/SCASW/SCASD: Scan String}{\v!{\footnote KLink("SCAS,SCAS")}}
\par {\uldb SET cc: Set Byte on Condition}{\v!{\footnote KLink("SET,SET")}}
\par {\uldb SFENCE: Store fence}{\v!{\footnote KLink("SFENCE,SFENCE")}}
\par {\uldb SGDT/SIDT: Store Global/Interrupt Descriptor Table Register}{\v!{\footnote KLink("SGDT,SGDT")}}
\par {\uldb SHLD: Double Precision Shift Left}{\v!{\footnote KLink("SHLD,SHLD")}}
\par {\uldb SHRD: Double Precision Shift Right}{\v!{\footnote KLink("SHRD,SHRD")}}
\par {\uldb SLDT: Store Local Descriptor Table Register}{\v!{\footnote KLink("SLDT,SLDT")}}
\par {\uldb SMSW: Store Machine Status Word}{\v!{\footnote KLink("SMSW,SMSW")}}
\par {\uldb Internal disassembler's symbol which indicates that the next command is used with the SS: segment.}{\v!{\footnote KLink("SS:,SS:")}}
\par {\uldb STC: Set Carry Flag}{\v!{\footnote KLink("STC,STC")}}
\par {\uldb STD: Set Direction Flag}{\v!{\footnote KLink("STD,STD")}}
\par {\uldb STI: Set Interrupt Flag}{\v!{\footnote KLink("STI,STI")}}
\par {\uldb STOS/STOSB/STOSW/STOSD: Store String}{\v!{\footnote KLink("STOS,STOS")}}
\par {\uldb STR: Store Task Register}{\v!{\footnote KLink("STR,STR")}}
\par {\uldb SUB: Subtract}{\v!{\footnote KLink("SUB,SUB")}}
\par {\uldb TEST: Logical Compare}{\v!{\footnote KLink("TEST,TEST")}}
\par {\uldb UD2: Undefined Instruction}{\v!{\footnote KLink("UD2,UD2")}}
\par {\uldb VERR, VERW: Verify a Segment for Reading or Writing}{\v!{\footnote KLink("VERR,VERR")}}
\par {\uldb WAIT: Wait}{\v!{\footnote KLink("WAIT,WAIT")}}
\par {\uldb WBINVD: Write Back and Invalidate Cache}{\v!{\footnote KLink("WBINVD,WBINVD")}}
\par {\uldb WRMSR: Write to Model Specific Register}{\v!{\footnote KLink("WRMSR,WRMSR")}}
\par {\uldb XADD: Exchange and Add}{\v!{\footnote KLink("XADD,XADD")}}
\par {\uldb XCHG: Exchange Register/Memory with Register}{\v!{\footnote KLink("XCHG,XCHG")}}
\par {\uldb XLAT/XLATB: Table Look-up Translation}{\v!{\footnote KLink("XLAT,XLAT")}}
\par {\uldb XOR: Logical Exclusive OR}{\v!{\footnote KLink("XOR,XOR")}}
}
