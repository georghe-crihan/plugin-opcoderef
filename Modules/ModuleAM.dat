<PF2IW>
[1]
"PF2IW: Packed floating-point to integer word conversion with sign extend"
""
"PF2IW is a vector instruction that converts a vector register containing single-precision floating-point operands to 16-bit signed integers using truncation. Arguments outside the range representable by signed 16-bit integers are saturated to the largest and smallest 16-bit integer, depending on their sign. All results are sign-extended to 32-bits."
[2]
"PF2IW mmreg1, mmreg2 performs the following operations:"
""
"IF (mmreg2[31:0] >= 2 15 )"
"THEN mmreg1[31:0] = 0x0000_7FFF"
"ELSE IF (mmreg2[31:0] <= -2 15 )"
"THEN mmreg1[31:0] = 0xFFFF_8000"
"ELSE mmreg1[31:0] = int(mmreg2[31:0])"
"IF (mmreg2[63:32] >= 2 15 )"
"THEN mmreg1[63:32] = 0x0000_7FFF"
"ELSE IF (mmreg2[63:32] <= -2 15 )"
"THEN mmreg1[63:32] = 0xFFFF_8000"
"ELSE mmreg1[63:32] = int(mmreg2[63:32])"
""
"PF2IW mmreg, mem64 performs the following operations:"
""
"IF (mem64[31:0] >= 2 15 )"
"THEN mmreg[31:0] = 0x0000_7FFF"
"ELSE IF (mem64[31:0] <= -2 15 )"
"THEN mmreg[31:0] = 0xFFFF_8000"
"ELSE mmreg[31:0] = int(mem64[31:0])"
"IF (mem64[63:32] >= 2 15 )"
"THEN mmreg[63:32] = 0x0000_7FFF"
"ELSE IF (mem64[63:32] <= -2 15 )"
"THEN mmreg[63:32] = 0xFFFF_8000"
"ELSE mmreg[63:32] = int(mem64[63:32])"
[3]
"None."
[4]
"Protected Mode Exceptions"
""
"#Invalid Opcode, The emulate instruction bit (EM) of the control register (CR0) is set to 1."
"#Device Not Available, Save the floating-point or MMX state if the task switch bit (TS) of the control register (CR0) is set to 1."
"#Stack Exception, During instruction execution, the stack segment limit was exceeded."
"#General Protection, During instruction execution, the effective address of one of the segment registers used for the operand points to an illegal memory location."
"#Page fault, A page fault resulted from the execution of the instruction."
"#Float point exception pending, An exception is pending due to the floating-point execution unit."
"#Alignment check, An unaligned memory reference resulted from the instruction execution, and the alignment mask bit (AM) of the control register (CR0) is set to 1. (In Protected Mode, CPL = 3.)"
""
"Real-Address Mode Exceptions"
""
"#Invalid Opcode, The emulate instruction bit (EM) of the control register (CR0) is set to 1."
"#Device Not Available, Save the floating-point or MMX state if the task switch bit (TS) of the control register (CR0) is set to 1."
"#Segment Overrun, One of the instruction data operands falls outside the address range 00000h to 0FFFFh."
"#Float point exception pending, An exception is pending due to the floating-point execution unit."
""
"Virtual-8086 Mode Exceptions"
""
"#Invalid Opcode, The emulate instruction bit (EM) of the control register (CR0) is set to 1."
"#Device Not Available, Save the floating-point or MMX state if the task switch bit (TS) of the control register (CR0) is set to 1."
"#Segment Overrun, One of the instruction data operands falls outside the address range 00000h to 0FFFFh."
"#Page fault, A page fault resulted from the execution of the instruction."
"#Float point exception pending, An exception is pending due to the floating-point execution unit."
"#Alignment check, An unaligned memory reference resulted from the instruction execution, and the alignment mask bit (AM) of the control register (CR0) is set to 1. (In Protected Mode, CPL = 3.)"
[5]
"0F 0F 1C /r PF2IW mmreg1, mmreg2 or PF2IW mmreg, mem64"
[6]
</PF2IW>
<PFNACC>
[1]
"PFNACC: Packed floating-point negative accumulate"
""
"PFNACC is a vector instruction that does negative accumulation of the two doublewords of the destination operand and the source operand. PFNACC then stores the results in the low and high words of the destination operand, respectively. Both operands are single-precision, floating-point operands with 24-bit significands."
[2]
"PFNACC mmreg1, mmreg2 performs the following operations:"
""
"mmreg1[31:0] = mmreg1[31:0] – mmreg1[63:32]"
"mmreg1[63:32] = mmreg2[31:0] – mmreg2[63:32]"
""
"PFNACC mmreg, mem64 performs the following operations:"
""
"mmreg[31:0] = mmreg[31:0] – mmreg[63:32]"
"mmreg[63:32] = mem64[31:0] – mem64[63:32]"
[3]
"None."
[4]
"Protected Mode Exceptions"
""
"#Invalid Opcode, The emulate instruction bit (EM) of the control register (CR0) is set to 1."
"#Device Not Available, Save the floating-point or MMX state if the task switch bit (TS) of the control register (CR0) is set to 1."
"#Stack Exception, During instruction execution, the stack segment limit was exceeded."
"#General Protection, During instruction execution, the effective address of one of the segment registers used for the operand points to an illegal memory location."
"#Page fault, A page fault resulted from the execution of the instruction."
"#Float point exception pending, An exception is pending due to the floating-point execution unit."
"#Alignment check, An unaligned memory reference resulted from the instruction execution, and the alignment mask bit (AM) of the control register (CR0) is set to 1. (In Protected Mode, CPL = 3.)"
""
"Real-Address Mode Exceptions"
""
"#Invalid Opcode, The emulate instruction bit (EM) of the control register (CR0) is set to 1."
"#Device Not Available, Save the floating-point or MMX state if the task switch bit (TS) of the control register (CR0) is set to 1."
"#Segment Overrun, One of the instruction data operands falls outside the address range 00000h to 0FFFFh."
"#Float point exception pending, An exception is pending due to the floating-point execution unit."
""
"Virtual-8086 Mode Exceptions"
""
"#Invalid Opcode, The emulate instruction bit (EM) of the control register (CR0) is set to 1."
"#Device Not Available, Save the floating-point or MMX state if the task switch bit (TS) of the control register (CR0) is set to 1."
"#Segment Overrun, One of the instruction data operands falls outside the address range 00000h to 0FFFFh."
"#Page fault, A page fault resulted from the execution of the instruction."
"#Float point exception pending, An exception is pending due to the floating-point execution unit."
"#Alignment check, An unaligned memory reference resulted from the instruction execution, and the alignment mask bit (AM) of the control register (CR0) is set to 1. (In Protected Mode, CPL = 3.)"
[5]
"0F 0F 8A /r PFNACC mmreg1, mmreg2 or PFNACC mmreg, mem64"
[6]
</PFNACC>
<PFPNACC>
[1]
"PFPNACC: Packed floating-point mixed positive-negative accumulate"
""
"PFPNACC is a vector instruction that does mixed negative and positive accumulation of the two doublewords of the destination operand and the source operand and stores the results in the low and high words of the destination operand, respectively. Both operands are single-precision, floating-point operands with 24-bit significands."
[2]
"PFPNACC mmreg1, mmreg2 performs the following operations:"
""
"mmreg1[31:0] = mmreg1[31:0] – mmreg1[63:32]"
"mmreg1[63:32] = mmreg2[31:0] + mmreg2[63:32]"
"PFPNACC mmreg, mem64 performs the following operations:"
""
"mmreg[31:0] = mmreg[31:0] – mmreg[63:32]"
"mmreg[63:32] = mem64[31:0] + mem64[63:32]"
[3]
"None."
[4]
"Protected Mode Exceptions"
""
"#Invalid Opcode, The emulate instruction bit (EM) of the control register (CR0) is set to 1."
"#Device Not Available, Save the floating-point or MMX state if the task switch bit (TS) of the control register (CR0) is set to 1."
"#Stack Exception, During instruction execution, the stack segment limit was exceeded."
"#General Protection, During instruction execution, the effective address of one of the segment registers used for the operand points to an illegal memory location."
"#Page fault, A page fault resulted from the execution of the instruction."
"#Float point exception pending, An exception is pending due to the floating-point execution unit."
"#Alignment check, An unaligned memory reference resulted from the instruction execution, and the alignment mask bit (AM) of the control register (CR0) is set to 1. (In Protected Mode, CPL = 3.)"
""
"Real-Address Mode Exceptions"
""
"#Invalid Opcode, The emulate instruction bit (EM) of the control register (CR0) is set to 1."
"#Device Not Available, Save the floating-point or MMX state if the task switch bit (TS) of the control register (CR0) is set to 1."
"#Segment Overrun, One of the instruction data operands falls outside the address range 00000h to 0FFFFh."
"#Float point exception pending, An exception is pending due to the floating-point execution unit."
""
"Virtual-8086 Mode Exceptions"
""
"#Invalid Opcode, The emulate instruction bit (EM) of the control register (CR0) is set to 1."
"#Device Not Available, Save the floating-point or MMX state if the task switch bit (TS) of the control register (CR0) is set to 1."
"#Segment Overrun, One of the instruction data operands falls outside the address range 00000h to 0FFFFh."
"#Page fault, A page fault resulted from the execution of the instruction."
"#Float point exception pending, An exception is pending due to the floating-point execution unit."
"#Alignment check, An unaligned memory reference resulted from the instruction execution, and the alignment mask bit (AM) of the control register (CR0) is set to 1. (In Protected Mode, CPL = 3.)"
[5]
"0F 0F 8E /r PFPNACC mmreg1, mmreg2 or PFPNACC mmreg, mem64"
[6]
</PFPNACC>
<PI2FW>
[1]
"PI2FW: Packed 16-bit integer to floating-point conversion"
""
"PI2FW is a vector instruction that converts a vector register containing signed, 16-bit integers to single-precision, floating-point operands."
[2]
"PI2FW mmreg1, mmreg2 performs the following operations:"
""
"mmreg1[31:0] = float(mmreg2[15:0])"
"mmreg1[63:32] = float(mmreg2[47:32])"
"PI2FW mmreg, mem64” performs the following operations:"
""
"mmreg[31:0] = float(mem64[15:0])"
"mmreg[63:32] = float(mem64[47:32])"
[3]
"None."
[4]
"Protected Mode Exceptions"
""
"#Invalid Opcode, The emulate instruction bit (EM) of the control register (CR0) is set to 1."
"#Device Not Available, Save the floating-point or MMX state if the task switch bit (TS) of the control register (CR0) is set to 1."
"#Stack Exception, During instruction execution, the stack segment limit was exceeded."
"#General Protection, During instruction execution, the effective address of one of the segment registers used for the operand points to an illegal memory location."
"#Page fault, A page fault resulted from the execution of the instruction."
"#Float point exception pending, An exception is pending due to the floating-point execution unit."
"#Alignment check, An unaligned memory reference resulted from the instruction execution, and the alignment mask bit (AM) of the control register (CR0) is set to 1. (In Protected Mode, CPL = 3.)"
""
"Real-Address Mode Exceptions"
""
"#Invalid Opcode, The emulate instruction bit (EM) of the control register (CR0) is set to 1."
"#Device Not Available, Save the floating-point or MMX state if the task switch bit (TS) of the control register (CR0) is set to 1."
"#Segment Overrun, One of the instruction data operands falls outside the address range 00000h to 0FFFFh."
"#Float point exception pending, An exception is pending due to the floating-point execution unit."
""
"Virtual-8086 Mode Exceptions"
""
"#Invalid Opcode, The emulate instruction bit (EM) of the control register (CR0) is set to 1."
"#Device Not Available, Save the floating-point or MMX state if the task switch bit (TS) of the control register (CR0) is set to 1."
"#Segment Overrun, One of the instruction data operands falls outside the address range 00000h to 0FFFFh."
"#Page fault, A page fault resulted from the execution of the instruction."
"#Float point exception pending, An exception is pending due to the floating-point execution unit."
"#Alignment check, An unaligned memory reference resulted from the instruction execution, and the alignment mask bit (AM) of the control register (CR0) is set to 1. (In Protected Mode, CPL = 3.)"
[5]
"0F 0F 0C /r PI2FW mmreg1, mmreg2 or PI2FW mmreg, mem64"
[6]
</PI2FW>
<PSWAPD>
[1]
"PSWAPD: Packed swap doubleword"
""
"The PSWAPD instruction swaps or reverses the upper and lower doublewords of the source operand."
[2]
"PSWAPD mmreg1, mmreg2 performs the following operations:"
""
"mmreg1[63:32] = mmreg2[31:0])"
"mmreg1[31:0] = mmreg2[63:32])"
""
"PSWAPD mmreg, mem64 performs the following operations:"
""
"mmreg[63:32] = mem64[31:0])"
"mmreg[31:0] = mem64[63:32])"
[3]
"None."
[4]
"Protected Mode Exceptions"
""
"#Invalid Opcode, The emulate instruction bit (EM) of the control register (CR0) is set to 1."
"#Device Not Available, Save the floating-point or MMX state if the task switch bit (TS) of the control register (CR0) is set to 1."
"#Stack Exception, During instruction execution, the stack segment limit was exceeded."
"#General Protection, During instruction execution, the effective address of one of the segment registers used for the operand points to an illegal memory location."
"#Page fault, A page fault resulted from the execution of the instruction."
"#Float point exception pending, An exception is pending due to the floating-point execution unit."
"#Alignment check, An unaligned memory reference resulted from the instruction execution, and the alignment mask bit (AM) of the control register (CR0) is set to 1. (In Protected Mode, CPL = 3.)"
""
"Real-Address Mode Exceptions"
""
"#Invalid Opcode, The emulate instruction bit (EM) of the control register (CR0) is set to 1."
"#Device Not Available, Save the floating-point or MMX state if the task switch bit (TS) of the control register (CR0) is set to 1."
"#Segment Overrun, One of the instruction data operands falls outside the address range 00000h to 0FFFFh."
"#Float point exception pending, An exception is pending due to the floating-point execution unit."
""
"Virtual-8086 Mode Exceptions"
""
"#Invalid Opcode, The emulate instruction bit (EM) of the control register (CR0) is set to 1."
"#Device Not Available, Save the floating-point or MMX state if the task switch bit (TS) of the control register (CR0) is set to 1."
"#Segment Overrun, One of the instruction data operands falls outside the address range 00000h to 0FFFFh."
"#Page fault, A page fault resulted from the execution of the instruction."
"#Float point exception pending, An exception is pending due to the floating-point execution unit."
"#Alignment check, An unaligned memory reference resulted from the instruction execution, and the alignment mask bit (AM) of the control register (CR0) is set to 1. (In Protected Mode, CPL = 3.)"
[5]
"0F 0F BB /r PSWAPD mmreg1, mmreg2 or PSWAPD mmreg, mem64"
[6]
</PSWAPD>
<MASKMOVQ>
[1]
"MASKMOVQ: Store using byte mask"
""
"The MASKMOVQ instruction uses the result of an MMX compare instruction to conditionally store MMX data to memory on a byte-by-byte basis."
[2]
"MASKMOVQ mmreg1, mmreg2 (edi) performs the following operations:"
""
"memory[edi][63:56] = mmreg2[63] ? mmreg1[63:56] : memory[edi][63:56]"
"memory[edi][55:48] = mmreg2[55] ? mmreg1[55:48] : memory[edi][55:48]"
"memory[edi][47:40] = mmreg2[47] ? mmreg1[47:40] : memory[edi][47:40]"
"memory[edi][39:32] = mmreg2[39] ? mmreg1[39:32] : memory[edi][39:32]"
"memory[edi][31:24] = mmreg2[31] ? mmreg1[31:24] : memory[edi][31:24]"
"memory[edi][23:16] = mmreg2[23] ? mmreg1[23:16] : memory[edi][23:16]"
"memory[edi][15:8] = mmreg2[15] ? mmreg1[15:8] : memory[edi][15:8]"
"memory[edi][7:0] = mmreg2[7] ? mmreg1[7:0] : memory[edi][7:0]"
[3]
"None."
[4]
"Protected Mode Exceptions"
""
"#Invalid Opcode, The emulate instruction bit (EM) of the control register (CR0) is set to 1."
"#Device Not Available, Save the floating-point or MMX state if the task switch bit (TS) of the control register (CR0) is set to 1."
"#Stack Exception, During instruction execution, the stack segment limit was exceeded."
"#General Protection, During instruction execution, the effective address of one of the segment registers used for the operand points to an illegal memory location."
"#Page fault, A page fault resulted from the execution of the instruction."
"#Float point exception pending, An exception is pending due to the floating-point execution unit."
"#Alignment check, An unaligned memory reference resulted from the instruction execution, and the alignment mask bit (AM) of the control register (CR0) is set to 1. (In Protected Mode, CPL = 3.)"
""
"Real-Address Mode Exceptions"
""
"#Invalid Opcode, The emulate instruction bit (EM) of the control register (CR0) is set to 1."
"#Device Not Available, Save the floating-point or MMX state if the task switch bit (TS) of the control register (CR0) is set to 1."
"#Segment Overrun, One of the instruction data operands falls outside the address range 00000h to 0FFFFh."
"#Float point exception pending, An exception is pending due to the floating-point execution unit."
""
"Virtual-8086 Mode Exceptions"
""
"#Invalid Opcode, The emulate instruction bit (EM) of the control register (CR0) is set to 1."
"#Device Not Available, Save the floating-point or MMX state if the task switch bit (TS) of the control register (CR0) is set to 1."
"#Segment Overrun, One of the instruction data operands falls outside the address range 00000h to 0FFFFh."
"#Page fault, A page fault resulted from the execution of the instruction."
"#Float point exception pending, An exception is pending due to the floating-point execution unit."
"#Alignment check, An unaligned memory reference resulted from the instruction execution, and the alignment mask bit (AM) of the control register (CR0) is set to 1. (In Protected Mode, CPL = 3.)"
[5]
"0F F7 /r MASKMOVQ mmreg1, mmreg2 (edi)"
[6]
</MASKMOVQ>
<MOVNTQ>
[1]
"MOVNTQ: Streaming (cache bypass) store"
""
"The MOVNTQ instruction is used to store data without first reading in old data (no write allocate)."
[2]
"MOVNTQ mem64, mmreg performs the following operations:"
""
"mem64[63:0] = mmreg"
[3]
"None."
[4]
"Protected Mode Exceptions"
""
"#Invalid Opcode, The emulate instruction bit (EM) of the control register (CR0) is set to 1."
"#Device Not Available, Save the floating-point or MMX state if the task switch bit (TS) of the control register (CR0) is set to 1."
"#Stack Exception, During instruction execution, the stack segment limit was exceeded."
"#General Protection, During instruction execution, the effective address of one of the segment registers used for the operand points to an illegal memory location."
"#Page fault, A page fault resulted from the execution of the instruction."
"#Float point exception pending, An exception is pending due to the floating-point execution unit."
"#Alignment check, An unaligned memory reference resulted from the instruction execution, and the alignment mask bit (AM) of the control register (CR0) is set to 1. (In Protected Mode, CPL = 3.)"
""
"Real-Address Mode Exceptions"
""
"#Invalid Opcode, The emulate instruction bit (EM) of the control register (CR0) is set to 1."
"#Device Not Available, Save the floating-point or MMX state if the task switch bit (TS) of the control register (CR0) is set to 1."
"#Segment Overrun, One of the instruction data operands falls outside the address range 00000h to 0FFFFh."
"#Float point exception pending, An exception is pending due to the floating-point execution unit."
""
"Virtual-8086 Mode Exceptions"
""
"#Invalid Opcode, The emulate instruction bit (EM) of the control register (CR0) is set to 1."
"#Device Not Available, Save the floating-point or MMX state if the task switch bit (TS) of the control register (CR0) is set to 1."
"#Segment Overrun, One of the instruction data operands falls outside the address range 00000h to 0FFFFh."
"#Page fault, A page fault resulted from the execution of the instruction."
"#Float point exception pending, An exception is pending due to the floating-point execution unit."
"#Alignment check, An unaligned memory reference resulted from the instruction execution, and the alignment mask bit (AM) of the control register (CR0) is set to 1. (In Protected Mode, CPL = 3.)"
[5]
"0F E7 /r MOVNTQ mem64, mmreg"
[6]
</MOVNTQ>
<PAVGB>
[1]
"PAVGB: Packed average of unsigned byte"
""
"The PAVGB instruction produces the rounded up averages of the eight unsigned 8-bit integer values in the source operand (an MMX register or a 64-bit memory location) and the eight corresponding unsigned 8-bit integer values in the destination operand (an MMX register). It does so by adding the source and destination byte values to get a 9-bit intermediate value. The intermediate value is then incremented by 1, divided by 2 (shifted right one place) and rounded up. The eight unsigned 8-bit results are stored in the MMX register specified as the destination operand."
""
"The PAVGB instruction is identical to the 3DNow! PAVGUSB instruction and can be used for pixel averaging in MPEG-2 motion compensation and video scaling operations."
[2]
"PAVGB mmreg1, mmreg2 performs the following operations:"
""
";round up by using a ceiling function"
"mmreg1[7:0] = (mmreg1[7:0] + mmreg2[7:0]) / 2"
"mmreg1[15:8] = (mmreg1[15:8] + mmreg2[15:8]) / 2"
"mmreg1[23:16] = (mmreg1[23:16] + mmreg2[23:16]) / 2"
"mmreg1[31:24] = (mmreg1[31:24] + mmreg2[31:24]) / 2"
"mmreg1[39:32] = (mmreg1[39:32] + mmreg2[39:32]) / 2"
"mmreg1[47:40] = (mmreg1[47:40] + mmreg2[47:40]) / 2"
"mmreg1[55:48] = (mmreg1[55:48] + mmreg2[55:48]) / 2"
"mmreg1[63:56] = (mmreg1[63:56] + mmreg2[63:56]) / 2"
""
"PAVGB mmreg, mem64 performs the following operations:"
""
";round up by using a ceiling function"
"mmreg[7:0] = (mmreg[7:0] + mem64[7:0]) / 2"
"mmreg[15:8] = (mmreg[15:8] + mem64[15:8]) / 2"
"mmreg[23:16] = (mmreg[23:16] + mem64[23:16]) / 2"
"mmreg[31:24] = (mmreg[31:24] + mem64[31:24]) / 2"
"mmreg[39:32] = (mmreg[39:32] + mem64[39:32]) / 2"
"mmreg[47:40] = (mmreg[47:40] + mem64[47:40]) / 2"
"mmreg[55:48] = (mmreg[55:48] + mem64[55:48]) / 2"
"mmreg[63:56] = (mmreg[63:56] + mem64[63:56]) / 2"
[3]
"None."
[4]
"Protected Mode Exceptions"
""
"#Invalid Opcode, The emulate instruction bit (EM) of the control register (CR0) is set to 1."
"#Device Not Available, Save the floating-point or MMX state if the task switch bit (TS) of the control register (CR0) is set to 1."
"#Stack Exception, During instruction execution, the stack segment limit was exceeded."
"#General Protection, During instruction execution, the effective address of one of the segment registers used for the operand points to an illegal memory location."
"#Page fault, A page fault resulted from the execution of the instruction."
"#Float point exception pending, An exception is pending due to the floating-point execution unit."
"#Alignment check, An unaligned memory reference resulted from the instruction execution, and the alignment mask bit (AM) of the control register (CR0) is set to 1. (In Protected Mode, CPL = 3.)"
""
"Real-Address Mode Exceptions"
""
"#Invalid Opcode, The emulate instruction bit (EM) of the control register (CR0) is set to 1."
"#Device Not Available, Save the floating-point or MMX state if the task switch bit (TS) of the control register (CR0) is set to 1."
"#Segment Overrun, One of the instruction data operands falls outside the address range 00000h to 0FFFFh."
"#Float point exception pending, An exception is pending due to the floating-point execution unit."
""
"Virtual-8086 Mode Exceptions"
""
"#Invalid Opcode, The emulate instruction bit (EM) of the control register (CR0) is set to 1."
"#Device Not Available, Save the floating-point or MMX state if the task switch bit (TS) of the control register (CR0) is set to 1."
"#Segment Overrun, One of the instruction data operands falls outside the address range 00000h to 0FFFFh."
"#Page fault, A page fault resulted from the execution of the instruction."
"#Float point exception pending, An exception is pending due to the floating-point execution unit."
"#Alignment check, An unaligned memory reference resulted from the instruction execution, and the alignment mask bit (AM) of the control register (CR0) is set to 1. (In Protected Mode, CPL = 3.)"
[5]
"0F E0 /r PAVGB mmreg1, mmreg2 or PAVGB mmreg, mem64"
[6]
</PAVGB>
<PAVGW>
[1]
"PAVGW: Packed average of unsigned word"
""
"The PAVGW instruction produces the rounded up averages of the four unsigned 16-bit integer values in the source operand (an MMX register or a 64-bit memory location) and the four corresponding unsigned 16-bit integer values in the destination operand (an MMX register)."
[2]
"PAVGW mmreg1, mmreg2 performs the following operations:"
""
";round up by using a ceiling function"
"mmreg1[15:0] = (mmreg1[15:0] + mmreg2[15:0]) / 2"
"mmreg1[31:16] = (mmreg1[31:16] + mmreg2[31:16]) / 2"
"mmreg1[47:32] = (mmreg1[47:32] + mmreg2[47:32]) / 2"
"mmreg1[63:48] = (mmreg1[63:48] + mmreg2[63:48]) / 2"
""
"PAVGW mmreg, mem64 performs the following operations:"
""
";round up by using a ceiling function"
"mmreg[15:0] = (mmreg[15:0] + mem64[15:0]) / 2"
"mmreg[31:16] = (mmreg[31:16] + mem64[31:16]) / 2"
"mmreg[47:32] = (mmreg[47:32] + mem64[47:32]) / 2"
"mmreg[63:48] = (mmreg[63:48] + mem64[63:48]) / 2"
[3]
"None."
[4]
"Protected Mode Exceptions"
""
"#Invalid Opcode, The emulate instruction bit (EM) of the control register (CR0) is set to 1."
"#Device Not Available, Save the floating-point or MMX state if the task switch bit (TS) of the control register (CR0) is set to 1."
"#Stack Exception, During instruction execution, the stack segment limit was exceeded."
"#General Protection, During instruction execution, the effective address of one of the segment registers used for the operand points to an illegal memory location."
"#Page fault, A page fault resulted from the execution of the instruction."
"#Float point exception pending, An exception is pending due to the floating-point execution unit."
"#Alignment check, An unaligned memory reference resulted from the instruction execution, and the alignment mask bit (AM) of the control register (CR0) is set to 1. (In Protected Mode, CPL = 3.)"
""
"Real-Address Mode Exceptions"
""
"#Invalid Opcode, The emulate instruction bit (EM) of the control register (CR0) is set to 1."
"#Device Not Available, Save the floating-point or MMX state if the task switch bit (TS) of the control register (CR0) is set to 1."
"#Segment Overrun, One of the instruction data operands falls outside the address range 00000h to 0FFFFh."
"#Float point exception pending, An exception is pending due to the floating-point execution unit."
""
"Virtual-8086 Mode Exceptions"
""
"#Invalid Opcode, The emulate instruction bit (EM) of the control register (CR0) is set to 1."
"#Device Not Available, Save the floating-point or MMX state if the task switch bit (TS) of the control register (CR0) is set to 1."
"#Segment Overrun, One of the instruction data operands falls outside the address range 00000h to 0FFFFh."
"#Page fault, A page fault resulted from the execution of the instruction."
"#Float point exception pending, An exception is pending due to the floating-point execution unit."
"#Alignment check, An unaligned memory reference resulted from the instruction execution, and the alignment mask bit (AM) of the control register (CR0) is set to 1. (In Protected Mode, CPL = 3.)"
[5]
"0F E3 /r PAVGW mmreg1, mmreg2 or PAVGB mmreg, mem64"
[6]
</PAVGW>
<PEXTRW>
[1]
"PEXTRW: Extract word into integer register"
""
"The PEXTRW instruction extracts one of the four words pointed to by imm8 from an MMX register and stores that into the least significant word of a 32-bit integer register."
[2]
"PEXTRW reg32, mmreg, imm8 performs the following operations:"
""
"index = imm8[1:0] * 16"
"reg32[31:16] = 0"
"reg32[15:0] = mmreg[index+15:index]"
[3]
"None."
[4]
"Protected Mode Exceptions"
""
"#Invalid Opcode, The emulate instruction bit (EM) of the control register (CR0) is set to 1."
"#Device Not Available, Save the floating-point or MMX state if the task switch bit (TS) of the control register (CR0) is set to 1."
"#Stack Exception, During instruction execution, the stack segment limit was exceeded."
"#General Protection, During instruction execution, the effective address of one of the segment registers used for the operand points to an illegal memory location."
"#Page fault, A page fault resulted from the execution of the instruction."
"#Float point exception pending, An exception is pending due to the floating-point execution unit."
"#Alignment check, An unaligned memory reference resulted from the instruction execution, and the alignment mask bit (AM) of the control register (CR0) is set to 1. (In Protected Mode, CPL = 3.)"
""
"Real-Address Mode Exceptions"
""
"#Invalid Opcode, The emulate instruction bit (EM) of the control register (CR0) is set to 1."
"#Device Not Available, Save the floating-point or MMX state if the task switch bit (TS) of the control register (CR0) is set to 1."
"#Segment Overrun, One of the instruction data operands falls outside the address range 00000h to 0FFFFh."
"#Float point exception pending, An exception is pending due to the floating-point execution unit."
""
"Virtual-8086 Mode Exceptions"
""
"#Invalid Opcode, The emulate instruction bit (EM) of the control register (CR0) is set to 1."
"#Device Not Available, Save the floating-point or MMX state if the task switch bit (TS) of the control register (CR0) is set to 1."
"#Segment Overrun, One of the instruction data operands falls outside the address range 00000h to 0FFFFh."
"#Page fault, A page fault resulted from the execution of the instruction."
"#Float point exception pending, An exception is pending due to the floating-point execution unit."
"#Alignment check, An unaligned memory reference resulted from the instruction execution, and the alignment mask bit (AM) of the control register (CR0) is set to 1. (In Protected Mode, CPL = 3.)"
[5]
"0F C5 /r PEXTRW reg32, mmreg, imm8"
[6]
</PEXTRW>
<PINSRW>
[1]
"PINSRW: Insert word from integer register"
""
"The PINSRW instruction inserts the least significant word of an integer register into one of the four words of an MMX register."
[2]
"PINSRW mmreg, reg32, imm8 performs the following operations:"
""
"index = imm8[1:0] * 16"
"mmreg[index+15:index] = reg32[15:0]"
"mmreg[rest] = mmreg[rest] / no change (merge)"
""
"PINSRW mmreg, mem16, imm8 performs the following operations:"
""
"index = imm8[1:0] * 16"
"mmreg[index+15:index] = mem16[15:0]"
"mmreg[rest] = mmreg[rest] / no change (merge)"
[3]
"None."
[4]
"Protected Mode Exceptions"
""
"#Invalid Opcode, The emulate instruction bit (EM) of the control register (CR0) is set to 1."
"#Device Not Available, Save the floating-point or MMX state if the task switch bit (TS) of the control register (CR0) is set to 1."
"#Stack Exception, During instruction execution, the stack segment limit was exceeded."
"#General Protection, During instruction execution, the effective address of one of the segment registers used for the operand points to an illegal memory location."
"#Page fault, A page fault resulted from the execution of the instruction."
"#Float point exception pending, An exception is pending due to the floating-point execution unit."
"#Alignment check, An unaligned memory reference resulted from the instruction execution, and the alignment mask bit (AM) of the control register (CR0) is set to 1. (In Protected Mode, CPL = 3.)"
""
"Real-Address Mode Exceptions"
""
"#Invalid Opcode, The emulate instruction bit (EM) of the control register (CR0) is set to 1."
"#Device Not Available, Save the floating-point or MMX state if the task switch bit (TS) of the control register (CR0) is set to 1."
"#Segment Overrun, One of the instruction data operands falls outside the address range 00000h to 0FFFFh."
"#Float point exception pending, An exception is pending due to the floating-point execution unit."
""
"Virtual-8086 Mode Exceptions"
""
"#Invalid Opcode, The emulate instruction bit (EM) of the control register (CR0) is set to 1."
"#Device Not Available, Save the floating-point or MMX state if the task switch bit (TS) of the control register (CR0) is set to 1."
"#Segment Overrun, One of the instruction data operands falls outside the address range 00000h to 0FFFFh."
"#Page fault, A page fault resulted from the execution of the instruction."
"#Float point exception pending, An exception is pending due to the floating-point execution unit."
"#Alignment check, An unaligned memory reference resulted from the instruction execution, and the alignment mask bit (AM) of the control register (CR0) is set to 1. (In Protected Mode, CPL = 3.)"
[5]
"0F C4 /r PINSRW mmreg, reg32, imm8 or PINSRW mmreg, mem16, imm8"
[6]
</PINSRW>
<PMAXSW>
[1]
"PMAXSW: Packed maximum signed word"
""
"The PMAXSW instruction operates on signed 16-bit data and selects the maximum signed value between source 1 and source 2 for each of the four word positions."
[2]
"PMAXSW mmreg1, mmreg2 performs the following signed operations:"
""
"mmreg1[15:0] = (mmreg1[15:0] > mmreg2[15:0]) ? mmreg1[15:0] : mmreg2[15:0]"
"mmreg1[31:16] = (mmreg1[31:16] > mmreg2[31:16]) ? mmreg1[31:16] : mmreg2[31:16]"
"mmreg1[47:32] = (mmreg1[47:32] > mmreg2[47:32]) ? mmreg1[47:32] : mmreg2[47:32]"
"mmreg1[63:48] = (mmreg1[63:48] > mmreg2[63:48]) ? mmreg1[63:48] : mmreg2[63:48]"
""
"PMAXSW mmreg, mem64 performs the following signed operations:"
"mmreg[15:0] = (mmreg[15:0] > mem64[15:0]) ? mmreg[15:0] : mem64[15:0]"
"mmreg[31:16] = (mmreg[31:16] > mem64[31:16]) ? mmreg[31:16] : mem64[31:16]"
"mmreg[47:32] = (mmreg[47:32] > mem64[47:32]) ? mmreg[47:32] : mem64[47:32]"
"mmreg[63:48] = (mmreg[63:48] > mem64[63:48]) ? mmreg[63:48] : mem64[63:48]"
[3]
"None."
[4]
"Protected Mode Exceptions"
""
"#Invalid Opcode, The emulate instruction bit (EM) of the control register (CR0) is set to 1."
"#Device Not Available, Save the floating-point or MMX state if the task switch bit (TS) of the control register (CR0) is set to 1."
"#Stack Exception, During instruction execution, the stack segment limit was exceeded."
"#General Protection, During instruction execution, the effective address of one of the segment registers used for the operand points to an illegal memory location."
"#Page fault, A page fault resulted from the execution of the instruction."
"#Float point exception pending, An exception is pending due to the floating-point execution unit."
"#Alignment check, An unaligned memory reference resulted from the instruction execution, and the alignment mask bit (AM) of the control register (CR0) is set to 1. (In Protected Mode, CPL = 3.)"
""
"Real-Address Mode Exceptions"
""
"#Invalid Opcode, The emulate instruction bit (EM) of the control register (CR0) is set to 1."
"#Device Not Available, Save the floating-point or MMX state if the task switch bit (TS) of the control register (CR0) is set to 1."
"#Segment Overrun, One of the instruction data operands falls outside the address range 00000h to 0FFFFh."
"#Float point exception pending, An exception is pending due to the floating-point execution unit."
""
"Virtual-8086 Mode Exceptions"
""
"#Invalid Opcode, The emulate instruction bit (EM) of the control register (CR0) is set to 1."
"#Device Not Available, Save the floating-point or MMX state if the task switch bit (TS) of the control register (CR0) is set to 1."
"#Segment Overrun, One of the instruction data operands falls outside the address range 00000h to 0FFFFh."
"#Page fault, A page fault resulted from the execution of the instruction."
"#Float point exception pending, An exception is pending due to the floating-point execution unit."
"#Alignment check, An unaligned memory reference resulted from the instruction execution, and the alignment mask bit (AM) of the control register (CR0) is set to 1. (In Protected Mode, CPL = 3.)"
[5]
"0F EE /r PMAXSW mmreg1, mmreg2 or PMAXSW mmreg, mem64"
[6]
</PMAXSW>
<PMAXUB>
[1]
"PMAXUB: Packed maximum unsigned byte"
""
"The PMAXUB instruction operates on unsigned 8-bit data and selects the maximum unsigned value between source 1 and source 2 for each of the eight byte positions."
[2]
"PMAXUB mmreg1, mmreg2 performs the following unsigned operations:"
""
"mmreg1[7:0] = (mmreg1[7:0] > mmreg2[7:0]) ? mmreg1[7:0] : mmreg2[7:0]"
"mmreg1[15:8] = (mmreg1[15:8] > mmreg2[15:8]) ? mmreg1[15:8] : mmreg2[15:8]"
"mmreg1[23:16] = (mmreg1[23:16] > mmreg2[23:16]) ? mmreg1[23:16] : mmreg2[23:16]"
"mmreg1[31:24] = (mmreg1[31:24] > mmreg2[31:24]) ? mmreg1[31:24] : mmreg2[31:24]"
"mmreg1[39:32] = (mmreg1[39:32] > mmreg2[39:32]) ? mmreg1[39:32] : mmreg2[39:32]"
"mmreg1[47:40] = (mmreg1[47:40] > mmreg2[47:40]) ? mmreg1[47:40] : mmreg2[47:40]"
"mmreg1[55:48] = (mmreg1[55:48] > mmreg2[55:48]) ? mmreg1[55:48] : mmreg2[55:48]"
"mmreg1[63:56] = (mmreg1[63:56] > mmreg2[63:56]) ? mmreg1[63:56] : mmreg2[63:56]"
""
"PMAXUB mmreg, mem64 performs the following unsigned operations:"
""
"mmreg[7:0] = (mmreg[7:0] > mem64[7:0]) ? mmreg[7:0] : mem64[7:0]"
"mmreg[15:8] = (mmreg[15:8] > mem64[15:8]) ? mmreg[15:8] : mem64[15:8]"
"mmreg[23:16] = (mmreg[23:16] > mem64[23:16]) ? mmreg[23:16] : mem64[23:16]"
"mmreg[31:24] = (mmreg[31:24] > mem64[31:24]) ? mmreg[31:24] : mem64[31:24]"
"mmreg[39:32] = (mmreg[39:32] > mem64[39:32]) ? mmreg[39:32] : mem64[39:32]"
"mmreg[47:40] = (mmreg[47:40] > mem64[47:40]) ? mmreg[47:40] : mem64[47:40]"
"mmreg[55:48] = (mmreg[55:48] > mem64[55:48]) ? mmreg[55:48] : mem64[55:48]"
"mmreg[63:56] = (mmreg[63:56] > mem64[63:56]) ? mmreg[63:56] : mem64[63:56]"
[3]
"None."
[4]
"Protected Mode Exceptions"
""
"#Invalid Opcode, The emulate instruction bit (EM) of the control register (CR0) is set to 1."
"#Device Not Available, Save the floating-point or MMX state if the task switch bit (TS) of the control register (CR0) is set to 1."
"#Stack Exception, During instruction execution, the stack segment limit was exceeded."
"#General Protection, During instruction execution, the effective address of one of the segment registers used for the operand points to an illegal memory location."
"#Page fault, A page fault resulted from the execution of the instruction."
"#Float point exception pending, An exception is pending due to the floating-point execution unit."
"#Alignment check, An unaligned memory reference resulted from the instruction execution, and the alignment mask bit (AM) of the control register (CR0) is set to 1. (In Protected Mode, CPL = 3.)"
""
"Real-Address Mode Exceptions"
""
"#Invalid Opcode, The emulate instruction bit (EM) of the control register (CR0) is set to 1."
"#Device Not Available, Save the floating-point or MMX state if the task switch bit (TS) of the control register (CR0) is set to 1."
"#Segment Overrun, One of the instruction data operands falls outside the address range 00000h to 0FFFFh."
"#Float point exception pending, An exception is pending due to the floating-point execution unit."
""
"Virtual-8086 Mode Exceptions"
""
"#Invalid Opcode, The emulate instruction bit (EM) of the control register (CR0) is set to 1."
"#Device Not Available, Save the floating-point or MMX state if the task switch bit (TS) of the control register (CR0) is set to 1."
"#Segment Overrun, One of the instruction data operands falls outside the address range 00000h to 0FFFFh."
"#Page fault, A page fault resulted from the execution of the instruction."
"#Float point exception pending, An exception is pending due to the floating-point execution unit."
"#Alignment check, An unaligned memory reference resulted from the instruction execution, and the alignment mask bit (AM) of the control register (CR0) is set to 1. (In Protected Mode, CPL = 3.)"
[5]
"0F DE /r PMAXUB mmreg1, mmreg2 or PMAXUB mmreg, mem64"
[6]
</PMAXUB>
<PMINSW>
[1]
"PMINSW: Packed minimum signed word"
""
"The PMINSW instruction operates on signed 16-bit data and selects the minimum arithmetic value between source 1 and source 2 for each word."
[2]
"PMINSW mmreg1, mmreg2 performs the following signed operations:"
""
"mmreg1[15:0] = (mmreg1[15:0] <= mmreg2[15:0]) ? mmreg1[15:0] : mmreg2[15:0]"
"mmreg1[31:16] = (mmreg1[31:16] <= mmreg2[31:16]) ? mmreg1[31:16] : mmreg2[31:16]"
"mmreg1[47:32] = (mmreg1[47:32] <= mmreg2[47:32]) ? mmreg1[47:32] : mmreg2[47:32]"
"mmreg1[63:48] = (mmreg1[63:48] <= mmreg2[63:48]) ? mmreg1[63:48] : mmreg2[63:48]"
""
"PMINSW mmreg, mem64 performs the following signed operations:"
""
"mmreg[15:0] = (mmreg[15:0] <= mem64[15:0]) ? mmreg[15:0] : mem64[15:0]"
"mmreg[31:16] = (mmreg[31:16] <= mem64[31:16]) ? mmreg[31:16] : mem64[31:16]"
"mmreg[47:32] = (mmreg[47:32] <= mem64[47:32]) ? mmreg[47:32] : mem64[47:32]"
"mmreg[63:48] = (mmreg[63:48] <= mem64[63:48]) ? mmreg[63:48] : mem64[63:48]"
[3]
"None."
[4]
"Protected Mode Exceptions"
""
"#Invalid Opcode, The emulate instruction bit (EM) of the control register (CR0) is set to 1."
"#Device Not Available, Save the floating-point or MMX state if the task switch bit (TS) of the control register (CR0) is set to 1."
"#Stack Exception, During instruction execution, the stack segment limit was exceeded."
"#General Protection, During instruction execution, the effective address of one of the segment registers used for the operand points to an illegal memory location."
"#Page fault, A page fault resulted from the execution of the instruction."
"#Float point exception pending, An exception is pending due to the floating-point execution unit."
"#Alignment check, An unaligned memory reference resulted from the instruction execution, and the alignment mask bit (AM) of the control register (CR0) is set to 1. (In Protected Mode, CPL = 3.)"
""
"Real-Address Mode Exceptions"
""
"#Invalid Opcode, The emulate instruction bit (EM) of the control register (CR0) is set to 1."
"#Device Not Available, Save the floating-point or MMX state if the task switch bit (TS) of the control register (CR0) is set to 1."
"#Segment Overrun, One of the instruction data operands falls outside the address range 00000h to 0FFFFh."
"#Float point exception pending, An exception is pending due to the floating-point execution unit."
""
"Virtual-8086 Mode Exceptions"
""
"#Invalid Opcode, The emulate instruction bit (EM) of the control register (CR0) is set to 1."
"#Device Not Available, Save the floating-point or MMX state if the task switch bit (TS) of the control register (CR0) is set to 1."
"#Segment Overrun, One of the instruction data operands falls outside the address range 00000h to 0FFFFh."
"#Page fault, A page fault resulted from the execution of the instruction."
"#Float point exception pending, An exception is pending due to the floating-point execution unit."
"#Alignment check, An unaligned memory reference resulted from the instruction execution, and the alignment mask bit (AM) of the control register (CR0) is set to 1. (In Protected Mode, CPL = 3.)"
[5]
"0F EA /r PMINSW mmreg1, mmreg2 or PMINSW mmreg, mem64"
[6]
</PMINSW>
<PMINUB>
[1]
"PMINUB: Packed minimum unsigned byte"
""
"The PMINUB instruction operates on unsigned 8-bit data and selects the minimum value between source 1 and source 2 for each byte position."
[2]
"PMINUB mmreg1, mmreg2 performs the following unsigned operations:"
""
"mmreg1[7:0] = (mmreg1[7:0] <= mmreg2[7:0]) ? mmreg1[7:0] : mmreg2[7:0]"
"mmreg1[15:8] = (mmreg1[15:8] <= mmreg2[15:8]) ? mmreg1[15:8] : mmreg2[15:8]"
"mmreg1[23:16] = (mmreg1[23:16] <= mmreg2[23:16]) ? mmreg1[23:16] : mmreg2[23:16]"
"mmreg1[31:24] = (mmreg1[31:24] <= mmreg2[31:24]) ? mmreg1[31:24] : mmreg2[31:24]"
"mmreg1[39:32] = (mmreg1[39:32] <= mmreg2[39:32]) ? mmreg1[39:32] : mmreg2[39:32]"
"mmreg1[47:40] = (mmreg1[47:40] <= mmreg2[47:40]) ? mmreg1[47:40] : mmreg2[47:40]"
"mmreg1[55:48] = (mmreg1[55:48] <= mmreg2[55:48]) ? mmreg1[55:48] : mmreg2[55:48]"
"mmreg1[63:56] = (mmreg1[63:56] <= mmreg2[63:56]) ? mmreg1[63:56] : mmreg2[63:56]"
""
"PMINUB mmreg1, mem64 performs the following unsigned operations:"
""
"mmreg[7:0] = (mmreg[7:0] <= mem64[7:0]) ? mmreg[7:0] : mem64[7:0]"
"mmreg[15:8] = (mmreg[15:8] <= mem64[15:8]) ? mmreg[15:8] : mem64[15:8]"
"mmreg[23:16] = (mmreg[23:16] <= mem64[23:16]) ? mmreg[23:16] : mem64[23:16]"
"mmreg[31:24] = (mmreg[31:24] <= mem64[31:24]) ? mmreg[31:24] : mem64[31:24]"
"mmreg[39:32] = (mmreg[39:32] <= mem64[39:32]) ? mmreg[39:32] : mem64[39:32]"
"mmreg[47:40] = (mmreg[47:40] <= mem64[47:40]) ? mmreg[47:40] : mem64[47:40]"
"mmreg[55:48] = (mmreg[55:48] <= mem64[55:48]) ? mmreg[55:48] : mem64[55:48]"
"mmreg[63:56] = (mmreg[63:56] <= mem64[63:56]) ? mmreg[63:56] : mem64[63:56]"
[3]
"None."
[4]
"Protected Mode Exceptions"
""
"#Invalid Opcode, The emulate instruction bit (EM) of the control register (CR0) is set to 1."
"#Device Not Available, Save the floating-point or MMX state if the task switch bit (TS) of the control register (CR0) is set to 1."
"#Stack Exception, During instruction execution, the stack segment limit was exceeded."
"#General Protection, During instruction execution, the effective address of one of the segment registers used for the operand points to an illegal memory location."
"#Page fault, A page fault resulted from the execution of the instruction."
"#Float point exception pending, An exception is pending due to the floating-point execution unit."
"#Alignment check, An unaligned memory reference resulted from the instruction execution, and the alignment mask bit (AM) of the control register (CR0) is set to 1. (In Protected Mode, CPL = 3.)"
""
"Real-Address Mode Exceptions"
""
"#Invalid Opcode, The emulate instruction bit (EM) of the control register (CR0) is set to 1."
"#Device Not Available, Save the floating-point or MMX state if the task switch bit (TS) of the control register (CR0) is set to 1."
"#Segment Overrun, One of the instruction data operands falls outside the address range 00000h to 0FFFFh."
"#Float point exception pending, An exception is pending due to the floating-point execution unit."
""
"Virtual-8086 Mode Exceptions"
""
"#Invalid Opcode, The emulate instruction bit (EM) of the control register (CR0) is set to 1."
"#Device Not Available, Save the floating-point or MMX state if the task switch bit (TS) of the control register (CR0) is set to 1."
"#Segment Overrun, One of the instruction data operands falls outside the address range 00000h to 0FFFFh."
"#Page fault, A page fault resulted from the execution of the instruction."
"#Float point exception pending, An exception is pending due to the floating-point execution unit."
"#Alignment check, An unaligned memory reference resulted from the instruction execution, and the alignment mask bit (AM) of the control register (CR0) is set to 1. (In Protected Mode, CPL = 3.)"
[5]
"0F DA /r PMINUB mmreg1, mmreg2 or PMINUB mmreg, mem64"
[6]
</PMINUB>
<PMOVMSKB>
[1]
"PMOVMSKB: Move mask to integer register"
""
"The PMOVMSKB instruction selects the most significant bit from each byte position of an MMX register and collapses all eight bits into the least significant byte of an integer register."
[2]
"PMOVMSKB reg32, mmreg performs the following operations:"
""
"reg32[31:8] = 0"
"reg32[7] = mmreg[63]"
"reg32[6] = mmreg[55]"
"reg32[5] = mmreg[47]"
"reg32[4] = mmreg[39]"
"reg32[3] = mmreg[31]"
"reg32[2] = mmreg[23]"
"reg32[1] = mmreg[15]"
"reg32[0] = mmreg[7]"
[3]
"None."
[4]
"Protected Mode Exceptions"
""
"#Invalid Opcode, The emulate instruction bit (EM) of the control register (CR0) is set to 1."
"#Device Not Available, Save the floating-point or MMX state if the task switch bit (TS) of the control register (CR0) is set to 1."
"#Stack Exception, During instruction execution, the stack segment limit was exceeded."
"#General Protection, During instruction execution, the effective address of one of the segment registers used for the operand points to an illegal memory location."
"#Page fault, A page fault resulted from the execution of the instruction."
"#Float point exception pending, An exception is pending due to the floating-point execution unit."
"#Alignment check, An unaligned memory reference resulted from the instruction execution, and the alignment mask bit (AM) of the control register (CR0) is set to 1. (In Protected Mode, CPL = 3.)"
""
"Real-Address Mode Exceptions"
""
"#Invalid Opcode, The emulate instruction bit (EM) of the control register (CR0) is set to 1."
"#Device Not Available, Save the floating-point or MMX state if the task switch bit (TS) of the control register (CR0) is set to 1."
"#Segment Overrun, One of the instruction data operands falls outside the address range 00000h to 0FFFFh."
"#Float point exception pending, An exception is pending due to the floating-point execution unit."
""
"Virtual-8086 Mode Exceptions"
""
"#Invalid Opcode, The emulate instruction bit (EM) of the control register (CR0) is set to 1."
"#Device Not Available, Save the floating-point or MMX state if the task switch bit (TS) of the control register (CR0) is set to 1."
"#Segment Overrun, One of the instruction data operands falls outside the address range 00000h to 0FFFFh."
"#Page fault, A page fault resulted from the execution of the instruction."
"#Float point exception pending, An exception is pending due to the floating-point execution unit."
"#Alignment check, An unaligned memory reference resulted from the instruction execution, and the alignment mask bit (AM) of the control register (CR0) is set to 1. (In Protected Mode, CPL = 3.)"
[5]
"0F D7 /r PMOVMSKB reg32, mmreg"
[6]
</PMOVMSKB>
<PMULHUW>
[1]
"PMULHUW: Packed multiply high unsigned word"
""
"The PMULHUW instruction multiplies the four unsigned words in the source operand with the four unsigned words in the destination operand. The upper 16 bits of the 32-bit intermediate result is placed into the destination operand."
[2]
"PMULHUW mmreg1, mmreg2 performs the following operations:"
""
"mmreg1[15:0] = (mmreg1[15:0] * mmreg2[15:0])[31:16]"
"mmreg1[31:16] = (mmreg1[31:16] * mmreg2[31:16])[31:16]"
"mmreg1[47:32] = (mmreg1[47:32] * mmreg2[47:32])[31:16]"
"mmreg1[63:48] = (mmreg1[63:48] * mmreg2[63:48])[31:16]"
"PMULHUW mmreg, mem64 performs the following operations:"
""
"mmreg[15:0] = (mmreg[15:0] * mem64[15:0])[31:16]"
"mmreg[31:16] = (mmreg[31:16] * mem64[31:16])[31:16]"
"mmreg[47:32] = (mmreg[47:32] * mem64[47:32])[31:16]"
"mmreg[63:48] = (mmreg[63:48] * mem64[63:48])[31:16]"
[3]
"None."
[4]
"Protected Mode Exceptions"
""
"#Invalid Opcode, The emulate instruction bit (EM) of the control register (CR0) is set to 1."
"#Device Not Available, Save the floating-point or MMX state if the task switch bit (TS) of the control register (CR0) is set to 1."
"#Stack Exception, During instruction execution, the stack segment limit was exceeded."
"#General Protection, During instruction execution, the effective address of one of the segment registers used for the operand points to an illegal memory location."
"#Page fault, A page fault resulted from the execution of the instruction."
"#Float point exception pending, An exception is pending due to the floating-point execution unit."
"#Alignment check, An unaligned memory reference resulted from the instruction execution, and the alignment mask bit (AM) of the control register (CR0) is set to 1. (In Protected Mode, CPL = 3.)"
""
"Real-Address Mode Exceptions"
""
"#Invalid Opcode, The emulate instruction bit (EM) of the control register (CR0) is set to 1."
"#Device Not Available, Save the floating-point or MMX state if the task switch bit (TS) of the control register (CR0) is set to 1."
"#Segment Overrun, One of the instruction data operands falls outside the address range 00000h to 0FFFFh."
"#Float point exception pending, An exception is pending due to the floating-point execution unit."
""
"Virtual-8086 Mode Exceptions"
""
"#Invalid Opcode, The emulate instruction bit (EM) of the control register (CR0) is set to 1."
"#Device Not Available, Save the floating-point or MMX state if the task switch bit (TS) of the control register (CR0) is set to 1."
"#Segment Overrun, One of the instruction data operands falls outside the address range 00000h to 0FFFFh."
"#Page fault, A page fault resulted from the execution of the instruction."
"#Float point exception pending, An exception is pending due to the floating-point execution unit."
"#Alignment check, An unaligned memory reference resulted from the instruction execution, and the alignment mask bit (AM) of the control register (CR0) is set to 1. (In Protected Mode, CPL = 3.)"
[5]
"0F E4 /r PMULHUW mmreg1, mmreg2 or PMULHUW mmreg, mem64"
[6]
</PMULHUW>
<PREFETCHNTA>
<PREFETCHT0>
<PREFETCHT1>
<PREFETCHT2>
[1]
"PREFETCHNTA: Move data closer to the processor using the NTA reference."
"PREFETCHT0: Move data closer to the processor using the T0 reference."
"PREFETCHT1: Move data closer to the processor using the T1 reference."
"PREFETCHT2: Move data closer to the processor using the T2 reference."
""
"The prefetch instruction brings a cache line into the processor cache level(s) specified by a locality reference. The address of the prefetched cache line is specified by the mem8 value. The prefetch instruction loads a cache line even if the mem8 address is not aligned with the start of the line. If a cache level, which is closer than the locality reference, already has the cache line, or a memory fault is detected, then no bus cycle is initiated and the instruction is treated as a NOP."
""
"The operation of the prefetch instructions is processor implementation dependent. The instructions can be ignored or changed by a processor implementation, though they will not change program behavior. The cache line size is also implementation dependent having a minimum size of 32 bytes. Bits 5:3 of the ModR/M byte indicate the cache locality references."
[2]
"NTA Move specified data into processor and minimize cache pollution."
"T0 Move specified data into all cache levels."
"T1 Move specified data into all cache levels except 0th level cache."
"T2 Move specified data into all cache levels except 0th and 1st level caches."
""
"Note: A 0th level cache is implementation dependent."
[3]
"None."
[4]
"None."
[5]
"0F 18 /0 PREFETCHNTA mem8"
"0F 18 /1 PREFETCHT0 mem8"
"0F 18 /2 PREFETCHT1 mem8"
"0F 18 /3 PREFETCHT2 mem8"
[6]
</PREFETCHNTA>
</PREFETCHT0>
</PREFETCHT1>
</PREFETCHT2>
<PSADBW>
[1]
"PSADBW: Packed sum of absolute byte differences"
""
"The PSADBW instruction is the sum of the absolute value of the differences between each byte position of source 1 and source 2."
[2]
"PSADBW mmreg1, mmreg2 performs the following operations:"
""
"mmreg1[63:16] = 0"
"mmreg1[15:0] = abs(mmreg1[7:0] – mmreg2[7:0]) +"
"abs(mmreg1[15:8] – mmreg2[15:8]) +"
"abs(mmreg1[23:16] – mmreg2[23:16]) +"
"abs(mmreg1[31:24] – mmreg2[31:24]) +"
"abs(mmreg1[39:32] – mmreg2[39:32]) +"
"abs(mmreg1[47:40] – mmreg2[47:40]) +"
"abs(mmreg1[55:48] – mmreg2[55:48]) +"
"abs(mmreg1[63:56] – mmreg2[63:56])"
""
"PSADBW mmreg, mem64 performs the following operations:"
""
"mmreg[63:16] = 0"
"mmreg[15:0] = abs(mmreg[7:0] – mem64[7:0]) +"
"abs(mmreg[15:8] – mem64[15:8]) +"
"abs(mmreg[23:16] – mem64[23:16]) +"
"abs(mmreg[31:24] – mem64[31:24]) +"
"abs(mmreg[39:32] – mem64[39:32]) +"
"abs(mmreg[47:40] – mem64[47:40]) +"
"abs(mmreg[55:48] – mem64[55:48]) +"
"abs(mmreg[63:56] – mem64[63:56])"
[3]
"None."
[4]
"Protected Mode Exceptions"
""
"#Invalid Opcode, The emulate instruction bit (EM) of the control register (CR0) is set to 1."
"#Device Not Available, Save the floating-point or MMX state if the task switch bit (TS) of the control register (CR0) is set to 1."
"#Stack Exception, During instruction execution, the stack segment limit was exceeded."
"#General Protection, During instruction execution, the effective address of one of the segment registers used for the operand points to an illegal memory location."
"#Page fault, A page fault resulted from the execution of the instruction."
"#Float point exception pending, An exception is pending due to the floating-point execution unit."
"#Alignment check, An unaligned memory reference resulted from the instruction execution, and the alignment mask bit (AM) of the control register (CR0) is set to 1. (In Protected Mode, CPL = 3.)"
""
"Real-Address Mode Exceptions"
""
"#Invalid Opcode, The emulate instruction bit (EM) of the control register (CR0) is set to 1."
"#Device Not Available, Save the floating-point or MMX state if the task switch bit (TS) of the control register (CR0) is set to 1."
"#Segment Overrun, One of the instruction data operands falls outside the address range 00000h to 0FFFFh."
"#Float point exception pending, An exception is pending due to the floating-point execution unit."
""
"Virtual-8086 Mode Exceptions"
""
"#Invalid Opcode, The emulate instruction bit (EM) of the control register (CR0) is set to 1."
"#Device Not Available, Save the floating-point or MMX state if the task switch bit (TS) of the control register (CR0) is set to 1."
"#Segment Overrun, One of the instruction data operands falls outside the address range 00000h to 0FFFFh."
"#Page fault, A page fault resulted from the execution of the instruction."
"#Float point exception pending, An exception is pending due to the floating-point execution unit."
"#Alignment check, An unaligned memory reference resulted from the instruction execution, and the alignment mask bit (AM) of the control register (CR0) is set to 1. (In Protected Mode, CPL = 3.)"
[5]
"0F F6 /r PSADBW mmreg1, mmreg2 or PSADBW mmreg, mem64"
[6]
</PSADBW>
<PSHUFW>
[1]
"PSHUFW: Packed shuffle word"
""
"The PSHUFW instruction rearranges the four words of an MMX register into one of 16 possible permutations as defined by an immediate byte."
[2]
"PSHUFW mmreg1, mmreg2, imm8 performs the following operations:"
""
"index3 = imm8[7:6] * 16"
"index2 = imm8[5:4] * 16"
"index1 = imm8[3:2] * 16"
"index0 = imm8[1:0] * 16"
"mmreg1[63:48] = mmreg2[index3+15:index3]"
"mmreg1[47:32] = mmreg2[index2+15:index2]"
"mmreg1[31:16] = mmreg2[index1+15:index1]"
"mmreg1[15:0] = mmreg2[index0+15:index0]"
""
"PSHUFW mmreg, mem64, imm8 performs the following operations:"
""
"index3 = imm8[7:6] * 16"
"index2 = imm8[5:4] * 16"
"index1 = imm8[3:2] * 16"
"index0 = imm8[1:0] * 16"
"mmreg[63:48] = mem64[index3+15:index3]"
"mmreg[47:32] = mem64[index2+15:index2]"
"mmreg[31:16] = mem64[index1+15:index1]"
"mmreg[15:0] = mem64[index0+15:index0]"
[3]
"None."
[4]
"Protected Mode Exceptions"
""
"#Invalid Opcode, The emulate instruction bit (EM) of the control register (CR0) is set to 1."
"#Device Not Available, Save the floating-point or MMX state if the task switch bit (TS) of the control register (CR0) is set to 1."
"#Stack Exception, During instruction execution, the stack segment limit was exceeded."
"#General Protection, During instruction execution, the effective address of one of the segment registers used for the operand points to an illegal memory location."
"#Page fault, A page fault resulted from the execution of the instruction."
"#Float point exception pending, An exception is pending due to the floating-point execution unit."
"#Alignment check, An unaligned memory reference resulted from the instruction execution, and the alignment mask bit (AM) of the control register (CR0) is set to 1. (In Protected Mode, CPL = 3.)"
""
"Real-Address Mode Exceptions"
""
"#Invalid Opcode, The emulate instruction bit (EM) of the control register (CR0) is set to 1."
"#Device Not Available, Save the floating-point or MMX state if the task switch bit (TS) of the control register (CR0) is set to 1."
"#Segment Overrun, One of the instruction data operands falls outside the address range 00000h to 0FFFFh."
"#Float point exception pending, An exception is pending due to the floating-point execution unit."
""
"Virtual-8086 Mode Exceptions"
""
"#Invalid Opcode, The emulate instruction bit (EM) of the control register (CR0) is set to 1."
"#Device Not Available, Save the floating-point or MMX state if the task switch bit (TS) of the control register (CR0) is set to 1."
"#Segment Overrun, One of the instruction data operands falls outside the address range 00000h to 0FFFFh."
"#Page fault, A page fault resulted from the execution of the instruction."
"#Float point exception pending, An exception is pending due to the floating-point execution unit."
"#Alignment check, An unaligned memory reference resulted from the instruction execution, and the alignment mask bit (AM) of the control register (CR0) is set to 1. (In Protected Mode, CPL = 3.)"
[5]
"0F 70 /r PSHUFW mmreg1, mmreg2, imm8 or PSHUFW mmreg, mem64, imm8"
[6]
</PSHUFW>
<SFENCE>
[1]
"SFENCE: Store fence"
""
"The SFENCE instructions makes all previous writes globally visible before any later writes."
[2]
"See Description."
[3]
"None."
[4]
"None."
[5]
"0F AE /7 SFENCE"
[6]
</PSHUFW>
