<WAIT>
[1]
"WAIT: Wait"
""
"Causes the processor to check for and handle pending, unmasked, floating-point exceptions before proceeding. (FWAIT is an alternate mnemonic for the WAIT). This instruction is useful for synchronizing exceptions in critical sections of code. Coding a WAIT instruction after a floating-point instruction insures that any unmasked floating-point exceptions the instruction may raise are handled before the processor can modify the instruction’s results."
[2]
"CheckForPendingUnmaskedFloatingPointExceptions;"
[3]
"The C0, C1, C2, and C3 flags are undefined."
[4]
"Floating-Point Exceptions"
""
"None."
""
"Protected Mode Exceptions"
""
"#NM MP and TS in CR0 is set."
""
"Real-Address Mode Exceptions"
""
"#NM MP and TS in CR0 is set."
""
"Virtual-8086 Mode Exceptions"
""
"#NM MP and TS in CR0 is set."
[5]
"9B WAIT Check pending unmasked floating-point exceptions."
[6]
</WAIT>
<WBINVD>
[1]
"WBINVD: Write Back and Invalidate Cache"
""
"Writes back all modified cache lines in the processor’s internal cache to main memory and invalidates (flushes) the internal caches. The instruction then issues a special-function bus cycle that directs external caches to also write back modified data and another bus cycle to indicate that the external caches should be invalidated."
"After executing this instruction, the processor does not wait for the external caches to complete their write-back and flushing operations before proceeding with instruction execution. It is the responsibility of hardware to respond to the cache write-back and flush signals. The WDINVD instruction is a privileged instruction. When the processor is running in protected mode, the CPL of a program or procedure must be 0 to execute this instruction. This instruction is also a serializing instruction."
""
"Intel Architecture Compatibility"
""
"The WBINVD instruction is implementation dependent, and its function may be implemented differently on future Intel Architecture processors. The instruction is not supported on Intel Architecture processors earlier than the Intel486 processor."
[2]
"WriteBack(InternalCaches);"
"Flush(InternalCaches);"
"SignalWriteBack(ExternalCaches);"
"SignalFlush(ExternalCaches);"
"Continue (* Continue execution);"
[3]
"None."
[4]
"Protected Mode Exceptions"
""
"#GP(0) If the current privilege level is not 0."
""
"Real-Address Mode Exceptions"
""
"None."
""
"Virtual-8086 Mode Exceptions"
""
"#GP(0) The WBINVD instruction cannot be executed at the virtual-8086 mode."
[5]
"0F 09 WBINVD Write back and flush Internal caches; initiate writing-back and flushing of external caches."
[6]
</WBINVD>
<WRMSR>
[1]
"WRMSR: Write to Model Specific Register"
""
"Writes the contents of registers EDX:EAX into the 64-bit model specific register (MSR) specified in the ECX register. The high-order 32 bits are copied from EDX and the low-order 32 bits are copied from EAX. Always set the undefined or reserved bits in an MSR to the values previously read."
"This instruction must be executed at privilege level 0 or in real-address mode; otherwise, a general protection exception #GP(0) will be generated. Specifying a reserved or unimplemented MSR address in ECX will also cause a general protection exception."
"When the WRMSR instruction is used to write to an MTRR, the TLBs are invalidated, including the global entries. (MTRRs are an implementation-specific feature of the Pentium Pro processor.)"
""
"Intel Architecture Compatibility"
""
"The MSRs and the ability to read them with the WRMSR instruction were introduced into the Intel Architecture with the Pentium processor. Execution of this instruction by an Intel Architecture processor earlier than the Pentium processor results in an invalid opcode exception #UD."
[2]
"MSR[ECX] ¬ EDX:EAX;"
[3]
"None."
[4]
"Protected Mode Exceptions"
""
"#GP(0) If the current privilege level is not 0. If the value in ECX specifies a reserved or unimplemented MSR address."
""
"Real-Address Mode Exceptions"
""
"#GP If the value in ECX specifies a reserved or unimplemented MSR address."
""
"Virtual-8086 Mode Exceptions"
""
"#GP(0) The WRMSR instruction is not recognized in virtual-8086 mode."
[5]
"0F 30 WRMSR Write the value in EDX:EAX to MSR specified by ECX"
[6]
</WRMSR>